#!/usr/bin/env python3


'''a stripped down version of HackAssembler

    Error checking has been replaced with stubs for clarity.'''


import re
import sys


def abort_assembly(nl=0):
    '''print error message and exit

    This is a stub.'''

    print('error on line', nl)
    sys.exit()


def mk_A_hack(n):
    return '{:016b}\n'.format(n)

if len(sys.argv) != 2:  # argv[0] == program name
    abort_assembly()    # argv[1] == input file

infile = sys.argv[1]

if not infile.endswith('.asm'):
    abort_assembly()

outfile = infile[:-4] + ".hack"

comp_tab = {
    "0"   : "101010",
    "1"   : "111111",
    "-1"  : "111010",
    "D"   : "001100",
    "A"   : "110000",
    "M"   : "110000",
    "!D"  : "001101",
    "!A"  : "110001",
    "!M"  : "110001",
    "-D"  : "001111",
    "-A"  : "110011",
    "-M"  : "110011",
    "D+1" : "011111",
    "A+1" : "110111",
    "M+1" : "110111",
    "D-1" : "001110",
    "A-1" : "110010",
    "M-1" : "110010",
    "D+A" : "000010",
    "D+M" : "000010",
    "D-A" : "010011",
    "D-M" : "010011",
    "A-D" : "000111",
    "M-D" : "000111",
    "D&A" : "000000",
    "D&M" : "000000",
    "D|A" : "010101",
    "D|M" : "010101"
}

jump_tab = {
    ""    : "000",
    "JLT" : "100",
    "JGT" : "001",
    "JNE" : "101",
    "JEQ" : "010",
    "JLE" : "110",
    "JGE" : "011",
    "JMP" : "111"
}

sym_tab = {
    "SP"     : 0,
    "LCL"    : 1,
    "ARG"    : 2,
    "THIS"   : 3,
    "THAT"   : 4,
    "SCREEN" : 16384,
    "KBD"    : 24576
}

nsym = 16
re_symbol = re.compile('[$:.\w]+')
re_asm = re.compile('[01ADMEGJLNPQT=;!+&|-]{1,11}')
digit = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9') 


# This is a bit of a misnomer
def decomment(line):
    '''remove comments and external white space'''
    return line.split("//")[0].strip()

with open(infile, "Ur") as fi:
    asm = fi.readlines()

#  install labels to symbol table
maddr = 1  # memory address of cpu instruction for label
for nl, line in enumerate(asm):

    nl += 1  # line number, not index

    # This will make any lines with no code the empty string.
    line = decomment(line)

    if not line:
        continue

    if line.startswith('('):

        sym = line.strip('()')

        if not re_symbol.fullmatch(sym) or sym.startswith(digit):
            abort_assembly(nl)

        if sym in sym_tab:
            abort_assembly(nl)

        sym_tab[sym] = maddr

    else:
        maddr += 1

fo = open(outfile, "w")

# assemble
for nl, line in enumerate(asm):

    nl += 1

    line = decomment(line)

    if not line or line.startswith('('):
        continue

    if line.startswith('@'):  # A instruction

        line = line[1:]

        if line.startswith('R'):  # could be a register
            reg = line[1:]
            if reg.isdigit():
                reg = int(reg)
                if 0 <= reg <= 15:
                    fo.write(mk_A_hack(reg))

        elif re_symbol.fullmatch(line):

            if line.startswith(digit):
                abort_assembly(nl)

            if line not in sym_tab:
                sym_tab[line] = nsym  
                nsym += 1

            ref = sym_tab[line]

            fo.write(mk_A_hack(ref))

        elif line.isdigit():
            fo.write(mk_A_hack(int(line)))

        else:
            abort_assembly(nl)

    else:  # C instruction

        # remove internal whitespace
        line = ''.join(line.split())

        if not re_asm.fullmatch(line)  \
                or line.count('=') > 1 \
                or line.count(';') > 1:
            abort_assembly(nl)

        eq = line.index('=') if '=' in line else 0
        sc = line.index(';') if ';' in line else len(line)

        dest = line[:eq]
        comp = line[eq:sc].strip('=')
        jump = line[sc:].strip(';')

        # build hack line
        hack = '111'

        # a field
        hack += '1' if 'M' in comp else '0'

        # comp field
        if comp not in comp_tab:
            abort_assembly(nl)
        hack += comp_tab[comp]

        # dest field
        if not re.fullmatch('[ADM]*', dest):
            abort_assembly(nl)
        hack += '1' if 'A' in dest else '0'
        hack += '1' if 'D' in dest else '0'
        hack += '1' if 'M' in dest else '0'

        # jump field
        if jump not in jump_tab:
            abort_assembly(nl)
        hack += jump_tab[jump]

        hack += '\n'

        fo.write(hack)

fo.close()
