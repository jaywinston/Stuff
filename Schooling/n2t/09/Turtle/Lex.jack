class Lex {

    static String WORDDLMS;


    function void init() {

        let WORDDLMS = String.new(4);
        do WORDDLMS.appendChar(32);   // ' '
        do WORDDLMS.appendChar(34);   // '"'
        do WORDDLMS.appendChar(61);   // '='
        do WORDDLMS.appendChar(123);  // '{'

        return;
    }


    /* collect substring of nested blocks delimited by l and r from s into t;
     * return last used index + 1
     */
    function int block(String s, String t, char l, char r, int i) {
        /* i + 1 is returned because the loop breaks on the closing delim.
           Adding one to the index indicates EOS where appropriate or
           an unclosed block as i will be greater than s.length().
           Or it conveniently places i on what is likely an operator. */
        var char c;
        var int blk, sLen;

        let sLen = s.length();
        let blk = 0;
        while (i < sLen) {
            let c = s.charAt(i);
            do t.appendChar(c);
            if (c = l) {
                let blk = blk + 1;
            } else { if (c = r) {
                let blk = blk - 1;
            }}
            if (blk = 0) {
                return i + 1;
            }
            let i = i + 1;
        }

        return i + 1;
    }


    function int quotes(String s, String t, int i) {
        var char c;
        var int len;

        let len = s.length();
        do t.appendChar(s.charAt(i));
        let i = i + 1;
        
        while (i < len) {
            let c = s.charAt(i);
            do t.appendChar(c);
            if (c = 34) {
                return i + 1;
            }
            let i = i + 1;
        }

        return i + 1;  // EOS while scanning for quote
    }


    function int word(String s, String t, int i) {

        let i = Str.tkn(s, t, WORDDLMS, i);

        if (i < s.length()) {
            if (s.charAt(i) = 34) {
                let i = Lex.quotes(s, t, i);
                if (i > s.length()) {
                    do Error.send("unclosed quote");  // ##DB##
                    do Error.set(1);  // unclosed quote
                }
            } else { if (s.charAt(i) = 123) {
                let i = Lex.block(s, t, 123, 125, i);
            } else { if (s.charAt(i) = 61) {
                do t.appendChar(61);
                let i = Lex.word(s, t, i+1);
            }}}
        }

        if (i < s.length()) { if (~(s.charAt(i) = 32)) {
            let i = Lex.word(s, t, i);
        }}

        return i;
    }


    function int integer(String s, String t, String list, int i) {

        /* unary ops: '-' '~'; evaluated with term */
        while ((s.charAt(i)=45) | (s.charAt(i)=126)) {
            do t.appendChar(s.charAt(i));
            let i = i + 1;
        }

        if (s.charAt(i) = 40) {
            let i = Lex.block(s, t, 40, 41, i);
            if (i > s.length()) {
                do Error.send("unclosed parentheses");  // ##DB##
                do Error.set(1);  // unclosed parentheses
                return i;
            }
        } else { if (s.charAt(i) = 123) {
            let i = Lex.block(s, t, 123, 125, i);
        }}

        let i = Str.tkn(s, t, list, i);

        /* this includes case of op at s[0] ... */
        if (t.length() = 0) {
            do Error.send("unexpected operator");  // ##DB##
            do Error.set(1);  // unexpected operator
            return i;
        }

        /* ... which would crash here.
           But this covers the case of op after uop, e.g. "-+". */
        if ( (s.charAt(i-1)=45) | (s.charAt(i-1)=126) ) {
            do Error.send("unexpected operator");  // ##DB##
            do Error.set(1);  // unexpected operator
            return i;
        }

        if (i < s.length()) {
            if (s.charAt(i) = 40) {
                let i = Lex.block(s, t, 40, 41, i);
                if (i > s.length()) {
                    do Error.send("unclosed parentheses");  // ##DB##
                    do Error.set(1);  // unclosed parentheses
                    return i;
                }
            if (i < s.length()) {
                let i = Lex.integer(s, t, list, i);
            }
            } else { if (s.charAt(i) = 123) {
                let i = Lex.block(s, t, 123, 125, i);
            }}
        }

        return i;
    }

}
