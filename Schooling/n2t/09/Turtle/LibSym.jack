// CTAB is an array of size 128.  It is used as something of a hashtable
// in that it is indexed by a character.  Its values are a bitmap of the
// character's type.  That bitmap is also used to implement arithmetic
// operator precedence.  Most types are one-bit values.  Block types
// and integer types have subtypes.  Block types are used by LibSym
// list functions to recurse on the symbol's data.  Integer types are
// used to announce an integer expression tree and afterwards, are masked
// and used for arithmetic operator precedence.
// 
// The bitmap is:
//   32768 16384 8192 4096 2048 1024 512 256 128  64  32  16   8   4   2   1
//       |     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//  unused     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//  symbol token    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//      integer token    |    |    |   |   |   |   |   |   |   |   |   |   |
//          string literal    |    |   |   |   |   |   |   |   |   |   |   |
//                  white space    |   |   |   |   |   |   |   |   |   |   |  
//                               EOS   |   |   |   |   |   |   |   |   |   |
//                         illegal index   |   |   |   |   |   |   |   |   |
//                                       end   |   |   |   |   |   |   |   |
//                                                 |   |   |   |   |   |   |
//                                                 |   |   |   |   |   |   |
//                                                 |   |   |   |   |   |   |
//                                                 |   |   |   |   |   |   |
//                                                 |   |   |   |   |   |   |
//                                              list   |   |   |   |   |   |
//                                                 block   |   |   |   |   |
//                                         string expression   |   |   |   |
//                                 integer expression / operator   |   |   |
//                                                                  \  |  /
//                                                    operation precedance
//
// String expressions are calls to the format function.
// Integer expressions are compound expressions i.e. including one or
// more operators.

class LibSym {

    static int CMD, TTL, BLOCK, CMDLIN, FUNC, INTEX, LIST, STREX, STR, INT,
               SYM, OP, UOP;
    static int HACK_CHARSET_SIZE, EOS_MAP, NOLGL_MAP, CLASSMASK;


    function void init() {

        /* magic numbers! */
        let HACK_CHARSET_SIZE = 152;
        let CLASSMASK = -8;

        let EOS_MAP = HACK_CHARSET_SIZE;
        let NOLGL_MAP = HACK_CHARSET_SIZE + 1;

        let LIST   = Lex.cclass(91);          // 64
        let BLOCK  = Lex.cclass(123);         // 64
        let CMDLIN = Lex.cclass(123) + 1;     // 65
        let FUNC   = Lex.cclass(123) + 2;     // 66
        let INTEX  = Lex.cclass(40);          // 80
        let STREX  = Lex.cclass(44);          // 96
        let STR    = Lex.cclass(34);          // 256
        let INT    = Lex.cclass(48);          // 8192
        let SYM    = Lex.cclass(65);          // 16384
        let OP     = (Lex.cclass(38)-1) & ~INTEX;       // 8
        let UOP    = Lex.cclass(126) & (~BLOCK & ~OP);  // 16

        return;
    }


    function Array ctab() {
        var int i;
        var Array ctab;

        let ctab = Array.new(HACK_CHARSET_SIZE + 2);

        let i = 0;
        while (i < 128) {
            let ctab[i] = 0;
            let i = i + 1;
        }

        let i = 32;
        while (i < 127) {
            let ctab[i] = 16384;
            let i = i + 1;
        }

        let i = 48;
        while (i < 58) {
            let ctab[i] = 8192;
            let i = i + 1;
        }
 
        let ctab[ 91] =   128;  // [
        let ctab[ 40] =   144;  // (
        let ctab[ 38] =    89;  // &
        let ctab[124] =    89;  // |
        let ctab[ 61] =    90;  // =
        let ctab[ 33] =    91;  // !
        let ctab[ 60] =    91;  // <
        let ctab[ 62] =    91;  // >
        let ctab[ 43] =   152;  // +
        let ctab[ 45] =   152;  // -
        let ctab[126] =   152;  // ~
        let ctab[ 37] =   153;  // %
        let ctab[ 42] =   153;  // *
        let ctab[ 47] =   153;  // /
        let ctab[ 44] =   160;  // ,
        let ctab[123] =   192;  // {
        let ctab[ 93] =   256;  // ]
        let ctab[125] =   768;  // }
        let ctab[ 41] =  1280;  // )
        let ctab[ 32] =  2048;  //  
        let ctab[ 34] =  4096;  // "

        let ctab[NOLGL_MAP] =  512;  // illegal index
        let ctab[  EOS_MAP] = 1024;  // EOS

        return ctab;
    }


    function int TOKENMASK() { return CTAB[65] | CTAB[48]; }
    function int CHARSETSIZE() { return HACK_CHARSET_SIZE; }
    function int CLASSMASK() { return CLASSMASK; }


    function Symbol copySym(Symbol sym) {
        var int type;

        if (sym = null) {
            return null;
        }

        let type = sym.meta() & (LIST|STR);

        if (type = STR) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              Str.dup(sym.data()));
        }

        if (type = LIST) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              LibSym.copyList(sym.data()));
        }

        return Symbol.new(Str.dup(sym.tag()), sym.meta(), sym.data());
    }


    function Collection copyList(Collection list) {
        var int i;
        var Collection new;

        let new = Collection.new();
        let i = 0;
        while (i < list.length()) {
            do new.append(LibSym.copySym(list.nth(i)));
            let i = i + 1;
        }

        return new;
    }


    function void destroySym(Symbol sym) {
        var int type;
        var String s;

        if (sym = null) {
            return;
        }

        let s = sym.tag();

        if (~(s = null)) {
            do s.dispose();
        }

        let type = sym.meta() & (LIST|STR);

        if (type = LIST) {
            do LibSym.destroyList(sym.data());
        } else { if (type = STR) {
            let s = sym.data();
            do s.dispose();
        }}

        do sym.dispose();

        return;
    }


    function void destroyList(Collection list) {

        while (list.length() > 0) {
            do LibSym.destroySym(list.pop());
        }

        do list.dispose();

        return;
    }


    function void destroyHashTable(HashTable ht) {
        var int i;

        let i = 0;
        while (i < ht.hashSize()) {
            do LibSym.destroyList(ht.bucket(i));
            let i = i + 1;
        }

        do ht.dispose();

        return;
    }


    function void install(HashTable ht, String name, int type, int value) {
        var String s;
        var Symbol p;

        let p = ht.lookup(name);

        if (p = null) {
            do ht.install(Str.dup(name), type, value);
        } else {
            if (p.meta() = FUNC) {
                do LibSym.destroyList(p.data());
            } else { if (p.meta() = STR) {
                let s = p.data();
                do s.dispose();
            }}
            do p.setMeta(type);
            do p.setData(value);
        }

        return;
    }


    function int CMD() { return CMD; }
    function int TTL() { return TTL; }
    function int OP() { return OP; }
    function int UOP() { return UOP; }
    function int LIST() { return LIST; }
    function int BLOCK() { return BLOCK; }
    function int CMDLIN() { return CMDLIN; }
    function int FUNC() { return FUNC; }
    function int INTEX() { return INTEX; }
    function int STREX() { return STREX; }
    function int STR() { return STR; }
    function int INT() { return INT; }
    function int SYM() { return SYM; }

}
