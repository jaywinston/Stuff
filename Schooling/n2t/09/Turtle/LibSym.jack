class LibSym {

    static int CMD, TTL, BLOCK, CMDLIN, FUNC, INTEX, STREX, STR, INT, SYM,
               OP, UOP;

    function void init() {

      let CMD    = 1;                    
      let TTL    = 2;                    
      let BLOCK  = Lex.cclass(123);         // 64
      let CMDLIN = Lex.cclass(123) + 1;     // 65
      let FUNC   = Lex.cclass(123) + 2;     // 66
      let INTEX  = Lex.cclass(40);          // 80
      let STREX  = Lex.cclass(44);          // 96
      let STR    = Lex.cclass(34);          // 256
      let INT    = Lex.cclass(48);          // 8192
      let SYM    = Lex.cclass(65);          // 16384
      let OP     = Lex.cclass(38)-1 & ~INTEX;         // 8
      let UOP    = Lex.cclass(126) & (~BLOCK & ~OP);  // 16

      return;
    }


    function Symbol copySym(Symbol sym) {
        var int tclass;

        if (sym = null) {
            return null;
        }

        let tclass = LibSym.typeClass(sym) & 320;

        if (tclass = LibSym.STR()) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              Str.dup(sym.data()));
        }

        if (tclass = LibSym.BLOCK()) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              LibSym.copyList(sym.data()));
        }

        return Symbol.new(Str.dup(sym.tag()), sym.meta(), sym.data());
    }


    function Symbol copyList(Symbol sym) {
        var Symbol new;

        if (sym = null) {
            return null;
        }

        let new = LibSym.copySym(sym);

        let sym = sym.next();
        while (~(sym = null)) {
            do new.append(LibSym.copySym(sym));
            let sym = sym.next();
        }

        return new;
    }


    function void destroySym(Symbol sym) {
        var int tclass;
        var String s;

        if (sym = null) {
            return;
        }

        let s = sym.tag();

        if (~(s = null)) {
            do s.dispose();
        }

        let tclass = LibSym.typeClass(sym);

        if (tclass = LibSym.STR()) {
            let s = sym.data();
            do s.dispose();
        } else { if (tclass = LibSym.BLOCK()) {
            do LibSym.destroyList(sym.data());
        }}

        do sym.dispose();

        return;
    }


    function void destroyList(Symbol sym) {
        var Symbol next;

        while (~(sym = null)) {
            let next = sym.next();
            do LibSym.destroySym(sym);
            let sym = next;
        }

        return;
    }


    function void _destroySym(Symbol sym) {
        var int tclass;
        var String s;

        if (sym = null) {
            return;
        }

        let s = sym.tag();

        if (~(s = null)) {
            do s.dispose();
        }

        let tclass = LibSym.typeClass(sym);

        if (tclass = LibSym.STR()) {
            let s = sym.data();
            do s.dispose();
        } else { if (tclass = LibSym.BLOCK()) {
            do LibSym._destroyList(sym.data());
        }}

        do sym.dispose();

        return;
    }


    function void _destroyList(Struct list) {
        var Symbol p;

        while (list.length() > 0) {
            let p = list.pop();
            do LibSym._destroySym(p);
        }

        do list.dispose();

        return;
    }


    function void destroyHashTable(HashTable ht) {
        var int i;

        let i = 0;
        while (i < ht.hashSize()) {
            do LibSym._destroyList(ht.bucket(i));
            let i = i + 1;
        }

        do ht.dispose();

        return;
    }


    function void install(HashTable ht, String name, int type, int value) {
        var String s;
        var Symbol p;

        let p = ht.lookup(name);

        if (p = null) {
            do ht.install(Str.dup(name), type, value);
        } else {
            if (p.meta() = LibSym.STR()) {
                let s = p.data();
                do s.dispose();
            } else { if (p.meta() = LibSym.FUNC()) {
                do LibSym.destroyList(p.data());
            }}
            do p.setMeta(type);
            do p.setData(value);
        }

        return;
    }


    function int typeClass(Symbol sym) {
        return sym.meta() & (LibSym.STR() | LibSym.BLOCK());
    }

                                                              // see Lex.init()
    function int CMD       () { return  1;                    }
    function int TTL       () { return  2;                    }
    function int OP        () { return  (Lex.cclass(38)-1)
                                           & ~LibSym.INTEX(); }  // 8
    function int UOP       () { return  Lex.cclass(126)
                                           & (~LibSym.BLOCK()
                                              & ~LibSym.OP()); }  // 16

    /* block type-class */
    function int BLOCK     () { return Lex.cclass(123);       }  // 64
    function int CMDLIN    () { return Lex.cclass(123) + 1;   }  // 65
    function int FUNC      () { return Lex.cclass(123) + 2;   }  // 66
    function int INTEX     () { return Lex.cclass(40);        }  // 80
    function int STREX     () { return Lex.cclass(44);        }  // 96

    function int STR       () { return Lex.cclass(34);        }  // 256
    function int INT       () { return Lex.cclass(48);        }  // 8192
    function int SYM       () { return Lex.cclass(65);        }  // 16384

}
