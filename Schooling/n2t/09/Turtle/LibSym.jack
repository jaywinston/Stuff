// CTAB is an array of size 128.  It is used as something of a hashtable
// in that it is indexed by a character.  Its values are a bitmap of the
// character's type.  That bitmap is also used to implement arithmetic
// operator precedence.  Most types are one-bit values.  Block types
// and integer types have subtypes.  Block types are used by LibSym
// list functions to recurse on the symbol's data.  Integer types are
// used to announce an integer expression tree and afterwards, are masked
// and used for arithmetic operator precedence.
// 
// The bitmap is:
//   32768 16384 8192 4096 2048 1024 512 256 128  64  32  16   8   4   2   1
//       |     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//  unused     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
// illegal index    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//       symbol token    |    |    |   |   |   |   |   |   |   |   |   |   |
//           integer token    |    |   |   |   |   |   |   |   |   |   |   |
//               string literal    |   |   |   |   |   |   |   |   |   |   |
//                     string format   |   |   |   |   |   |   |   |   |   |  
//                                 block   |   |   |   |   |   |   |   |   |
//                                    unused   |   |   |   |   |   |   |   |
//                                   white space   |   |   |   |   |   |   |
//                                             index   |   |   |   |   |   |
//                                                   end   |   |   |   |   |
//                                                      list   |   |   |   |
//                                 integer expression / operator   |   |   |
//                                                                 |   |   |
//                                                                 site use
//
// String expressions are calls to the format function.
// Integer expressions are compound expressions i.e. including one or
// more operators.

class LibSym {

    static int BIN, BLOCK, CMD, CMDLIN, FUNC, INDEX, INT, ARTEX, LIST, OP,
        STR, FMTEX, NAME, UOP;
    static int HACK_CHARSET_SIZE, EOS_MAP, NOLGL_MAP, SITE;


    function void init() {
        var Array ctab;

        /* magic number!s */
        let HACK_CHARSET_SIZE = 152;
        let SITE = 7;

        let EOS_MAP = HACK_CHARSET_SIZE;
        let NOLGL_MAP = HACK_CHARSET_SIZE + 1;

        let CMD = 1;
        let BIN = 3;

        let ctab = LibSym.ctab();

        let BLOCK = ctab[123];
        let INDEX = ctab[46];
        let INT = ctab[48];
        let ARTEX = ctab[40];
        let LIST = ctab[91];
        let STR = ctab[34];
        let FMTEX = ctab[44];
        let NAME = ctab[65];

        do ctab.dispose();

        let FUNC = LIST + 1;
        let CMDLIN = LIST + 2;

        let OP = ARTEX & ~LIST;
        let UOP = OP | SITE;

        return;
    }


    function Array ctab() {
        var int i;
        var Array ctab;

        let ctab = Array.new(HACK_CHARSET_SIZE + 2);  /* magic number! */

        let i = 0;
        while (i < 128) {
            let ctab[i] = 0;
            let i = i + 1;
        }

        let i = 65;
        while (i < 90) {
            let ctab[i] = 10240;
            let i = i + 1;
        }

        let i = 97;
        while (i < 122) {
            let ctab[i] = 10240;
            let i = i + 1;
        }

        let ctab[36] = 10240; // $

        let i = 48;
        while (i < 58) {
            let ctab[i] = 4096;
            let i = i + 1;
        }
 
        let ctab[ 91] =    16;  // [
        let ctab[ 40] =    24;  // (
        let ctab[ 38] =    25;  // &
        let ctab[124] =    25;  // |
        let ctab[ 94] =    25;  // ^
        let ctab[ 61] =    26;  // =
        let ctab[ 33] =    27;  // !
        let ctab[ 60] =    27;  // <
        let ctab[ 62] =    27;  // >
        let ctab[ 43] =    28;  // +
        let ctab[ 45] =    28;  // -
        let ctab[126] =    28;  // ~
        let ctab[ 37] =    29;  // %
        let ctab[ 42] =    29;  // *
        let ctab[ 47] =    29;  // /
        let ctab[ 41] =    30;  // )
        let ctab[ 93] =    32;  // ]
        let ctab[ 46] =    64;  // .
        let ctab[ 32] =   128;  //  
        let ctab[123] =   528;  // {
        let ctab[125] =   544;  // }
        let ctab[ 44] =  1040;  // ,
        let ctab[ 34] =  2048;  // "

        let ctab[  EOS_MAP] =  8224;  // EOS
        let ctab[NOLGL_MAP] = 16384;  // illegal index

        return ctab;
    }


    function Symbol copySym(Symbol sym) {
        var int type;

        if (sym = null) {
            return null;
        }

        let type = sym.meta() & (LIST | STR);

        if (type = LIST) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              LibSym.copyList(sym.data()));
        }

        if (type = STR) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              Str.dup(sym.data()));
        }

        return Symbol.new(Str.dup(sym.tag()), sym.meta(), sym.data());
    }


    function Collection copyList(Collection list) {
        var int i;
        var Collection new;

        let new = Collection.new();
        let i = 0;
        while (i < list.length()) {
            do new.append(LibSym.copySym(list.nth(i)));
            let i = i + 1;
        }

        return new;
    }


    function void destroySym(Symbol sym) {
        var int type;
        var String s;

        if (sym = null) {
            return;
        }

        let type = sym.meta() & (LIST | STR);

        if (type = LIST) {
            do LibSym.destroyList(sym.data());
        } else { if (type = STR) {
            let s = sym.data();
            do s.dispose();
        }}

        do sym.dispose();

        return;
    }


    function void destroyList(Collection list) {

        if (list = null) {
            return;
        }

        while (list.length() > 0) {
            do LibSym.destroySym(list.pop());
        }

        do list.dispose();

        return;
    }


    function void destroyHashTable(HashTable ht) {
        var int i;

        let i = 0;
        while (i < ht.hashSize()) {
            do LibSym.destroyList(ht.bucket(i));
            let i = i + 1;
        }

        do ht.dispose();

        return;
    }


    function void install(HashTable ht, String name, int type, int value) {
        var String s;
        var Symbol p;

        let p = ht.lookup(name);

        if (p = null) {
            do ht.install(Str.dup(name), type, value);
        } else {
            if ( (p.meta()&LIST) = LIST ) {
                do LibSym.destroyList(p.data());
            } else { if ( (p.meta()&STR) = STR ) {
                let s = p.data();
                do s.dispose();
            }}
            do p.setMeta(type);
            do p.setData(value);
        }

        return;
    }


    function int BIN() { return BIN; }
    function int BLOCK() { return BLOCK; }
    function int CHARSETSIZE() { return HACK_CHARSET_SIZE; }
    function int CMD() { return CMD; }
    function int CMDLIN() { return CMDLIN; }
    function int FUNC() { return FUNC; }
    function int INT() { return INT; }
    function int ARTEX() { return ARTEX; }
    function int LIST() { return LIST; }
    function int OP() { return OP; }
    function int SITE() { return SITE; }
    function int STR() { return STR; }
    function int FMTEX() { return FMTEX; }
    function int NAME() { return NAME; }
    function int UOP() { return UOP; }

}
