class LibSym {


    function Symbol copySym(Symbol sym) {
        var int tclass;

        if (sym = null) {
            return null;
        }

        let tclass = LibSym.typeClass(sym);

        if (tclass = LibSym.STR()) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              Str.dup(sym.data()));
        }

        if (tclass = LibSym.BLOCK()) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              LibSym.copyList(sym.data()));
        }

        return Symbol.new(Str.dup(sym.tag()), sym.meta(), sym.data());
    }


    function Symbol copyList(Symbol sym) {
        var Symbol new;

        if (sym = null) {
            return null;
        }

        let new = LibSym.copySym(sym);

        let sym = sym.next();
        while (~(sym = null)) {
            do new.append(LibSym.copySym(sym));
            let sym = sym.next();
        }

        return new;
    }


    function void destroySym(Symbol sym) {
        var int tclass;
        var String s;

        if (sym = null) {
            return;
        }

        let s = sym.tag();

        if (~(s = null)) {
            do s.dispose();
        }

        let tclass = LibSym.typeClass(sym);

        if (tclass = LibSym.STR()) {
            let s = sym.data();
            do s.dispose();
        } else { if (tclass = LibSym.BLOCK()) {
            do LibSym.destroyList(sym.data());
        }}

        do sym.dispose();

        return;
    }


    function void destroyList(Symbol sym) {
        var Symbol next;

        while (~(sym = null)) {
            let next = sym.next();
            do LibSym.destroySym(sym);
            let sym = next;
        }

        return;
    }


    function void destroyHashTable(HashTable ht) {
        var int i;

        let i = 0;
        while (i < ht.hashSize()) {
            do LibSym.destroyList(ht.bucket(i));
            let i = i + 1;
        }

        do ht.dispose();

        return;
    }


    function void install(HashTable ht, String name, int type, int value) {
        var String s;
        var Symbol p;

        let p = ht.lookup(name);

        if (p = null) {
            do ht.install(Str.dup(name), type, value);
        } else {
            if (p.meta() = LibSym.STR()) {
                let s = p.data();
                do s.dispose();
            } else { if (p.meta() = LibSym.FUNC()) {
                do LibSym.destroyList(p.data());
            }}
            do p.setMeta(type);
            do p.setData(value);
        }

        return;
    }


    function int typeClass(Symbol sym) {
        return sym.meta() & (LibSym.STR() | LibSym.BLOCK());
    }

                                                              // see Lex.init()
    function int CMD       () { return  3;                   }
    function int TTL       () { return  4;                   }
    function int OP        () { return  Lex.cclass(38);      }  // 8
    function int UOP       () { return  Lex.cclass(126);     }  // 90

    /* string type-class */  // defunct
    function int END       () { return 33; }  // in obsolescence
    function int EXPR      () { return 34; }  // in obsolescence

    /* block type-class */
    function int BLOCK     () { return Lex.cclass(123);      }  // 64
    function int CMDLIN    () { return Lex.cclass(123) + 1;  }  // 65
    function int FUNC      () { return Lex.cclass(123) + 2;  }  // 66
    function int INTEX     () { return Lex.cclass(126) & -8; }  // 80
    function int STREX     () { return Lex.cclass(44);       }  // 96

    function int STR       () { return Lex.cclass(34);       }  // 256
    function int INT       () { return Lex.cclass(48);       }  // 8192
    function int SYM       () { return Lex.cclass(65);       }  // 16384

}
