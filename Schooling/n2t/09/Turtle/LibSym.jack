// CTAB is an array of size 128.  It is used as something of a hashtable
// in that it is indexed by a character.  Its values are a bitmap of the
// character's type.  That bitmap is also used to implement arithmetic
// operator precedence.  Most types are one-bit values.  Block types
// and integer types have subtypes.  Block types are used by LibSym
// list functions to recurse on the symbol's data.  Integer types are
// used to announce an integer expression tree and afterwards, are masked
// and used for arithmetic operator precedence.
// 
// The bitmap is:
//   32768 16384 8192 4096 2048 1024 512 256 128  64  32  16   8   4   2   1
//       |     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//  unused     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
// illegal index    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//       symbol token    |    |    |   |   |   |   |   |   |   |   |   |   |
//           integer token    |    |   |   |   |   |   |   |   |   |   |   |
//               string literal    |   |   |   |   |   |   |   |   |   |   |
//                     string format   |   |   |   |   |   |   |   |   |   |  
//                                 block   |   |   |   |   |   |   |   |   |
//                                    unused   |   |   |   |   |   |   |   |
//                                        unused   |   |   |   |   |   |   |
//                                       white space   |   |   |   |   |   |
//                                                   end   |   |   |   |   |
//                                                      list   |   |   |   |
//                                 integer expression / operator   |   |   |
//                                                                 |   |   |
//                                                                 site use
//
// String expressions are calls to the format function.
// Integer expressions are compound expressions i.e. including one or
// more operators.

class LibSym {

    static int CMD, TTL, BLOCK, CMDLIN, FUNC, INTEX, LIST, STREX, STR, INT,
               SYM, OP, UOP;
    static int HACK_CHARSET_SIZE, EOS_MAP, NOLGL_MAP, CLASSMASK;


    function void init() {
        var Array ctab;

        /* magic numbers! */
        let HACK_CHARSET_SIZE = 152;
        let CLASSMASK = -8;

        let EOS_MAP = HACK_CHARSET_SIZE;
        let NOLGL_MAP = HACK_CHARSET_SIZE + 1;

        let ctab = LibSym.ctab();

        let CMD = 1;
        let TTL = 2;
        let LIST = ctab[91];
        let CMDLIN = LIST + 1;
        let FUNC = LIST + 2;
        let BLOCK = ctab[123];
        let SYM = ctab[65];
        let INT = ctab[48];
        let INTEX = ctab[40];
        let OP = INTEX & ~LIST;
        let UOP = ~CLASSMASK;
        let STR = ctab[34];
        let STREX = ctab[44];

        do ctab.dispose();

        return;
    }


    function Array ctab() {
        var int i;
        var Array ctab;

        let ctab = Array.new(HACK_CHARSET_SIZE + 2);

        let i = 0;
        while (i < 128) {
            let ctab[i] = 0;
            let i = i + 1;
        }

        let i = 32;
        while (i < 127) {
            let ctab[i] = 8192;
            let i = i + 1;
        }

        let i = 48;
        while (i < 58) {
            let ctab[i] = 4096;
            let i = i + 1;
        }
 
        let ctab[ 91] =    16;  // [
        let ctab[ 40] =    24;  // (
        let ctab[ 38] =    25;  // &
        let ctab[124] =    25;  // |
        let ctab[ 61] =    26;  // =
        let ctab[ 33] =    26;  // !
        let ctab[ 60] =    26;  // <
        let ctab[ 62] =    26;  // >
        let ctab[ 43] =    27;  // +
        let ctab[ 45] =    27;  // -
        let ctab[126] =    27;  // ~
        let ctab[ 37] =    28;  // %
        let ctab[ 42] =    28;  // *
        let ctab[ 47] =    28;  // /
        let ctab[ 93] =    32;  // ]
        let ctab[ 41] =    40;  // )
        let ctab[ 32] =    64;  //  
        let ctab[123] =   528;  // {
        let ctab[125] =   544;  // }
        let ctab[ 44] =  1040;  // ,
        let ctab[ 34] =  2048;  // "

        let ctab[  EOS_MAP] =  8224;  // EOS
        let ctab[NOLGL_MAP] = 16384;  // illegal index

        return ctab;
    }


    function Symbol copySym(Symbol sym) {
        var int type;

        if (sym = null) {
            return null;
        }

        let type = sym.meta() & (LIST|STR);

        if (type = STR) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              Str.dup(sym.data()));
        }

        if (type = LIST) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              LibSym.copyList(sym.data()));
        }

        return Symbol.new(Str.dup(sym.tag()), sym.meta(), sym.data());
    }


    function Collection copyList(Collection list) {
        var int i;
        var Collection new;

        let new = Collection.new();
        let i = 0;
        while (i < list.length()) {
            do new.append(LibSym.copySym(list.nth(i)));
            let i = i + 1;
        }

        return new;
    }


    function void destroySym(Symbol sym) {
        var int type;
        var String s;

        if (sym = null) {
            return;
        }

        let type = sym.meta() & (LIST|STR);

        if ( type = LIST ) {
            do LibSym.destroyList(sym.data());
        } else { if (type = STR) {
            let s = sym.data();
            do s.dispose();
        }}

        do sym.dispose();

        return;
    }


    function void destroyList(Collection list) {
        while (list.length() > 0) {
            do LibSym.destroySym(list.pop());
        }
        do list.dispose();
        return;
    }


    function void destroyHashTable(HashTable ht) {
        var int i;

        let i = 0;
        while (i < ht.hashSize()) {
            do LibSym.destroyList(ht.bucket(i));
            let i = i + 1;
        }

        do ht.dispose();

        return;
    }


    function void install(HashTable ht, String name, int type, int value) {
        var String s;
        var Symbol p;

        let p = ht.lookup(name);

        if (p = null) {
            do ht.install(Str.dup(name), type, value);
        } else {
            if (p.meta() = FUNC) {
                do LibSym.destroyList(p.data());
            } else { if (p.meta() = STR) {
                let s = p.data();
                do s.dispose();
            }}
            do p.setMeta(type);
            do p.setData(value);
        }

        return;
    }


    function int CHARSETSIZE() { return HACK_CHARSET_SIZE; }
    function int CLASSMASK() { return CLASSMASK; }
    function int CMD() { return CMD; }
    function int TTL() { return TTL; }
    function int OP() { return OP; }
    function int UOP() { return UOP; }
    function int LIST() { return LIST; }
    function int BLOCK() { return BLOCK; }
    function int CMDLIN() { return CMDLIN; }
    function int FUNC() { return FUNC; }
    function int INTEX() { return INTEX; }
    function int STREX() { return STREX; }
    function int STR() { return STR; }
    function int INT() { return INT; }
    function int SYM() { return SYM; }

}
