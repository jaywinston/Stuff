class LibSym {

    static int CMD, TTL, BLOCK, CMDLIN, FUNC, INTEX, LIST, STREX, STR, INT,
               SYM, OP, UOP;

    function void init() {

      let CMD    = 1;                    
      let TTL    = 2;                    
      let LIST   = Lex.cclass(91);          // 64
      let BLOCK  = Lex.cclass(123);         // 64
      let CMDLIN = Lex.cclass(123) + 1;     // 65
      let FUNC   = Lex.cclass(123) + 2;     // 66
      let INTEX  = Lex.cclass(40);          // 80
      let STREX  = Lex.cclass(44);          // 96
      let STR    = Lex.cclass(34);          // 256
      let INT    = Lex.cclass(48);          // 8192
      let SYM    = Lex.cclass(65);          // 16384
      let OP     = (Lex.cclass(38)-1) & ~INTEX;       // 8
      let UOP    = Lex.cclass(126) & (~BLOCK & ~OP);  // 16

      return;
    }


    function Symbol copySym(Symbol sym) {
        var int type;

        if (sym = null) {
            return null;
        }

        let type = sym.meta() & (LIST|STR);

        if (type = STR) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              Str.dup(sym.data()));
        }

        if (type = LIST) {
            return Symbol.new(Str.dup(sym.tag()), sym.meta(),
                              LibSym.copyList(sym.data()));
        }

        return Symbol.new(Str.dup(sym.tag()), sym.meta(), sym.data());
    }


    function Collection copyList(Collection list) {
        var int i;
        var Collection new;

        let new = Collection.new();
        let i = 0;
        while (i < list.length()) {
            do new.append(LibSym.copySym(list.nth(i)));
            let i = i + 1;
        }

        return new;
    }


    function void destroySym(Symbol sym) {
        var int type;
        var String s;

        if (sym = null) {
            return;
        }

        let s = sym.tag();

        if (~(s = null)) {
            do s.dispose();
        }

        let type = sym.meta() & (LIST|STR);

        if (type = LIST) {
            do LibSym.destroyList(sym.data());
        } else { if (type = STR) {
            let s = sym.data();
            do s.dispose();
        }}

        do sym.dispose();

        return;
    }


    function void destroyList(Collection list) {

        while (list.length() > 0) {
            do LibSym.destroySym(list.pop());
        }

        do list.dispose();

        return;
    }


    function void destroyHashTable(HashTable ht) {
        var int i;

        let i = 0;
        while (i < ht.hashSize()) {
            do LibSym.destroyList(ht.bucket(i));
            let i = i + 1;
        }

        do ht.dispose();

        return;
    }


    function void install(HashTable ht, String name, int type, int value) {
        var String s;
        var Symbol p;

        let p = ht.lookup(name);

        if (p = null) {
            do ht.install(Str.dup(name), type, value);
        } else {
            if (p.meta() = FUNC) {
                do LibSym.destroyList(p.data());
            } else { if (p.meta() = STR) {
                let s = p.data();
                do s.dispose();
            }}
            do p.setMeta(type);
            do p.setData(value);
        }

        return;
    }


    function int CMD() { return CMD; }
    function int TTL() { return TTL; }
    function int OP() { return OP; }
    function int UOP() { return UOP; }
    function int LIST() { return LIST; }
    function int BLOCK() { return BLOCK; }
    function int CMDLIN() { return CMDLIN; }
    function int FUNC() { return FUNC; }
    function int INTEX() { return INTEX; }
    function int STREX() { return STREX; }
    function int STR() { return STR; }
    function int INT() { return INT; }
    function int SYM() { return SYM; }

}
