class Turtle {

    static int TLEN;
    static int top, left, bottom, right;

    field boolean _pendown;
    field int direction, _x, _y;
    field Vector v;
    field ScreenArea sa;

    constructor Turtle new(int x, int y, int d, int t, int l, int b, int r) {
        let TLEN = 3;
        /* todo: validate boundaries */
        let top = t;
        let left = l;
        let bottom = b;
        let right = r;
        /* todo: validate coordinates */
        let _x = x;
        let _y = y;
        let direction = setDirection(d);
        let v = Vector.new();
        let sa = ScreenArea.new(TLEN*6, TLEN*6);
        let _pendown = false;
        do show();
        return this;
    }

    method void dispose() {
        do hide();
        do v.dispose();
        do sa.dispose();
        do Memory.deAlloc(this);
        return;
    }

    method int setDirection(int d) {
        let direction = Vector.mod(d, 360);
        if (direction < 0) {
            let direction = direction + 360;
        }
        return direction;
    }

    method int direction() {
        return direction;
    }

    method int x() {
        return _x;
    }

    method int y() {
        return _y;
    }

    method void drawLine(int x1, int y1, int x2, int y2) {

        if (x1 < left) {
            let x1 = left;
        } else { if (x1 > right) {
            let x1 = right;
        }}

        if (y1 < top) {
            let y1 = top;
        } else { if (y1 > bottom) {
            let y1 = bottom;
        }}

        if (x2 < left) {
            let x2 = left;
        } else { if (x2 > right) {
            let x2 = right;
        }}

        if (y2 < top) {
            let y2 = top;
        } else { if (y2 > bottom) {
            let y2 = bottom;
        }}

        do Screen.drawLine(x1, y1, x2, y2);

        return;
    }

    method void drawTurtle() {
        var int i, l, x, y;

        do Screen.setColor(true);
        do Screen.drawCircle(_x, _y, TLEN*2);
        do v.calculate(TLEN*2, direction);
        do Screen.setColor(false);
        do Screen.drawCircle(_x-v.re(), _y+v.im(), TLEN*2);
/*
        let x = _x + v.re();
        let y = _y - v.im();
        let i = 160;
        let l = 0;
        while (i < 180) {
            do v.calculate(TLEN-(l/6), direction+i);
            do drawLine(x, y, x+v.re(), y-v.im());
            let i = i + 2;
            let l = l + 1;
        }
        while (i < 200) {
            do v.calculate(TLEN-(l/6), direction+i);
            do drawLine(x, y, x+v.re(), y-v.im());
            let i = i + 2;
            let l = l - 1;
        }
*/

        return;
    }

    method void show() {
        do sa.copy(_x-(TLEN*2), _y-(TLEN*2));
        do drawTurtle();
        do sa.overlay();
        return;
    }

    method void hide() {
        do drawTurtle();
        do sa.restore();
        return;
    }

    method int turn(int d) {
        do hide();
        do setDirection(direction + d);
        do show();
        return direction;
    }

    method int turnleft(int d) {
        return turn(d);
    }

    method int turnright(int d) {
        return turn(-d);
    }

    method int forward(int l) {
        var int x, y;

        if (l < 0) {
            return -1;
        }

        do v.calculate(l, direction);
        let x = _x + v.re();
        let y = _y - v.im();

        if ( ((x<left) | (x>right)) | ((y<top) | (y>bottom)) ) {
            return -2;  // target beyond boundary
        }

        do hide();

        if (_pendown) {
            do Screen.setColor(true);
            do drawLine(_x, _y, x, y);
        }

        let _x = x;
        let _y = y;

        do show();

        return l;
    }

    method void penup() {
        let _pendown = false;
        return;
    }

    method void pendown() {
        let _pendown = true;
        return;
    }
}
