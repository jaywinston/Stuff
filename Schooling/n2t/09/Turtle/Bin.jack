class Bin {

    static int bottom, left, right, top;
    static int BIN, INT, STR;
    static int CLEAR, DIR, FORWARD, PENDOWN, PENUP, POSX, POSY, PRINT,
        TURNLEFT, TURNRIGHT;
    static Turtle t;


    function void init() {
        var Array b;
        var int i, j, h, w;

        let b = LibIO.boundaries();
        let i = b[0];
        let j = b[1];
        let h = b[2];
        let w = b[3];
        let top = i * 11;
        let left = j * 8;
        let bottom = (i+h) * 11;
        let right = (j+w) * 8;
        let BIN = LibSym.BIN();
        let INT = LibSym.INT();
        let STR = LibSym.STR();
        let t = Bin.turtle();

        let CLEAR     =  1;
        let DIR       =  2;
        let FORWARD   =  4;
        let PENDOWN   =  5;
        let PENUP     =  6;
        let POSX      =  7;
        let POSY      =  8;
        let PRINT     =  9;
        let TURNLEFT  = 10;
        let TURNRIGHT = 11;

        do Eval.install("CLEAR", BIN, CLEAR);
        do Eval.install("DIR", BIN, DIR);
        do Eval.install("FORWARD", BIN, FORWARD);
        do Eval.install("PENDOWN", BIN, PENDOWN);
        do Eval.install("PENUP", BIN, PENUP);
        do Eval.install("POSX", BIN, POSX);
        do Eval.install("POSY", BIN, POSY);
        do Eval.install("PRINT", BIN, PRINT);
        do Eval.install("TURNLEFT", BIN, TURNLEFT);
        do Eval.install("TURNRIGHT", BIN, TURNRIGHT);

        return;
    }


    function Turtle turtle() {
        return Turtle.new(left + ((right-left)/2),
                          top + ((bottom-top)/2),
                          90);
    }


    function Symbol exec(int cmd, Collection argv) {

        if (cmd = DIR)    { return Bin.dir(argv.next());               }
        if (cmd = POSX)   { return Bin.posx(argv.next());              }
        if (cmd = POSY)   { return Bin.posy(argv.next());              }

        if (cmd = CLEAR)            { do Bin.doClear(argv.next());     }
        else { if (cmd = FORWARD)   { do Bin.doForward(argv.next());   }
        else { if (cmd = PENDOWN)   { do Bin.doPendown(argv.next());   }
        else { if (cmd = PENUP)     { do Bin.doPenup(argv.next());     }
        else { if (cmd = PRINT)     { do Bin.doPrint(argv.next());     }
        else { if (cmd = TURNLEFT)  { do Bin.doTurnleft(argv.next());  }
        else { if (cmd = TURNRIGHT) { do Bin.doTurnright(argv.next()); }
        }}}}}}

        do LibIO.fixCanvas();

        return null;
    }


    function void doClear(Symbol arg) {
        do t.dispose();
        do LibIO.clear();
        return;
    }


    function Symbol dir(Symbol arg) {
        return Symbol.new(null, INT, t.direction());
    }


    function void doForward(Symbol arg) {
        var Array target;

        do Eval.arg(arg);

        if (arg.data() < 0) {
            do LibIO.error("won't go backwards");
            return;
        }

        let target = t.aim(arg.data());

        if ( ((target[0] < left) | (target[0] > right))
                | ((target[1] < top) | (target[1] > bottom)) ) {
            do LibIO.error("target beyond boundary");
            return;
        }

        do t.forward(arg.data());

        return;
    }


    function void doPendown(Symbol arg) {
        do t.pendown();
        return;
    }


    function void doPenup(Symbol arg) {
        do t.penup();
        return;
    }


    function Symbol posx(Symbol arg) {
        return Symbol.new(null, INT, t.x() - ((left+right)/2));
    }


    function Symbol posy(Symbol arg) {
        return Symbol.new(null, INT, -(t.y() - ((top+bottom)/2)));
    }


    function void doPrint(Symbol arg) {

        do Eval.arg(arg);

        if (~(arg.meta() = STR)) {
            do LibIO.error("exec print: expected string");
            return;
        }

        do Bin.hideAll();
        if (LibIO.print(arg.data(), t.y()/11, (t.x()/8)+1) = 1) {
            do LibIO.error("illegal cursor coordinate");
        }
        do Bin.showAll();

        return;
    }


    function void hideAll() {
        var int i;
        var Turtle tt;

        let i = 0;
        while (i < turtle.length()) {
            let tt = turtles.nth(i);
            do tt.hide();
            let i = i + 1;
        }

        return;
    }


    function void showAll() {
        var int i;
        var Turtle tt;

        let i = 0;
        while (i < turtle.length()) {
            let tt = turtles.nth(i);
            do tt.show();
            let i = i + 1;
        }

        return;
    }


    function void doTurnleft(Symbol arg) {
        do Eval.arg(arg);
        do t.turnleft(arg.data());
        return;
    }


    function void doTurnright(Symbol arg) {
        do Eval.arg(arg);
        do t.turnright(arg.data());
        return;
    }



}
