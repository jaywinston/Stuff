class Parse {

    static int EQ, BLANK, DELIM, BLOCK, END, EOS, CMDLIN, INT, COMMA,
                INTEX, OP, STR, STREX, SYM, UOP, LPAREN, RPAREN;
    static int MASK;
    static String PS1, PS2;


    function void init() {
        let EQ = Lex.cclass(61);
        let BLANK = Lex.cclass(32);
        let BLOCK = LibSym.BLOCK();
        let END = Lex.cclass(125);
        let EOS = Lex.cclass(0);
        let CMDLIN = LibSym.CMDLIN();
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let OP = LibSym.OP();
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let COMMA = STREX & ~BLOCK;
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();
        let LPAREN = Lex.cclass(40);
        let RPAREN = Lex.cclass(41);
        let MASK = -16;
        let PS2 = "|";
        return;
    }


    function int cmdline(String s, Symbol argv, int i) {
        var int cclass;
        var String t;
        var Symbol next;

        let i = Str.lskip(s, 32, i);
        let cclass = Lex.cclass(Lex.getch(s, i)) & MASK;
        let DELIM = COMMA | EOS;
        while ( (cclass&DELIM) = 0 ) {

            if (cclass = END) {
                do argv.setTag(s);
                return i;
            }

            if (cclass = BLOCK) {
                let next = Symbol.new(null, BLOCK, null);
                let i = Parse.block(s, next, i);
                let s = next.tag();
                do next.setTag(null);
                do next.setData(next.next());
                do next.setNext(null);
                let cclass = Lex.cclass(Lex.getch(s, i)) & MASK;
                if (cclass = INTEX) {
                    let i = Parse.intex(s, next, i);
                    let s = next.tag();
                    do next.setTag(null);
                    let next = Symbol.new(null, INTEX, next);
                } else { if (cclass = STREX) {
                    let i = Parse.strex(s, next, i);
                    let s = next.tag();
                    do next.setTag(null);
                    let next = Symbol.new(null, STREX, next);
                }}
            } else { if (cclass = INT) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let next = Symbol.new(null, INT, t.intValue());
                do t.dispose();
                if ( (Lex.cclass(Lex.getch(s, i))&MASK) = INTEX ) {
                    let i = Parse.intex(s, next, i);
                    let s = next.tag();
                    do next.setTag(null);
                    let next = Symbol.new(null, INTEX, next);
                }
            } else { if (cclass = INTEX) {
                let next = Symbol.new(null, INTEX, null);
                let i = Parse.intex(s, next, i);
                let s = next.tag();
                do next.setTag(null);
                do next.setData(next.next());
                do next.setNext(null);
            } else { if (cclass = STR) {
                let t = String.new(s.length());
                let i = Lex.string(s, t, i);
                let next = Symbol.new(null, STR, t);
                if (Lex.cclass(Lex.getch(s, i)) = STREX) {
                    let i = Parse.strex(s, next, i);
                    let s = next.tag();
                    do next.setTag(null);
                    let next = Symbol.new(null, STREX, next);
                }
            //} else { if (cclass = STREX) {
                //let next = Symbol.new(null, STREX, null);
                //let i = Parse.intex(s, next, i);
                //let s = next.tag();
                //do next.setTag(null);
            } else { if (cclass = SYM) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                /* assignment? */
                if ( (Lex.cclass(Lex.getch(s, i)) = EQ)
                        & (~(Lex.cclass(Lex.getch(s, i+1)) = EQ)) ) {
                    let next = Symbol.new(null, SYM, "=");
                    do next.append(Symbol.new(null, SYM, t));
                } else {
                    let next = Symbol.new(null, SYM, t);
                }
                let cclass = Lex.cclass(Lex.getch(s, i)) & MASK;
                if (cclass = INTEX) {
                    let i = Parse.intex(s, next, i);
                    let s = next.tag();
                    do next.setTag(null);
                    let next = Symbol.new(null, INTEX, next);
                } else { if (cclass = STREX) {
                    let i = Parse.strex(s, next, i);
                    let s = next.tag();
                    do next.setTag(null);
                    let next = Symbol.new(null, STREX, next);
                }}
            } else {
                /* error */
            }}}}}//}

//do Output.printInt(next);
//do Output.println();
//do Output.printInt(next.next());
//do Output.println();
//do Output.println();
            do argv.append(next);

            let i = Str.lskip(s, 32, i);
            let cclass = Lex.cclass(Lex.getch(s, i)) & MASK;
        }

        do argv.setTag(s);

        return i;
    }


    function int intex(String s, Symbol queue, int i) {
        var boolean uop;
        var int cclass, op;
        var String t;
        var Symbol objbuf, stack, stackbuf;

        let stack = Symbol.new(null, null, null);
        let uop = queue.meta() = INTEX;
        let cclass = Lex.cclass(Lex.getch(s, i));

        let DELIM = BLANK | (COMMA | EOS);
        while ( (cclass&DELIM) = 0 ) {

            if ( (cclass=INT) | ((cclass=SYM) | (cclass=BLOCK)) ) {
                if (cclass = INT) {
                    let t = String.new(5);
                    let i = Lex.token(s, t, i);
                    let objbuf = Symbol.new(null, INT, t.intValue());
                    do t.dispose();
                } else { if (cclass = SYM) {
                    let t = String.new(5);
                    let i = Lex.token(s, t, i);
                    let objbuf = Symbol.new(null, SYM, t);
                } else { if (cclass = BLOCK) {
                    let objbuf = Symbol.new(null, BLOCK, null);
                    let i = Parse.block(s, objbuf, i);
                    let s = objbuf.tag();
                    do objbuf.setTag(null);
                    do objbuf.setData(objbuf.next());
                    do objbuf.setNext(null);
                }}}
                do queue.append(objbuf);
                while (stack.meta() = UOP) {
                    let stackbuf = stack;
                    let stack = stack.next();
                    do stackbuf.setNext(null);
                    do queue.append(stackbuf);
                }
                let uop = false;
            } else { if ( (cclass&OP) = OP) {
                let op = s.charAt(i);
                if (uop) {
                    let objbuf = Symbol.new(null, UOP, op);
                } else {
                    let objbuf = Symbol.new(null, Lex.cclass(op)&7, op);
                }
                if ( (i+1) < s.length() ) {
                    if ((Lex.cclass(op)=EQ) & (Lex.cclass(s.charAt(i+1))=EQ)) {
                        let op = (op*100) + s.charAt(i+1);
                        let i = i + 1;
                        do objbuf.setData(op);
                    }
                }
                /* pop higher equal ops to queue */
                if (~uop) {
                    while (  ((stack.meta()>objbuf.meta())
                            | (stack.meta()=objbuf.meta()))
                            & (~(stack.meta()=LPAREN)) ) {
                        let stackbuf = stack;
                        let stack = stack.next();
                        do stackbuf.setNext(null);
                        do queue.append(stackbuf);
                    }
                    let uop = true;
                }
                do objbuf.setNext(stack);
                let stack = objbuf;
                let i = i + 1;
            } else { if (cclass = LPAREN) {
                let objbuf = Symbol.new(null, LPAREN, null);
                do objbuf.setNext(stack);
                let stack = objbuf;
                let uop = true;
                let i = i + 1;
            } else { if (cclass = RPAREN) {
                do objbuf.dispose();
                while (~(stack.meta() = LPAREN)) {
                    if (stack.meta() = null) { /* mismatched parens */
                        do stack.dispose();
                        return -i;
                    }
                    let stackbuf = stack;
                    let stack = stack.next();
                    do stackbuf.setNext(null);
                    do queue.append(stackbuf);
                }
                let stackbuf = stack;
                let stack = stack.next();
                do stackbuf.dispose();
                let uop = false;
                let i = i + 1;
            }}}}

            let cclass = Lex.cclass(Lex.getch(s, i));
        }

        while (~(stack.meta() = null)) {
            if (stack.meta() = LPAREN) {    /* mismatched parens */
                while (~(stack = null)) {
                    let stackbuf = stack;
                    let stack = stack.next();
                    do stackbuf.dispose();
                }
                return -i;
            }
            let stackbuf = stack;
            let stack = stack.next();
            do stackbuf.setNext(null);
            do queue.append(stackbuf);
        }

        do stack.dispose();

        do queue.setTag(s);

        return i;
    }


    function int strex(String s, Symbol next, int i) {
        var int cclass;
        var Symbol arg;

        let DELIM = BLANK | EOS;
        let arg = Symbol.new(null, null, null);
        let cclass = Lex.cclass(Lex.getch(s, i+1));
        while ( (cclass&DELIM) = 0 ) {
            let i = Parse.cmdline(s, arg, i+1);
            do next.append(arg.next());
            do arg.setNext(null);
            let s = arg.tag();
            let cclass = Lex.cclass(Lex.getch(s, i+1));
        }

        do arg.setTag(null);
        do arg.dispose();
        do next.setTag(s);

        return i;
    }


    function int block(String s, Symbol block, int i) {
        var Symbol cmdlin;

        let i = Str.lskip(s, 32, i+1);

        if ( (Lex.cclass(Lex.getch(s, i))&(END|EOS)) = 0 ) {
            let cmdlin = Symbol.new(null, CMDLIN, null);
            let i = Parse.cmdline(s, cmdlin, i);
            let s = cmdlin.tag();
            do cmdlin.setTag(null);
            do cmdlin.setData(cmdlin.next());
            do cmdlin.setNext(null);
            do block.append(cmdlin);
        }

        while (Lex.cclass(Lex.getch(s, i)) = EOS) {
            let s = IOBox.read(PS2);
            let i = Str.lskip(s, 32, 0);
            if (~(Lex.cclass(Lex.getch(s, i)) = END)) {
                let cmdlin = Symbol.new(s, CMDLIN, null);
                let i = Parse.cmdline(s, cmdlin, 0);
                let s = cmdlin.tag();
                do cmdlin.setTag(null);
                do cmdlin.setData(cmdlin.next());
                do cmdlin.setNext(null);
                do block.append(cmdlin);
            }
        }

        do block.setTag(s);

        return i + 1;
    }

}
