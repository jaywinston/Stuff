// Site use of the meta namespace is bit[0..2] to classify operator precedence.

class Parse {

    static int BEND, BLANK, BLOCK, CMDLIN, COMMA, DELIM, END, EOS, EQ, INDEX,
            INT, INTEX, LEND, LIST, LPAREN, NOLGL, OP, RPAREN, STR, STREX, SYM,
            UOP;
    static int GLOBL, SITE, TOKENMASK;
    static String PS1, PS2;
    static Symbol ARGV;


    function void init() {

        let BEND = Lex.cclass(125);
        let BLANK = Lex.cclass(32);
        let BLOCK = LibSym.BLOCK();
        let CMDLIN = LibSym.CMDLIN();
        let COMMA = STREX & ~BLOCK;
        let END = Lex.cclass(93);
        let EOS = Lex.EOS();
        let EQ = Lex.cclass(61);
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let LEND = END;
        let LIST = Lex.cclass(91);
        let LPAREN = Lex.cclass(40);
        let NOLGL = Lex.NOLGL();
        let OP = LibSym.OP();
        let RPAREN = Lex.cclass(41);
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();

        let SITE = LibSym.SITE();
        let GLOBL = ~SITE;
        let TOKENMASK = SYM | INT;

        let PS1 = ">";
        let PS2 = "|";

        let ARGV = Symbol.new(null, null, null);

        return;
    }


    function void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do LibSym.destroySym(ARGV);
        return;
    }


    function String input(String ps) {
        return LibIO.read(ps);
    }


    function Collection next() {
        do Parse.cmdlin(Parse.input(PS1), ARGV, 0);
        return ARGV.data();
    }


    function int cclass(String s, int i) {
        return Lex.cclass(Lex.getch(s, i));
    }


    function int package(Symbol pkg, int data, String tag, int i) {

        if (pkg = null) {
            return -1;
        }

        do pkg.setData(data);
        do pkg.setTag(tag);

        return i;
    }


    function String tag(Symbol p) {
        var String s;

        if (p = null) {
            return null;
        }

        let s = p.tag();
        do p.setTag(null);

        return s;
    }


    function int word(String s, Symbol word, int i) {
        var int cc;
        var String t;

        if (i < 0) {
            do word.setTag(s);
            return i;
        }

        let i = Str.lskip(s, 32, i);
        let cc = Parse.cclass(s, i);

        if (cc = LIST) {
            do LibIO.error("not implemented");
            return -1;
        } else { if (cc = BLOCK) {
            do word.setMeta(BLOCK);
            let i = Parse.block(s, word, i);
            let s = Parse.tag(word);
        } else { if (cc = INT) {
            let t = String.new(s.length()-i);
            let i = Lex.token(s, t, TOKENMASK, i);
            do word.setMeta(INT);
            do word.setData(t.intValue());
            do t.dispose();
        } else { if (cc = STR) {
            let t = String.new(s.length()-i);
            let i = Lex.string(s, t, i);
            if (i < 0) {
                do LibIO.error("EOS while scanning string");
                do t.dispose();
                return -1;
            }
            do word.setMeta(STR);
            do word.setData(t);
        } else { if (cc = SYM) {
            let t = String.new(s.length());
            let i = Lex.token(s, t, TOKENMASK, i);
            do word.setMeta(SYM);
            do word.setData(t);
        } else {
            do LibIO.error("illegal character");
            return -1;
        }}}}}

        do word.setTag(s);

        return i;
    }


    function int cmdlin(String s, Symbol argv, int i) {
        var int DLM;
        var int cc;
        var String t;
        var Collection cmdlin;
        var Symbol word;

        let DLM = EOS | (END | NOLGL);
        let cmdlin = Collection.new();

        let cc = 0;  // one iteration for naught; i don't love it
        while ( (cc&DLM) = 0 ) {

            if (cc = INDEX) {
                do LibIO.error("not implemented");
                return Parse.package(argv, cmdlin, s, -1);
            }

            if ( (cc=EQ) & ~(Parse.cclass(s, i+1)=EQ) ) {
                do cmdlin.append(Symbol.new("ASSIGN", SYM, null));
                let i = i + 1;
                let cc = Parse.cclass(s, i);
            }

            if ( (cc&INTEX) = INTEX ) {
                let word = Symbol.new(null, INTEX, word);
                let i = Parse.intex(s, word, i);
                let s = Parse.tag(word);
            } else { if (cc = STREX) {
                let word = Symbol.new(null, STREX, word);
                let i = Parse.strex(s, word, i);
                let s = Parse.tag(word);
            }}

            let word = Symbol.new(null, null, null);
            do cmdlin.append(word);
            let i = Parse.word(s, word, i);
            let s = Parse.tag(word);
            let cc = Parse.cclass(s, i) & GLOBL;
        }

        return Parse.package(argv, cmdlin, s, i);
    }


    function int intex(String s, Symbol intex, int i) {
        var boolean uop;
        var int DLM, cc, op;
        var String t;
        var Collection stack, queue;
        var Symbol token, top;

        let DLM = (BLANK | COMMA) | (END | EOS);
        let queue = Collection.new();
        let stack = Collection.new();
        do stack.push(Symbol.new(null, null, null));
        let token = intex.data();
        if (token.meta() = null) {
            let uop = true;
        } else {
            let uop = false;
            do queue.append(token);
        }

        let cc = Parse.cclass(s, i);
        while ( (cc&DLM) = 0 ) {

            if (cc = NOLGL) {
                do LibSym.destroyList(stack);
                return Parse.package(intex, queue, s, -1);
            }

            if (cc = LPAREN) {
                do stack.push(Symbol.new(null, LPAREN, null));
                let uop = true;
                let i = i + 1;
            } else { if (cc = RPAREN) {
                let top = stack.nth(0);
                while (~(top.meta() = LPAREN)) {
                    if (top.meta() = null) {
                        do LibIO.error("mismatched parentheses");
                        do LibSym.destroyList(stack);
                        return Parse.package(intex, queue, s, -1);
                    }
                    do top.setMeta(OP);
                    do queue.append(stack.pop());
                    let top = stack.nth(0);
                }
                do top.dispose();
                do stack.pop();
                let uop = false;
                let i = i + 1;
            } else { if ( (cc&OP) = OP ) {
                let op = s.charAt(i);
                let i = i + 1;
                if (uop) {  /* I don't love this. */
                    let token = Symbol.new(null, UOP, op);
                } else {
                    let token = Symbol.new(null, cc&SITE, op);
                    if (Parse.cclass(s, i) = EQ) {
                        do token.setData((op*100) + 61);
                        let i = i + 1;
                    }
                    /* pop higher/equal ops to queue */
                    let top = stack.nth(0);
                    while ( ~(top.meta()<token.meta())
                             & ~(top.meta()=LPAREN) ) {
                        do top.setMeta(OP);
                        do queue.append(stack.pop());
                        let top = stack.nth(0);
                    }
                    let uop = true;
                }
                do stack.push(token);
            } else {
                let token = Symbol.new(null, null, null);
                let i = Parse.word(s, token, i);
                let s = Parse.tag(token);
                do queue.append(token);

                let top = stack.nth(0);
                while (top.meta() = UOP) {
                    do queue.append(stack.pop());
                    let top = stack.nth(0);
                }

                let uop = false;
            }}}

            let cc = Parse.cclass(s, i);
        }

        /* pop ops to queue */
        let top = stack.nth(0);
        while (~(top.meta() = null)) {
            if (top.meta() = LPAREN) {
                do LibIO.error("mismatched parentheses");
                do LibSym.destroyList(stack);
                return Parse.package(intex, queue, s, -1);
            }
            do top.setMeta(OP);
            do queue.append(stack.pop());
            let top = stack.nth(0);
        }

        do LibSym.destroyList(stack);

        return Parse.package(intex, queue, s, i);
    }


    function int strex(String s, Symbol strex, int i) {
        var int cc;
        var String t;
        var Collection argv;
        var Symbol arg, intex, next;

        let arg = strex.data();
        let argv = Collection.new();
        do argv.append(arg);

        while (Parse.cclass(s, i) = STREX) {

            let i = i + 1;
            let cc = Parse.cclass(s, i) & GLOBL;

            if (cc = NOLGL) {
                return Parse.package(strex, argv, s, -1);
            }

            let arg = Symbol.new(null, null, null);
            let i = Parse.word(s, arg, i);
            let s = Parse.tag(arg);

            if ( (Parse.cclass(s, i)&GLOBL) = INTEX ) {
                let arg = Symbol.new(null, INTEX, arg);
                let i = Parse.intex(s, intex, i);
                let s = Parse.tag(arg);
            }

            do argv.append(arg);
        }

        return Parse.package(strex, argv, s, i);
    }


    function int block(String s, Symbol argv, int i) {
        var int cc;
        var Collection block;
        var Symbol cmdlin;

        let block = Collection.new();
        let i = i + 1;
        while (true) {
            let cmdlin = Symbol.new(null, CMDLIN, null);
            let i = Parse.cmdlin(s, cmdlin, i);
            let s = Parse.tag(cmdlin);
            do block.append(cmdlin);
            let cc = Parse.cclass(s, i);
            if (cc = BEND) {
                return Parse.package(argv, block, s, i+1);
            }
            if (cc = NOLGL) {
                return Parse.package(argv, block, s, -1);
            }
            let s = Parse.input(PS2);
            let i = 0;
        }

        return -1;
    }


    function int list(String s, Symbol p, int i) {
        return i;
    }

}
