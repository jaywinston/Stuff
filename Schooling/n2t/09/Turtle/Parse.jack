class Parse {

    static int EQ, EQOP, BLANK, DELIM, BLOCK, BEND, EOS, CMDLIN, INT, COMMA,
                INTEX, OP, STR, STREX, SYM, UOP, LPAREN, RPAREN, NOLGL,
                LIST, LEND;
    static int CLASSMASK, OPMASK;
    static String PS1, PS2;
    static Symbol ARGV;


    function void init() {

        let EQ = Lex.cclass(61);
        let EQOP = Lex.cclass(60);
        let BLANK = Lex.cclass(32);
        let BLOCK = LibSym.BLOCK();
        let BEND = Lex.cclass(125);
        let EOS = Lex.EOS();
        let CMDLIN = LibSym.CMDLIN();
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let OP = LibSym.OP();
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let COMMA = STREX & ~BLOCK;
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();
        let LPAREN = Lex.cclass(40);
        let RPAREN = Lex.cclass(41);
        let NOLGL = Lex.NOLGL();
        let LIST = Lex.cclass(91);
        let LEND = Lex.cclass(93);

        let CLASSMASK = LibSym.CLASSMASK();
        let OPMASK = ~CLASSMASK;

        let PS1 = ">";
        let PS2 = "|";

        let ARGV = Symbol.new(null, null, null);
        return;
    }


    function void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do LibSym.destroySymbol(ARGV);
        return;
    }


    function Collection next() {
        do Parse.cmdlin(LibIO.read(PS1), ARGV, 0);
        return ARGV.data();
    }


    function int cclass(String s, int i) {
        return Lex.cclass(Lex.getch(s, i));
    }


    function int package(Symbol pkg, int data, String tag, int i) {

        if (pkg = null) {
            return -1;
        }

        do pkg.setData(data);
        do pkg.setTag(tag);

        return i;
    }


    function String tag(Symbol pointer) {
        var String s;

        if (pointer = null) {
            return null;
        }

        let s = pointer.tag();
        do pointer.setTag(null);

        return s;
    }


    function int cmdlin(String s, Symbol pointer, int i) {
        var int cclass;
        var String t;
        var Collection argv;
        var Symbol extok, next;

        let argv = Collection.new();
        let i = Str.lskip(s, 32, i);

        let cclass = Parse.cclass(s, i) & CLASSMASK;
        while (~(cclass = EOS)) {

            if (cclass = NOLGL) {
                return Parse.package(pointer, argv, s, -1);
            }

            if ( (cclass=BEND) | (cclass=LEND) ) {
                return Parse.package(pointer, argv, s, i);
            }

            if (cclass = LIST) {
                do LibIO.error("not implemented");
                return Parse.package(pointer, argv, s, -1);
            } else { if (cclass = BLOCK) {
                let next = Symbol.new(null, BLOCK, null);
                let i = Parse.block(s, next, i);
                let s = Parse.tag(next);
            } else { if (cclass = INT) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let next = Symbol.new(null, INT, t.intValue());
                do t.dispose();
            } else { if (cclass = INTEX) {
                let next = Symbol.new(null, INTEX, null);
                let i = Parse.intex(s, next, i);
                let s = Parse.tag(next);
            } else { if (cclass = STR) {
                let t = String.new(s.length());
                let i = Lex.string(s, t, i);
                if (i < 0) {
                    do LibIO.error("EOS while scanning string");
                    do t.dispose();
                    return Parse.package(pointer, argv, s, -1);
                }
                let next = Symbol.new(null, STR, t);
            } else { if (cclass = SYM) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let next = Symbol.new(t, SYM, null);
            } else {
                do LibIO.error("illegal character");
                return Parse.package(pointer, argv, s, -1);
            }}}}}}

            let cclass = Parse.cclass(s, i) & CLASSMASK;
            if (cclass = INTEX) {
                let extok = Symbol.new(null, INTEX, next);
                let i = Parse.intex(s, extok, i);
                let s = Parse.tag(extok);
                let next = extok;
            } else { if (cclass = STREX) {
                let extok = Symbol.new(null, STREX, next);
                let i = Parse.strex(s, extok, i);
                let s = Parse.tag(extok);
                let next = extok;
            } else { if (cclass = LIST) {
                do LibIO.error("not implemented");
                return Parse.package(pointer, argv, s, -1);
            } else { if (cclass = EQ) {
                if (~( (Parse.cclass(s, i-1)&OP) = OP )) {
                    do next.push(Symbol.new("ASSIGN", SYM, null));
                    let i = i + 1;
                }
            }}}}

            do argv.append(next);

            let i = Str.lskip(s, 32, i);
            let cclass = Parse.cclass(s, i) & CLASSMASK;
        }

        return Parse.package(pointer, argv, s, i);
    }


    function int intex(String s, Symbol pointer, int i) {
        var boolean uop;
        var int MASK, cclass, op;
        var String t;
        var Collection stack, queue;
        var Symbol objbuf, stack, stackbuf;

        if ( (i<0) | ~(i<s.length()) ) {
            return -1;
        }

        let MASK  = ((BLANK|COMMA)|(BEND|LEND))|EOS;
        let queue = Collection.new();
        let stack = Collection.new();
        do stack.push(Symbol.new(null, null, null));
        if (pointer.data() = null) {
            let uop = true;
        } else {
            let uop = false;
            do queue.append(pointer.data());
        }

        let cclass = Parse.cclass(s, i);
        while ( (cclass&MASK) = 0 ) {

            if (cclass = NOLGL) {
                do LibSym.destroyList(stack);
                return Parse.package(pointer, queue, s, -1);
            }

            if ( (cclass=INT) | ((cclass=SYM) | (cclass=BLOCK)) ) {
                if (cclass = INT) {
                    let t = String.new(5);
                    let i = Lex.token(s, t, i);
                    do queue.append(Symbol.new(null, INT, t.intValue()));
                    do t.dispose();
                } else { if (cclass = SYM) {
                    let t = String.new(s.length());
                    let i = Lex.token(s, t, i);
                    do queue.append(Symbol.new(t, SYM, null));
                } else { if (cclass = BLOCK) {
                    let objbuf = Symbol.new(null, BLOCK, null);
                    let i = Parse.block(s, objbuf, i);
                    let s = Parse.tag(objbuf);
                    do queue.append(objbuf);
                }}}

                let objbuf = stack.nth(0);
                while (objbuf.meta() = OP) {
                    do queue.append(stack.pop());
                    let objbuf = stack.nth(0);
                }

                let uop = false;

            } else { if ( (cclass&OP) = OP ) {
                let op = s.charAt(i);
                let i = i + 1;
                if (uop) {
                    let objbuf = Symbol.new(null, UOP, op);
                } else {
                    let objbuf = Symbol.new(null, Lex.cclass(op)&OPMASK, op);
                    if ( ((Lex.cclass(op)&EQ)=EQ) & (Parse.cclass(s, i)=EQ) ) {
                        do objbuf.setData((op*100) + 61);
                        let i = i + 1;
                    }
                    /* pop higher/equal ops to queue */
                    let stackbuf = stack.nth(0);
                    while ( ~(stackbuf.meta()<objbuf.meta())
                            & ~(stackbuf.meta()=LPAREN) ) {
                        do queue.append(stack.pop());
                        let stackbuf = stack.nth(0);
                    }
                    let uop = true;
                }
                do stack.push(objbuf);
            } else { if (cclass = LPAREN) {
                do stack.push(Symbol.new(null, LPAREN, null));
                let uop = true;
                let i = i + 1;
            } else { if (cclass = RPAREN) {
                // todo: cleaner?
                if (stack.length() = 0) { /* mismatched parens */
                    do LibIO.error("mismatched parentheses");
                    do pointer.setData(queue);
                    do pointer.setTag(s);
                    do stack.dispose();
                    return -1;
                }
                let stackbuf = stack.nth(0);
                while (~(stackbuf.meta() = LPAREN)) {
                    if (stack.length() = 0) {
                        do LibIO.error("mismatched parentheses");
                        do pointer.setData(queue);
                        do pointer.setTag(s);
                        do stack.dispose();
                        return -1;
                    }
                    do queue.append(stack.pop());
                    let stackbuf = stack.nth(0);
                }
                do stackbuf.dispose();
                let uop = false;
                let i = i + 1;
            }}}}

            let cclass = Parse.cclass(s, i);
        }

        /* pop ops to queue */
        while (stack.length() > 0) {
            if (stack.meta() = LPAREN) {
                do LibIO.error("mismatched parentheses");
                do LibSym.destroyList(stack);
                do pointer.setData(queue);
                do pointer.setTag(s);
                return -1;
            }
            do queue.append(stack.pop());
        }

        do stack.dispose();

        do pointer.setData(queue);
        do pointer.setTag(s);

        return i;
    }


    function int strex(String s, Symbol pointer, int i) {
        var int cclass;
        var String t;
        var Symbol arg, intex, next;

        if ( (s=null) | (next=null) ) {
            return -1;
        }

        let arg = next.next();
        if (arg = null) {
            return -1;
        }

        if (~(arg.meta() = STR)) {
            do LibIO.error("no format string given");
            return -1;
        }

        let arg = null;

        if ( (i<0) | ~(i<s.length()) ) {
            return -1;
        }

        while (Parse.cclass(s, i) = STREX) {

            let i = i + 1;
            let cclass = Parse.cclass(s, i) & CLASSMASK;

            if (cclass = BLOCK) {
                let arg = Symbol.new(null, BLOCK, null);
                let i = Parse.block(s, arg, i);
                let s = arg.tag();
                do arg.setTag(null);
            } else { if (cclass = INT) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let arg = Symbol.new(null, INT, t.intValue());
                do t.dispose();
            } else { if (cclass = INTEX) {
                let arg = Symbol.new(null, INTEX, null);
                let i = Parse.intex(s, arg, i);
                let s = arg.tag();
                do arg.setTag(null);
            } else { if (cclass = STR) {
                let t = String.new(s.length());
                let i = Lex.string(s, t, i);
                if (i < 0) {
                    do LibIO.error("EOS while scanning string");
                    return Parse.package(pointer, next, t, -1);
                }
                let arg = Symbol.new(null, STR, t);
            } else { if (cclass = SYM) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let arg = Symbol.new(t, SYM, null);
            }}}}}

            if (i < 0) {
                return i;
            }

            if ( (Parse.cclass(s, i)&CLASSMASK) = INTEX) {
                let intex = Symbol.new(null, INTEX, null);
                do intex.append(arg);
                let i = Parse.intex(s, intex, i);
                let s = intex.tag();
                do intex.setTag(null);
                let arg = intex;
            }

            if (i < 0) {
                return i;
            }

            do next.append(arg);
        }

        return Parse.package(pointer, next, s, i);
    }


    function int block(String s, Symbol pointer, int i) {
        var Collection block;
        var Symbol cmdlin;

        if ( (i<0) | ~(i<s.length()) ) {
            return -1;
        }

        let block = Collection.new();

        let i = Str.lskip(s, 32, i+1);
        if ( (Parse.cclass(s, i)&(BEND|EOS)) = 0 ) {
            let cmdlin = Symbol.new(null, CMDLIN, null);
            let i = Parse.cmdlin(s, cmdlin, i);
            let s = cmdlin.tag();
            do cmdlin.setTag(null);
            do block.append(cmdlin);
        }

        if (i < 0) {
            return i;
        }

        while (Parse.cclass(s, i) = EOS) {
            let s = LibIO.read(PS2);
            let i = Str.lskip(s, 32, 0);
            if (~(Parse.cclass(s, i) = BEND)) {
                let cmdlin = Symbol.new(s, CMDLIN, null);
                let i = Parse.cmdlin(s, cmdlin, 0);
                let s = Parse.tag(cmdlin);
                do block.append(cmdlin);
                if (i < 0) {
                    return Parse.package(pointer, block, s, -1);
                }
            }
        }

        do Parse.package(pointer, block, s, i);

        return i + 1;
    }

}
