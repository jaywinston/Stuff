// CTAB is an array of size 128.  It is used as something of a hashtable
// in that it is indexed by a character.  Its values are a bitmap of the
// character's type.  That bitmap is also used to implement arithmetic
// operator precedence.  Most types are one-bit values.  Block types
// and integer types have subtypes.  Block types are used by LibSym
// list functions to recurse on the symbol's data.  Integer types are
// used to announce an integer expression tree and afterwards, are masked
// and used for arithmetic operator precedence.
// 
// The bitmap is:
//   32768 16384 8192 4096 2048 1024 512 256 128  64  32  16   8   4   2   1
//       |     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//  unused     |    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//  symbol token    |    |    |    |   |   |   |   |   |   |   |   |   |   |
//      integer token    |    |    |   |   |   |   |   |   |   |   |   |   |
//                     EOS    |    |   |   |   |   |   |   |   |   |   |   |
//              blank character    |   |   |   |   |   |   |   |   |   |   |
//                            unused   |   |   |   |   |   |   |   |   |   |
//                                unused   |   |   |   |   |   |   |   |   |
//                            string literal   |   |   |   |   |   |   |   |
//                                     block end   |   |   |   |   |   |   |
//                                             block   |   |   |   |   |   |
//                                                 |\ /   /|   |   |   |   |
//                                   string expression   / |   |   |   |   |
//                                                 \    /  |   |   |   |   |
//                                    integer expression   |   |   |   |   |
//                                            unary operator   |   |   |   |
//                                               binary operator   |   |   |
//                                                                  \  |  /
//                                                     opreator precedance
//
// String expressions are calls to the format function.
// Integer expressions are compound expressions i.e. including one or
// more operators.

class Parse {

    static int EQ, EQOP, BLANK, DELIM, BLOCK, END, EOS, CMDLIN, INT, COMMA,
                INTEX, OP, STR, STREX, SYM, UOP, LPAREN, RPAREN;
    static int CLASSMASK;
    static Array CTAB;
    static String PS1, PS2;
    static Symbol ARGV;


    function void init() {
        var int i;

        let CTAB = Array.new(128);

        let i = 0;
        while (i < 128) {
            let CTAB[i] = 0;
            let i = i + 1;
        }

        let i = 65;
        while (i < 90) {
            let CTAB[i] = 16384;
            let i = i + 1;
        }

        let i = 97;
        while (i < 122) {
            let CTAB[i] = 16384;
            let i = i + 1;
        }

/*
lexing tests alnums, are these worth it?
        let CTAB[ 35] = 16384;  // #
        let CTAB[ 36] = 16384;  // $
        let CTAB[ 46] = 16384;  // .
        let CTAB[ 63] = 16384;  // ?
        let CTAB[ 64] = 16384;  // @
        let CTAB[ 95] = 16384;  // _
*/

        let i = 48;
        while (i < 58) {
            let CTAB[i] = 8192;
            let i = i + 1;
        }
 
        let CTAB[123] =    64;  // {
        let CTAB[ 40] =    80;  // (
        let CTAB[ 41] =    81;  // )
        let CTAB[ 38] =    89;  // &
        let CTAB[124] =    89;  // |
        let CTAB[ 61] =    90;  // =
        let CTAB[ 33] =    91;  // !
        let CTAB[ 60] =    91;  // <
        let CTAB[ 62] =    91;  // >
        let CTAB[ 43] =    92;  // +
        let CTAB[ 45] =    92;  // -
        let CTAB[126] =    92;  // ~
        let CTAB[ 37] =    93;  // %
        let CTAB[ 42] =    93;  // *
        let CTAB[ 47] =    93;  // /
        let CTAB[ 44] =    96;  // ,
        let CTAB[125] =   128;  // }
        let CTAB[ 34] =   256;  // "
        let CTAB[ 32] =  2048;  //  
        let CTAB[  0] =  4096;  // EOS

        let EQ = Parse.cclass(61);
        let EQOP = Parse.cclass(60);
        let BLANK = Parse.cclass(32);
        let BLOCK = LibSym.BLOCK();
        let END = Parse.cclass(125);
        let EOS = Parse.cclass(0);
        let CMDLIN = LibSym.CMDLIN();
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let OP = LibSym.OP();
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let COMMA = STREX & ~BLOCK;
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();
        let LPAREN = Parse.cclass(40);
        let RPAREN = Parse.cclass(41);

        let CLASSMASK = -16;

        let PS1 = ">";
        let PS2 = "|";

        let ARGV = Symbol.new(null, null, null);

        return;
    }


    function void dispose() {
        do CTAB.dispose();
        do PS1.dispose();
        do PS2.dispose();
        do ARGV.dispose();
        return;
    }


    function Symbol next() {

        do ARGV.setData(null);

        if (Parse.cmdlin(LibIO.read(PS1), ARGV, 0) < 0) {
            do LibSym.destroyList(ARGV.data());
            return null;
        }

        return ARGV.data();
    }


    function char getch(String s, int i) {
        if (~(i < s.length())) {
            return 0;
        }
        return s.charAt(i);
    }


    function int cclass(char c) {
        return CTAB[c];
    }


    function void mkpackage(Symbol pkg, String tag) {

        if (pkg = null) {
            return;
        }

        do pkg.setData(pkg.next());
        do pkg.setNext(null);
        do pkg.setTag(tag);

        return;
    }


    function int cmdlin(String s, Symbol argv, int i) {
        var int cclass;
        var String t;
        var Symbol extok, next;

        if ( (i<0) | ~(i<s.length()) ) {
            return -1;
        }

        let i = Str.lskip(s, 32, i);
        let cclass = Parse.cclass(Parse.getch(s, i)) & CLASSMASK;
        while (~(cclass = EOS)) {

            if (cclass = END) {
                do Parse.mkpackage(argv, s);
                return i;
            }

            if (cclass = BLOCK) {
                let next = Symbol.new(null, BLOCK, null);
                let i = Parse.block(s, next, i);
                let s = next.tag();
                do next.setTag(null);
            } else { if (cclass = INT) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let next = Symbol.new(null, INT, t.intValue());
                do t.dispose();
            } else { if (cclass = INTEX) {
                let next = Symbol.new(null, INTEX, null);
                let i = Parse.intex(s, next, i);
                let s = next.tag();
                do next.setTag(null);
            } else { if (cclass = STR) {
                let t = String.new(s.length());
                let i = Lex.string(s, t, i);
                if (i < 0) {
                    do LibIO.error("EOS while scanning string");
                    return -1;
                }
                let next = Symbol.new(null, STR, t);
            } else { if (cclass = SYM) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                /* assignment? */
                if ( (Parse.cclass(Parse.getch(s, i)) = EQ)
                        & (~(Parse.cclass(Parse.getch(s, i-1)) = EQOP)) ) {
                    let next = Symbol.new("ASSIGN", SYM, null);
                    do next.append(Symbol.new(t, SYM, null));
                    let i = i + 1;
                } else {
                    let next = Symbol.new(t, SYM, null);
                }
            } else {
                do LibIO.error("illegal character");
                return -1;
            }}}}}

            if (i < 0) {
                return i;
            }

            let cclass = Parse.cclass(Parse.getch(s, i)) & CLASSMASK;
            if (cclass = INTEX) {
                let extok = Symbol.new(null, INTEX, null);
                do extok.append(next);
                let i = Parse.intex(s, extok, i);
                let s = extok.tag();
                do extok.setTag(null);
                let next = extok;
            } else { if (cclass = STREX) {
                let extok = Symbol.new(null, STREX, null);
                do extok.append(next);
                let i = Parse.strex(s, extok, i);
                let s = extok.tag();
                do extok.setTag(null);
                let next = extok;
            }}

            if (i < 0) {
                return i;
            }

            do argv.append(next);

            let i = Str.lskip(s, 32, i);
            let cclass = Parse.cclass(Parse.getch(s, i)) & CLASSMASK;
        }

        do Parse.mkpackage(argv, s);

        return i;
    }


    function int intex(String s, Symbol queue, int i) {
        var boolean uop;
        var int cclass, op;
        var String t;
        var Symbol objbuf, stack, stackbuf;

        if ( (i<0) | ~(i<s.length()) ) {
            return -1;
        }

        let stack = Symbol.new(null, null, null);
        let uop = queue.next() = 0;
        let cclass = Parse.cclass(Parse.getch(s, i));

        /* todo: should END be in exit cond? */
        while ( (cclass & ((BLANK|COMMA)|(END|EOS))) = 0 ) {

            if ( (cclass=INT) | ((cclass=SYM) | (cclass=BLOCK)) ) {
                if (cclass = INT) {
                    let t = String.new(5);
                    let i = Lex.token(s, t, i);
                    let objbuf = Symbol.new(null, INT, t.intValue());
                    do t.dispose();
                } else { if (cclass = SYM) {
                    let t = String.new(5);
                    let i = Lex.token(s, t, i);
                    let objbuf = Symbol.new(t, SYM, null);
                } else { if (cclass = BLOCK) {
                    let objbuf = Symbol.new(null, BLOCK, null);
                    let i = Parse.block(s, objbuf, i);
                    let s = objbuf.tag();
                    do objbuf.setTag(null);
                }}}

                if (i < 0) {
                    return i;
                }

                do queue.append(objbuf);
                while (stack.meta() = UOP) {
                    let stackbuf = stack;
                    let stack = stack.next();
                    do stackbuf.setNext(null);
                    do queue.append(stackbuf);
                }

                let uop = false;

            } else { if ( (cclass&OP) = OP) {
                let op = s.charAt(i);
                let i = i + 1;
                if (uop) {
                    let objbuf = Symbol.new(null, UOP, op);
                } else {
                    let objbuf = Symbol.new(null, Parse.cclass(op)&15, op);
                    if (i < s.length()) {
                        if ( ((Parse.cclass(op)=EQ) | (Parse.cclass(op)=EQOP))
                                & (Parse.cclass(Parse.getch(s, i))=EQ) ) {
                            do objbuf.setData((op*100) + 61);
                            let i = i + 1;
                        }
                    }
                    /* pop higher equal ops to queue */
                    while ( ~(stack.meta()<objbuf.meta())
                            & ~(stack.meta()=LPAREN) ) {
                        let stackbuf = stack;
                        let stack = stack.next();
                        do stackbuf.setNext(null);
                        do queue.append(stackbuf);
                    }
                    let uop = true;
                }
                do objbuf.setNext(stack);
                let stack = objbuf;
            } else { if (cclass = LPAREN) {
                let objbuf = Symbol.new(null, LPAREN, null);
                do objbuf.setNext(stack);
                let stack = objbuf;
                let uop = true;
                let i = i + 1;
            } else { if (cclass = RPAREN) {
                while (~(stack.meta() = LPAREN)) {
                    if (stack.meta() = null) { /* mismatched parens */
                        do stack.dispose();
                        do LibIO.error("mismatched parentheses");
                        return -1;
                    }
                    let stackbuf = stack;
                    let stack = stack.next();
                    do stackbuf.setNext(null);
                    do queue.append(stackbuf);
                }
                let stackbuf = stack;
                let stack = stack.next();
                do stackbuf.dispose();
                let uop = false;
                let i = i + 1;
            }}}}

            let cclass = Parse.cclass(Parse.getch(s, i));
        }

        /* pop ops to queue */
        while (~(stack.meta() = null)) {
            if (stack.meta() = LPAREN) {    /* mismatched parens */
                while (~(stack = null)) {
                    let stackbuf = stack;
                    let stack = stack.next();
                    do stackbuf.dispose();
                }
                do LibIO.error("mismatched parentheses");
                return -1;
            }
            let stackbuf = stack;
            let stack = stack.next();
            do stackbuf.setNext(null);
            do queue.append(stackbuf);
        }

        do stack.dispose();

        do Parse.mkpackage(queue, s);

        return i;
    }


    function int strex(String s, Symbol next, int i) {
        var int cclass;
        var String t;
        var Symbol arg, intex;

        if ( (i<0) | ~(i<s.length()) ) {
            return -1;
        }

        while (Parse.cclass(Parse.getch(s, i)) = STREX) {

            let i = i + 1;
            let cclass = Parse.cclass(Parse.getch(s, i)) & CLASSMASK;

            if (cclass = BLOCK) {
                let arg = Symbol.new(null, BLOCK, null);
                let i = Parse.block(s, arg, i);
                let s = arg.tag();
                do arg.setTag(null);
            } else { if (cclass = INT) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let arg = Symbol.new(null, INT, t.intValue());
                do t.dispose();
            } else { if (cclass = INTEX) {
                let arg = Symbol.new(null, INTEX, null);
                let i = Parse.intex(s, arg, i);
                let s = arg.tag();
                do arg.setTag(null);
            } else { if (cclass = STR) {
                let t = String.new(s.length());
                let i = Lex.string(s, t, i);
                if (i < 0) {
                    do LibIO.error("EOS while scanning string");
                    return -1;
                }
                let arg = Symbol.new(null, STR, t);
            } else { if (cclass = SYM) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, i);
                let arg = Symbol.new(t, SYM, null);
            }}}}}

            if (i < 0) {
                return i;
            }

            if ( (Parse.cclass(Parse.getch(s, i))&CLASSMASK) = INTEX) {
                let intex = Symbol.new(null, INTEX, null);
                do intex.append(arg);
                let i = Parse.intex(s, intex, i);
                let s = intex.tag();
                do intex.setTag(null);
                let arg = intex;
            }

            if (i < 0) {
                return i;
            }

            do next.append(arg);
        }

        do Parse.mkpackage(next, s);

        return i;
    }


    function int block(String s, Symbol block, int i) {
        var Symbol cmdlin;

        if ( (i<0) | ~(i<s.length()) ) {
            return -1;
        }

        let i = Str.lskip(s, 32, i+1);

        if ( (Parse.cclass(Parse.getch(s, i))&(END|EOS)) = 0 ) {
            let cmdlin = Symbol.new(null, CMDLIN, null);
            let i = Parse.cmdlin(s, cmdlin, i);
            let s = cmdlin.tag();
            do cmdlin.setTag(null);
            do block.append(cmdlin);
        }

        if (i < 0) {
            return i;
        }

        while (Parse.cclass(Parse.getch(s, i)) = EOS) {
            let s = LibIO.read(PS2);
            let i = Str.lskip(s, 32, 0);
            if (~(Parse.cclass(Parse.getch(s, i)) = END)) {
                let cmdlin = Symbol.new(s, CMDLIN, null);
                let i = Parse.cmdlin(s, cmdlin, 0);
                if (i < 0) {
                    return i;
                }
                let s = cmdlin.tag();
                do cmdlin.setTag(null);
                do block.append(cmdlin);
            }
        }

        do Parse.mkpackage(block, s);

        return i + 1;
    }

}
