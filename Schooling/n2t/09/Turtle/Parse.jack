// Site use of the meta namespace is bit[0..2] to classify operator precedence.

class Parse {

    static int BEND, BLANK, BLOCK, CMDLIN, COMMA, DELIM, END, EOS, EQ, INDEX,
            INT, ARTEX, LEND, LIST, LPAREN, NOLGL, OP, RPAREN, STR, FMTEX, SYM,
            UOP;
    static int GLOBL, SITE, TOKENMASK;
    static String PS1, PS2;
    static Symbol ARGV;


    function void init() {

        let BEND = Lex.cclass(125);
        let BLANK = Lex.cclass(32);
        let BLOCK = LibSym.BLOCK();
        let CMDLIN = LibSym.CMDLIN();
        let COMMA = FMTEX & ~BLOCK;
        let END = Lex.cclass(93);
        let EOS = Lex.EOS();
        let EQ = Lex.cclass(61);
        let INT = LibSym.INT();
        let ARTEX = LibSym.ARTEX();
        let LEND = END;
        let LIST = Lex.cclass(91);
        let LPAREN = Lex.cclass(40);
        let NOLGL = Lex.NOLGL();
        let OP = LibSym.OP();
        let RPAREN = Lex.cclass(41);
        let STR = LibSym.STR();
        let FMTEX = LibSym.FMTEX();
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();

        let SITE = LibSym.SITE();
        let GLOBL = ~SITE;
        let TOKENMASK = SYM | INT;

        let PS1 = ">";
        let PS2 = "|";

        let ARGV = Symbol.new(null, null, null);

        return;
    }


    function void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do LibSym.destroySym(ARGV);
        return;
    }


    function String input(String ps) {
        return LibIO.read(ps);
    }


    function Collection next() {
        do Parse.cmdlin(Parse.input(PS1), ARGV, 0);
        return ARGV.data();
    }


    function int cclass(String s, int i) {
        return Lex.cclass(Lex.getch(s, i));
    }


    function int package(Symbol pkg, int data, String tag, int i) {

        if (pkg = null) {
            return -1;
        }

        do pkg.setData(data);
        do pkg.setTag(tag);

        return i;
    }


    function String tag(Symbol p) {
        var String s;

        if (p = null) {
            return null;
        }

        let s = p.tag();
        do p.setTag(null);

        return s;
    }


    function int simple(String s, Symbol word, int i) {
        var int cc;
        var String t;

        let i = Str.lskip(s, 32, i);
        let cc = Parse.cclass(s, i) & GLOBL;

        if (cc = LIST) {
            do LibIO.error("not implemented");
            let i = -1;
        } else { if (cc = BLOCK) {
            do word.setMeta(BLOCK);
            let i = Parse.block(s, word, i);
            let s = Parse.tag(word);
        } else { if (cc = INT) {
            let t = String.new(s.length()-i);
            let i = Lex.token(s, t, TOKENMASK, i);
            do word.setMeta(INT);
            do word.setData(t.intValue());
            do t.dispose();
        } else { if (cc = ARTEX) {
            do word.setMeta(ARTEX);
            let i = Parse.artex(s, word, i);
            let s = Parse.tag(word);
        } else { if (cc = STR) {
            let t = String.new(s.length()-i);
            let i = Lex.string(s, t, i);
            if (i < 0) {
                do LibIO.error("EOS while scanning string");
            }
            do word.setMeta(STR);
            do word.setData(t);
        } else { if (cc = SYM) {
            let t = String.new(s.length());
            let i = Lex.token(s, t, TOKENMASK, i);
            do word.setMeta(SYM);
            do word.setData(t);
        } else {
            do LibIO.error("illegal character");
            let i = -1;
        }}}}}}

        do word.setTag(s);

        return i;
    }


    function int cmdlin(String s, Symbol argv, int i) {
        var int DLM;
        var int cc;
        var String t;
        var Collection cmdlin;
        var Symbol word;

        if (s.length() = 0) {
            return Parse.package(argv, 0, s, 0);
        }

        let DLM = END | NOLGL;
        let cmdlin = Collection.new();

        let cc = Parse.cclass(s, i) & GLOBL;
        while ( (cc&DLM) = 0 ) {

            let word = Symbol.new(null, null, null);
            let i = Parse.simple(s, word, i);
            let s = Parse.tag(word);
            let cc = Parse.cclass(s, i) & GLOBL;

            if (cc = INDEX) {
                do LibIO.error("not implemented");
                return Parse.package(argv, cmdlin, s, -1);
                // willbe: let cc = Parse.cclass(s, i) & GLOBL;
            }

            if ( (cc=EQ) &
                   ~((Parse.cclass(s, i+1)=EQ) | (Parse.cclass(s, i-1)=EQ)) ) {
                do cmdlin.append(Symbol.new("ASSIGN", SYM, null));
                let i = i + 1;
                let cc = Parse.cclass(s, i) & GLOBL;
            }

            if (cc = ARTEX) {
                let word = Symbol.new(null, ARTEX, word);
                let i = Parse.artex(s, word, i);
                let s = Parse.tag(word);
            } else { if (cc = FMTEX) {
                let word = Symbol.new(null, FMTEX, word);
                let i = Parse.fmtex(s, word, i);
                let s = Parse.tag(word);
            }}

            do cmdlin.append(word);

            let cc = Parse.cclass(s, i) & GLOBL;
        }

        return Parse.package(argv, cmdlin, s, i);
    }


    function int artex(String s, Symbol artex, int i) {
        var boolean uop;
        var int DLM, cc, op;
        var String t;
        var Collection stack, queue;
        var Symbol token, top;

        let DLM = (BLANK | COMMA) | (END | EOS);
        let queue = Collection.new();
        let stack = Collection.new();
        do stack.push(Symbol.new(null, null, null));
        if (artex.data() = null) {
            let uop = true;
        } else {
            let uop = false;
            do queue.append(artex.data());
        }

        let cc = Parse.cclass(s, i);
        while ( (cc&DLM) = 0 ) {

            if (cc = NOLGL) {
                do LibSym.destroyList(stack);
                return Parse.package(artex, queue, s, -1);
            }

            if (cc = LPAREN) {
                do stack.push(Symbol.new(null, LPAREN, null));
                let uop = true;
                let i = i + 1;
            } else { if (cc = RPAREN) {
                let top = stack.pop();
                while (~(top.meta() = LPAREN)) {
                    if (top.meta() = null) {
                        do LibIO.error("mismatched parentheses");
                        do LibSym.destroyList(stack);
                        return Parse.package(artex, queue, s, -1);
                    }
                    do top.setMeta(OP);
                    do queue.append(top);
                    let top = stack.pop();
                }
                do top.dispose();
                let uop = false;
                let i = i + 1;
            } else { if ( (cc&OP) = OP ) {
                let op = s.charAt(i);
                let i = i + 1;
                if (uop) {  /* I don't love this. */
                    let token = Symbol.new(null, UOP, op);
                } else {
                    let token = Symbol.new(null, cc&SITE, op);
                    if (Parse.cclass(s, i) = EQ) {
                        do token.setData((op*100) + 61);
                        let i = i + 1;
                    }
                    /* pop higher/equal ops to queue */
                    let top = stack.nth(0);
                    while ( ~(top.meta()<token.meta())
                             & ~(top.meta()=LPAREN) ) {
                        do top.setMeta(OP);
                        do queue.append(stack.pop());
                        let top = stack.nth(0);
                    }
                    let uop = true;
                }
                do stack.push(token);
            } else {
                let token = Symbol.new(null, null, null);
                let i = Parse.simple(s, token, i);
                let s = Parse.tag(token);
                do queue.append(token);

                let top = stack.nth(0);
                while (top.meta() = UOP) {
                    do queue.append(stack.pop());
                    let top = stack.nth(0);
                }

                let uop = false;
            }}}

            let cc = Parse.cclass(s, i);
        }

        /* pop ops to queue */
        let top = stack.nth(0);
        while (~(top.meta() = null)) {
            if (top.meta() = LPAREN) {
                do LibIO.error("mismatched parentheses");
                do LibSym.destroyList(stack);
                return Parse.package(artex, queue, s, -1);
            }
            do top.setMeta(OP);
            do queue.append(stack.pop());
            let top = stack.nth(0);
        }

        do LibSym.destroyList(stack);

        return Parse.package(artex, queue, s, i);
    }


    function int fmtex(String s, Symbol fmtex, int i) {
        var int cc;
        var String t;
        var Collection argv;
        var Symbol arg, artex, next;

        let argv = Collection.new();
        do argv.append(fmtex.data());

        while (Parse.cclass(s, i) = FMTEX) {

            let arg = Symbol.new(null, null, null);
            let i = Parse.simple(s, arg, i+1);
            let s = Parse.tag(arg);
            let cc = Parse.cclass(s, i) & GLOBL;

            if (cc = NOLGL) {
                return Parse.package(fmtex, argv, s, -1);
            }

            if (cc = INDEX) {
                do LibIO.error("not implemented");
                return Parse.package(fmtex, argv, s, -1);
                // will be: let cc = Parse.cclass(s, i) & GLOBL;
            }

            if (cc = ARTEX) {
                let arg = Symbol.new(null, ARTEX, arg);
                let i = Parse.artex(s, artex, i);
                let s = Parse.tag(arg);
            }

            do argv.append(arg);
        }

        return Parse.package(fmtex, argv, s, i);
    }


    function int block(String s, Symbol argv, int i) {
        var boolean newline;
        var int cc;
        var Collection block, linehead;
        var Symbol cmdlin;

        let block = Collection.new();
        let i = i + 1;
        while (true) {
            let cmdlin = Symbol.new(null, CMDLIN, null);
            let i = Parse.cmdlin(s, cmdlin, i);
            let s = Parse.tag(cmdlin);
            do block.append(cmdlin);
            let cc = Parse.cclass(s, i);
            if (cc = BEND) {
                return Parse.package(argv, block, s, i+1);
            }
            if (cc = NOLGL) {
                return Parse.package(argv, block, s, -1);
            }
            let s = Parse.input(PS2);
            let i = 0;
        }

        return 0;
    }


    function int list(String s, Symbol p, int i) {
        return i;
    }


    function int index(String s, Symbol p, int i) {
        return i;
    }

}
