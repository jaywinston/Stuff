// Site use of the meta namespace is bit[0..2] to classify operator precedence.

class Parse {

    static int BEND, BLANK, BLOCK, CMDLIN, COMMA, DELIM, END, EOS, EQ, INT,
                INTEX, LEND, LIST, LPAREN, NOLGL, OP, RPAREN, STR, STREX,
                SYM, UOP;
    static int CLASSMASK, OPMASK, TOKENMASK;
    static String PS1, PS2;
    static Symbol ARGV;


    function void init() {

        let BEND = Lex.cclass(125);
        let BLANK = Lex.cclass(32);
        let BLOCK = LibSym.BLOCK();
        let CMDLIN = LibSym.CMDLIN();
        let COMMA = STREX & ~BLOCK;
        let END = Lex.cclass(93);
        let EOS = Lex.EOS();
        let EQ = Lex.cclass(61);
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let LEND = END;
        let LIST = Lex.cclass(91);
        let LPAREN = Lex.cclass(40);
        let NOLGL = Lex.NOLGL();
        let OP = LibSym.OP();
        let RPAREN = Lex.cclass(41);
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();

        let CLASSMASK = LibSym.CLASSMASK();
        let OPMASK = ~CLASSMASK;
        let TOKENMASK = SYM | INT;

        let PS1 = ">";
        let PS2 = "|";

        let ARGV = Symbol.new(null, null, null);

        return;
    }


    function void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do LibSym.destroySym(ARGV);
        return;
    }


    function Collection next() {
        do Parse.cmdlin(LibIO.read(PS1), ARGV, 0);
        return ARGV;
    }


    function int cclass(String s, int i) {
        return Lex.cclass(Lex.getch(s, i));
    }


    function int package(Symbol pkg, int data, String tag, int i) {

        if (pkg = null) {
            return -1;
        }

        do pkg.setData(data);
        do pkg.setTag(tag);

        return i;
    }


    function String tag(Symbol pointer) {
        var String s;

        if (pointer = null) {
            return null;
        }

        let s = pointer.tag();
        do pointer.setTag(null);

        return s;
    }


    function int cmdlin(String s, Symbol argv, int i) {
        var int cc;
        var String t;
        var Collection cmdlin;
        var Symbol word;

        let cmdlin = Collection.new();

        let i = Str.lskip(s, 32, i);
        let cc = Parse.cclass(s, i) & CLASSMASK;
        while (~(cc = EOS)) {

            if (cc = NOLGL) {
                return Parse.package(argv, cmdlin, s, -1);
            }

            if ( (cc&END) = END ) {
                return Parse.package(argv, cmdlin, s, i);
            }

            if (cc = LIST) {
                do LibIO.error("not implemented");
                return Parse.package(argv, cmdlin, s, -1);
            } else { if (cc = BLOCK) {
                let word = Symbol.new(null, BLOCK, null);
                let i = Parse.block(s, word, i);
                let s = Parse.tag(word);
            } else { if (cc = INT) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, TOKENMASK, i);
                let word = Symbol.new(null, INT, t.intValue());
                do t.dispose();
            } else { if (cc = INTEX) {
                let word = Symbol.new(null, INTEX, null);
                let i = Parse.intex(s, word, i);
                let s = Parse.tag(word);
            } else { if (cc = STR) {
                let t = String.new(s.length());
                let i = Lex.string(s, t, i);
                if (i < 0) {
                    do LibIO.error("EOS while scanning string");
                    do t.dispose();
                    return Parse.package(argv, cmdlin, s, -1);
                }
                let word = Symbol.new(null, STR, t);
            } else { if (cc = SYM) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, TOKENMASK, i);
                let word = Symbol.new(t, SYM, null);
            } else {
                do LibIO.error("illegal character");
                return Parse.package(argv, cmdlin, s, -1);
            }}}}}}

            let cc = Parse.cclass(s, i);

            if (cc = LIST) {
                do LibIO.error("not implemented");
                return Parse.package(argv, cmdlin, s, -1);
            }

            if ( (cc=EQ) & ~(Parse.cclass(s, i+1)=EQ) ) {
                do cmdlin.append(Symbol.new("ASSIGN", SYM, null));
                let i = i + 1;
                let cc = Parse.cclass(s, i);
            }

            if ( (cc&INTEX) = INTEX ) {
                let word = Symbol.new(null, INTEX, word);
                let i = Parse.intex(s, word, i);
                let s = Parse.tag(word);
            } else { if (cc = STREX) {
                let word = Symbol.new(null, STREX, word);
                let i = Parse.strex(s, word, i);
                let s = Parse.tag(word);
            }}

            do cmdlin.append(word);

            let i = Str.lskip(s, 32, i);

            let cc = Parse.cclass(s, i) & CLASSMASK;
        }

        return Parse.package(argv, cmdlin, s, i);
    }


    function int intex(String s, Symbol intex, int i) {
        var boolean uop;
        var int DLM, cc, op;
        var String t;
        var Collection stack, queue;
        var Symbol token, stkp;

        let DLM  = (BLANK | COMMA) | (END | EOS);
        let queue = Collection.new();
        let stack = Collection.new();
        do stack.push(Symbol.new(null, null, null));
        if (intex.data() = null) {
            let uop = true;
        } else {
            let uop = false;
            do queue.append(intex.data());
        }

        let cc = Parse.cclass(s, i);
        while ( (cc&DLM) = 0 ) {

            if (cc = NOLGL) {
                do LibSym.destroyList(stack);
                return Parse.package(intex, queue, s, -1);
            }

            if (cc = LPAREN) {
                do stack.push(Symbol.new(null, LPAREN, null));
                let uop = true;
                let i = i + 1;
            } else { if (cc = RPAREN) {
                let stkp = stack.nth(0);
                while (~(stkp.meta() = LPAREN)) {
                    if (stkp.meta() = null) {
                        do LibIO.error("mismatched parentheses");
                        do LibSym.destroyList(stack);
                        return Parse.package(intex, queue, s, -1);
                    }
                    do queue.append(stack.pop());
                    let stkp = stack.nth(0);
                }
                do stkp.dispose();
                let uop = false;
                let i = i + 1;
            } else { if ( (cc&OP) = OP ) {
                let op = s.charAt(i);
                let i = i + 1;
                if (uop) {  /* I don't love this. */
                    let token = Symbol.new(null, UOP, op);
                } else {
                    let token = Symbol.new(null, cc&OPMASK, op);
                    if (Parse.cclass(s, i) = EQ) {
                        do token.setData((op*100) + 61);
                        let i = i + 1;
                    }
                    /* pop higher/equal ops to queue */
                    let stkp = stack.nth(0);
                    while ( ~(stkp.meta()<token.meta())
                            /* & ~(stkp.meta()=LPAREN) */ ) {
                        do stkp.setMeta(OP);
                        do queue.append(stack.pop());
                        let stkp = stack.nth(0);
                    }
                    let uop = true;
                }
                do stack.push(token);
            } else {
                if (cc = INT) {
                    let t = String.new(5);
                    let i = Lex.token(s, t, TOKENMASK, i);
                    do queue.append(Symbol.new(null, INT, t.intValue()));
                    do t.dispose();
                } else { if (cc = SYM) {
                    let t = String.new(s.length());
                    let i = Lex.token(s, t, TOKENMASK, i);
                    do queue.append(Symbol.new(t, SYM, null));
                } else { if (cc = BLOCK) {
                    let token = Symbol.new(null, BLOCK, null);
                    let i = Parse.block(s, token, i);
                    let s = Parse.tag(token);
                    do queue.append(token);
                }}}

                let stkp = stack.nth(0);
                while (stkp.meta() = UOP) {
                    do queue.append(stack.pop());
                    let stkp = stack.nth(0);
                }

                let uop = false;
            }}}

            let cc = Parse.cclass(s, i);
        }

        /* pop ops to queue */
        let stkp = stack.nth(0);
        while (~(stkp.meta() = null)) {
            if (stkp.meta() = LPAREN) {
                do LibIO.error("mismatched parentheses");
                do LibSym.destroyList(stack);
                return Parse.package(intex, queue, s, -1);
            }
            do queue.append(stack.pop());
            let stkp = stack.nth(0);
        }

        do LibSym.destroyList(stack);

        return Parse.package(intex, queue, s, i);
    }


    function int strex(String s, Symbol strex, int i) {
        var int cc;
        var String t;
        var Collection argv;
        var Symbol arg, intex, next;

        let arg = strex.data();
        let argv = Collection.new();
        do argv.append(arg);

        if (~(arg.meta() = STR)) {
            do LibIO.error("format string not found");
            return Parse.package(strex, argv, s, -1);
        }

        while (Parse.cclass(s, i) = STREX) {

            let i = i + 1;
            let cc = Parse.cclass(s, i) & CLASSMASK;

            if (cc = NOLGL) {
                do LibIO.error("strex: illegal index");
                return Parse.package(strex, argv, s, -1);
            }

            if (cc = BLOCK) {
                let arg = Symbol.new(null, BLOCK, null);
                let i = Parse.block(s, arg, i);
                let s = Parse.tag(arg);
            } else { if (cc = INT) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, TOKENMASK, i);
                let arg = Symbol.new(null, INT, t.intValue());
                do t.dispose();
            } else { if (cc = INTEX) {
                let arg = Symbol.new(null, INTEX, null);
                let i = Parse.intex(s, arg, i);
                let s = Parse.tag(arg);
            } else { if (cc = STR) {
                let t = String.new(s.length());
                let i = Lex.string(s, t, i);
                if (i < 0) {
                    do LibIO.error("EOS while scanning string");
                    do t.dispose();
                    return Parse.package(strex, next, s, -1);
                }
                let arg = Symbol.new(null, STR, t);
            } else { if (cc = SYM) {
                let t = String.new(s.length());
                let i = Lex.token(s, t, TOKENMASK, i);
                let arg = Symbol.new(t, SYM, null);
            }}}}}

            if ( (Parse.cclass(s, i)&CLASSMASK) = INTEX ) {
                let arg = Symbol.new(null, INTEX, arg);
                let i = Parse.intex(s, intex, i);
                let s = Parse.tag(arg);
            }

            do argv.append(arg);
        }

        return Parse.package(strex, argv, s, i);
    }


    function int block(String s, Symbol argv, int i) {
        var int cc;
        var Collection block;
        var Symbol cmdlin;

        let block = Collection.new();
        let i = i + 1;
        while (true) {
            let cmdlin = Symbol.new(null, CMDLIN, null);
            let i = Parse.cmdlin(s, cmdlin, i);
            let s = Parse.tag(cmdlin);
            do block.append(cmdlin);
            let cc = Parse.cclass(s, i);
            if (cc = BEND) {
                return Parse.package(argv, block, s, i+1);
            }
            if (cc = NOLGL) {
                return Parse.package(argv, block, s, -1);
            }
            let s = LibIO.read(PS2);
            let i = 0;
        }

        return -1;
    }

}
