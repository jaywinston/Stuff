/**
 *  Depends on Str.jack 
 */
class Symbol {

    field int _type, _value;
    field String _name;
    field Symbol _next;
    field Symbol end;

    constructor Symbol new(String name, int type, int value) {
        if (name = null) {
            let _name = null;
        } else {
            let _name = Str.dup(name);
        }
        let _type = type;
        let _value = value;
        let _next = null;
        let end = this;
        return this;
    }

    method void dispose() {
        if (~(_name = null)) {
            do _name.dispose();
        }
        do Memory.deAlloc(this);
        return;
    }

    method int name() {
        return _name;
    }

    method int type() {
        return _type;
    }

    method int value() {
        return _value;
    }

    method int next() {
        return _next;
    }

    method void setName(int name) {
        let _name = name;
        return;
    }

    method void setType(int type) {
        let _type = type;
        return;
    }

    method void setValue(int value) {
        let _value = value;
        return;
    }

    method void setNext(int next) {
        let _next = next;
        return;
    }

    method void append(Symbol o) {
        if (~(o = null)) {
            do o.append(end.next());
            do end.setNext(o);
            let end = o;
        }
        return;
    }

    function void clear(Symbol sym) {
        var int type;
        var String s;
        var Symbol next;

        while (~(sym = null)) {

            let next = sym.next();

            let type = sym.type();
            if (type = Symbol.STR()) {
                let s = sym.value();
                if (~(s = null)) {
                    do s.dispose();
                }
            } else { if ( ((type=Symbol.BLOCK()) | (type=Symbol.CMDLIN()))
                         | (type=Symbol.FUNC()) ) {
                do Symbol.clear(sym.value());
            }}

            do sym.dispose();

            let sym = next;
        }

        return;
    }

    function Symbol copy(Symbol sym) {
        var int type;
        var Symbol p;

        let p = Symbol.new(null, null, null);

        while (~(sym = null)) {

            let type = sym.type();

            if (type = Symbol.STR()) {
                do p.append(Symbol.new(sym.name(),
                                       sym.type(),
                                       Str.dup(sym.value())));
            } else { if ( (type=Symbol.BLOCK())
                        |((type=Symbol.CMDLIN()) 
                        | (type=Symbol.FUNC())) ) {
                do p.append(Symbol.new(sym.name(),
                                       sym.type(),
                                       Symbol.copy(sym.value())));
            } else {
                do p.append(Symbol.new(sym.name(), sym.type(), sym.value()));
            }}

            let sym = sym.next();
        }

        let sym = p;
        let p = p.next();
        do sym.setNext(null);
        do Symbol.clear(sym);

        return p;
    }


    function int NULL      () { return  0; }
    function int BLOCK     () { return  1; }
    function int CMD       () { return  2; }
    function int CMDLIN    () { return  3; }
    function int FUNC      () { return  4; }
    function int END       () { return  5; }
    function int INT       () { return  6; }
    function int STR       () { return  7; }
    function int SYM       () { return  8; }

}
