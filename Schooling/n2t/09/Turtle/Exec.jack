class Exec {

    static int bottom, left, right, top;
    static int CMD, CMDLIN, FUNC, EXPR, INT, STR, SYM, TTL,
        ASSIGN, BLOCK, CLEAR, DISPOSE, FORWARD, FUNCTION, IF, PENDOWN, PENUP,
        PRINT, REPEAT, TURNLEFT, TURNRIGHT, TURTLE, QUIT;
    static TextBox tb;
    static Symbol turtle;
    static Turtle t;


    function void init(int i, int j, int h, int w) {

        let tb = TextBox.new(i, j, h, w);
        let top = i * 11;
        let left = j * 8;
        let bottom = (i+h) * 11;
        let right = (j+w) * 8;

        do Exec.initKWs();
        do Exec.getTurtle();

        return;
    }


    /* intialize key words and internal symbols */
    function void initKWs() {
        var int i;

        let BLOCK   = LibSym.BLOCK();
        let CMD     = LibSym.CMD();
        let CMDLIN  = LibSym.CMDLIN();
        let EXPR    = LibSym.EXPR();
        let FUNC    = LibSym.FUNC();
        let INT     = LibSym.INT();
        let STR     = LibSym.STR();
        let SYM     = LibSym.SYM();
        let TTL     = LibSym.TTL();

        let ASSIGN    =  1;
        let CLEAR     =  2;
        let DISPOSE   =  3;
        let FORWARD   =  4;
        let FUNCTION  =  5;
        let IF        =  6;
        let PENDOWN   =  7;
        let PENUP     =  8;
        let PRINT     =  9;
        let REPEAT    = 10;
        let TURNLEFT  = 11;
        let TURNRIGHT = 12;
        let TURTLE    = 13;
        let QUIT      = 14;

        do Exec.installKW("MV",128);  // ##DB##

        do Exec.installKW("=",         ASSIGN);
        do Exec.installKW("CLEAR",     CLEAR);
        do Exec.installKW("DISPOSE",   DISPOSE);
        do Exec.installKW("FORWARD",   FORWARD);
        do Exec.installKW("FUNCTION",  FUNCTION);
        do Exec.installKW("IF",        IF);
        do Exec.installKW("PENDOWN",   PENDOWN);
        do Exec.installKW("PENUP",     PENUP);
        do Exec.installKW("PRINT",     PRINT);
        do Exec.installKW("REPEAT",    REPEAT);
        do Exec.installKW("TURNLEFT",  TURNLEFT);
        do Exec.installKW("TURNRIGHT", TURNRIGHT);
        do Exec.installKW("TURTLE",    TURTLE);
        do Exec.installKW("QUIT",      QUIT);

        return;
    }


    function void installKW(String name, int val) {
        do Eval.install(name, CMD, val);
        do name.dispose();
        return;
    }


    function void getTurtle() {
        let t = Turtle.new(left + ((right-left)/2),
                           top + ((bottom-top)/2),
                           90, top, left, bottom, right);
        return;
    }


    function void clear() {
        do t.dispose();
        do tb.clear();
        do Exec.getTurtle();
        return;
    }


    function void try(Symbol argv) {
        var Symbol retval;

        let retval = Exec.exec(argv);

        if (Error.isSet()) {
            while (Error.isSet()) {
                do IOBox.echo(Error.message());
            }
        } else {
            do Exec.echo(retval);
        }

        do LibSym.destroyList(retval);

        return;
    }


    function Symbol exec(Symbol argv) {
        var int cmd;

        if (argv = null) {
            return null;
        }

        if (argv.meta() = BLOCK)  { return Exec.execBlock(argv.data()); }
        if (argv.meta() = CMDLIN) { return Exec.exec(argv.data());      }

        do Eval.arg(argv);

        if   (argv.meta() = FUNC) { return Exec.call(argv);             }
        if (~(argv.meta() = CMD)) { return argv;                        }

        let cmd = argv.data();

        if (cmd = TURTLE) { return Exec.newTurtle(argv.next());         }

        if (cmd = ASSIGN)           { do Exec.doAssign(argv.next());    }
        else { if (cmd = CLEAR)     { do Exec.doClear(argv.next());     }
        else { if (cmd = DISPOSE)   { do Exec.doDispose(argv.next());   }
        else { if (cmd = FORWARD)   { do Exec.doForward(argv.next());   }
        else { if (cmd = FUNCTION)  { do Exec.doFunction(argv.next());  }
        else { if (cmd = IF)        { do Exec.doIf(argv.next());        }
        else { if (cmd = PENDOWN)   { do Exec.doPendown(argv.next());   }
        else { if (cmd = PENUP)     { do Exec.doPenup(argv.next());     }
        else { if (cmd = PRINT)     { do Exec.doPrint(argv.next());     }
        else { if (cmd = REPEAT)    { do Exec.doRepeat(argv.next());    }
        else { if (cmd = TURNLEFT)  { do Exec.doTurnleft(argv.next());  }
        else { if (cmd = TURNRIGHT) { do Exec.doTurnright(argv.next()); }
        else { if (cmd = QUIT)      { do Exec.doQuit(argv.next());      }
        }}}}}}}}}}}}

        if (cmd=128) {do DB.mv();}  // ##DB##

        do LibSym.destroyList(argv);

        return null;
    }


    function Symbol call(Symbol argv) {
        var int n;
        var Array fargs;
        var String argname, fstr;
        var Symbol arg, ret;

        do Eval.pushScope(3);

        let fargs = Array.new(1);
        let fstr = "$%D";
        let n = 0;

        let arg = argv.next();
        while (~(arg = null)) {
            let n = n + 1;
            let fargs[0] = n;
            let argname = Str.format(fstr, fargs);
            do Eval.arg(arg);
            do Eval.install(argname, arg.meta(), arg.data());
            do argname.dispose();
            let arg = arg.next();
        }

        let ret = Exec.exec(LibSym.copyList(argv.data()));

        do Eval.dropScope();
        do LibSym.destroyList(argv);
        do fargs.dispose();
        do fstr.dispose();

        return ret;
    }


    function Symbol execBlock(Symbol b) {

        if (b = null) {
            return null;
        }

        while (~(b.next() = null)) {
            do Exec.try(LibSym.copyList(b.data()));
            let b = b.next();
        }

        return Exec.exec(LibSym.copyList(b.data()));
    }


    function Symbol newTurtle(Symbol argv) {
        var int d, x, y;
        var Turtle tt;

        do Eval.arg(argv);
        let x = argv.data();
        let argv = argv.next();
        do Eval.arg(argv);
        let y = argv.data();
        let argv = argv.next();
        do Eval.arg(argv);
        let d = argv.data();


        do Exec.try(argv.next());

        return Symbol.new(null, TTL,
                          Turtle.new(x, y, d, top, left, bottom, right));
    }


    function void doAssign(Symbol arg) {
        do Eval.assign(arg.data());
        do Exec.try(arg.next());
        return;
    }


    function void doClear(Symbol arg) {
        do Exec.clear();
        do Exec.try(arg);
        return;
    }


    function void doDispose(Symbol arg) {
        var Turtle tt;

        do Eval.arg(arg);
        let tt = arg.data();
        do tt.dispose();

        return;
    }


    function void doForward(Symbol arg) {
        var int errno;  // ##TEMP##
        var Turtle tt;

        do Eval.arg(arg);

        if (arg.meta() = TTL) {
            let tt = arg.data();
            let arg = Eval.arg(arg.next());
        } else {
            let tt = t;
        }

        let errno = tt.forward(arg.data());  // ##TEMP##
        if (errno = 1) {
            do Error.send("won't go backwards");  // ##DB##
            do Error.set(1);  // won't go backwards
        }

        if (errno = 2) {
            do Error.send("target beyond boundary");  // ##DB##
            do Error.set(1);  // target beyond boundary
        }

        /* do Error.set(t.forward(arg.data())); will be this */

        do Exec.try(arg.next());
        return;
    }


    function void doFunction(Symbol arg) {

        if (arg = null) {
            do Error.send("no function name");  // ##DB##
            do Error.set(1);  // no function name
            return;
        }

        do Eval.install(arg.name(), FUNC, LibSym.copyList(arg.next()));

        return;
    }


    function void doIf(Symbol arg) {
        var Symbol elsep;

        let elsep = Exec.elsePointer(arg);

        do Eval.arg(arg);

        if (~(arg.data() = 0)) {
            do Exec.try(arg.next());
        } else { if (~(elsep = null)) {
            do Exec.try(elsep.next());
        }}

        return;
    }


    function Symbol elsePointer(Symbol argv) {
        var int ifc;
        var String IF, ELSE;
        var Symbol argp;

        let IF = "IF";
        let ELSE = "ELSE";

        let argp = argv.next();
        while (~(argp = null)) {
            if (HashTable.streq(ELSE, argp.name())) {
                if (ifc = 0) {
                    do IF.dispose();
                    do ELSE.dispose();
                    do argv.setNext(null);
                    return argp;
                } else {
                    let ifc = ifc - 1;
                }
            } else { if (HashTable.streq(IF, argp.name())) {
                let ifc = ifc + 1;
            }}
            let argv = argv.next();
            let argp = argp.next();
        }

        do IF.dispose();
        do ELSE.dispose();

        return null;
    }


    function void doPendown(Symbol arg) {
        do t.pendown();
        do Exec.try(arg);
        return;
    }


    function void doPenup(Symbol arg) {
        do t.penup();
        do Exec.try(arg);
        return;
    }


    function void doPrint(Symbol arg) {

        if (tb.set(t.y()/11, (t.x()/8)+1) = 1) {
            do Error.send("illegal cursor coordinate");  // ##DB##
            do Error.set(1);  // illegal cursor coordinate
            return;
        }

        do Eval.arg(arg);

        do t.hide();

        do tb.puts(arg.data());

        do t.show();

        do Exec.try(arg.next());
        return;
    }


    function void doRepeat(Symbol arg) {
        var int i;

        do Eval.arg(arg);

        if ( (arg.meta()=CMD) & (arg.data()=IF) ) {
            do Exec.doRepeatIf(arg.next());
            return;
        }

        /* todo: type check */

        let i = arg.data();
        while (i > 0) {
            do Exec.try(arg.next());
            let i = i - 1;
        }

        return;
    }


    function void doRepeatIf(Symbol arg) {
        var int condition;
        var Symbol p;

        do Eval.arg(arg);

        let condition = arg.data();
        while (~(condition = 0)) {
            do Exec.try(LibSym.copyList(arg.next()));
            let p = Eval.arg(Eval.eval(arg.name(), 0));
            let condition = p.data();
            do LibSym.destroyList(p);
        }

        return;
    }


    function void doTurnleft(Symbol arg) {
        do Eval.arg(arg);
        do t.turnleft(arg.data());
        do Exec.try(arg.next());
        return;
    }


    function void doTurnright(Symbol arg) {
        do Eval.arg(arg);
        do t.turnright(arg.data());
        do Exec.try(arg.next());
        return;
    }


    function void doQuit(Symbol arg) {
        do Sys.halt();
        return;
    }


    function void echo(Symbol sym) {

        if (sym = null) {
            return;
        }

        if (sym.meta() = STR) {
            do IOBox.echo(sym.data());
        } else { if (sym.meta() = INT) {
            do Exec.echoInt(sym);
        }}

        do Exec.try(sym.next());

        return;
    }


    function void echoInt(Symbol sym) {
        var String s;

        let s = String.new(6);
        do s.setInt(sym.data());
        do IOBox.echo(s);
        do s.dispose();

        return;
    }


    function void install(String name, int type, int value) {
        do symtab.install(name, type, value);
        return;
    }


    function Symbol lookup(String s) {
        return symtab.lookup(s);
    }


    function void assign(Symbol argv) {
        var int type;
        var String name;
        var Symbol value;

        let value = Eval.arg(argv.next());

        if (value = null) {
            let type = 0;
        } else {
            let type = value.meta();
        }

        if (value.meta() = STR) {
            do symtab.install(argv.name(), type, Str.dup(value.data()));
        } else {
            do symtab.install(argv.name(), type, value.data());
        }

        return;
    }

}
