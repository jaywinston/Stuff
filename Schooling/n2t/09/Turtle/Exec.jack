class Exec {

    static int bottom, left, right, top;
    static int TERM;
    static Array INTOPS;
    static SymbolTable symtab;
    static TextBox tb;
    static Turtle t;

    static int
        CMD,
        CMDLIN,
        FUNC,
        HASHTAB,
        INT,
        STR,
        SYM,

        ASSIGN,
        BLOCK,
        CLEAR,
        ELSE,
        FORWARD,
        FUNCTION,
        IF,
        PENDOWN,
        PENUP,
        PRINT,
        REPEAT,
        TURNLEFT,
        TURNRIGHT,
        QUIT;


    function void init(int i, int j, int h, int w) {

        let tb = TextBox.new(i, j, h, w);
        let top = i * 11;
        let left = j * 8;
        let bottom = (i + h) * 11;
        let right = (j + w) * 8;
        let symtab = SymbolTable.new(15);

        let TERM = 4;
        let INTOPS = Array.new(4);
        let INTOPS[0] = "&|({";
        let INTOPS[1] = "=!<>({";
        let INTOPS[2] = "+-({";
        let INTOPS[3] = "*/%({";

        do Exec.initKWs();
        do Exec.getTurtle();

        return;
    }


    /* intialize key words and internal symbols */
    function void initKWs() {
        var int i;

        let BLOCK   = Symbol.BLOCK();
        let CMD     = Symbol.CMD();
        let CMDLIN  = Symbol.CMDLIN();
        let FUNC    = Symbol.FUNC();
        let HASHTAB = Symbol.HASHTAB();
        let INT     = Symbol.INT();
        let STR     = Symbol.STR();
        let SYM     = Symbol.SYM();

        let ASSIGN    =  0;
        let CLEAR     =  2;
        let ELSE      =  3;
        let FORWARD   =  4;
        let FUNCTION  =  5;
        let IF        =  6;
        let PENDOWN   =  7;
        let PENUP     =  8;
        let PRINT     =  9;
        let REPEAT    = 10;
        let TURNLEFT  = 11;
        let TURNRIGHT = 12;
        let QUIT      = 13;

        do Exec.installKW("MV",128);  // ##DB##

        do Exec.installKW("=",         ASSIGN);
        do Exec.installKW("CLEAR",     CLEAR);
        do Exec.installKW("ELSE",      ELSE);
        do Exec.installKW("FORWARD",   FORWARD);
        do Exec.installKW("FUNCTION",  FUNCTION);
        do Exec.installKW("IF",        IF);
        do Exec.installKW("PENDOWN",   PENDOWN);
        do Exec.installKW("PENUP",     PENUP);
        do Exec.installKW("PRINT",     PRINT);
        do Exec.installKW("REPEAT",    REPEAT);
        do Exec.installKW("TURNLEFT",  TURNLEFT);
        do Exec.installKW("TURNRIGHT", TURNRIGHT);
        do Exec.installKW("QUIT",      QUIT);

        return;
    }


    function void installKW(String name, int val) {
        do symtab.install(name, CMD, val);
        do name.dispose();
        return;
    }


    function void getTurtle() {
        let t = Turtle.new(left + ((right-left)/2),
                           top + ((bottom-top)/2),
                           90, top, left, bottom, right);
        return;
    }


    function void clear() {
        do t.dispose();
        do tb.clear();
        do Exec.getTurtle();
        return;
    }


    function void try(Symbol argv) {
        var Symbol retval;

        let retval = Exec.exec(argv);

        if (Error.isSet()) {
            while (Error.isSet()) {
                do IOBox.echo(Error.message());
            }
        } else {
            do Exec.echo(retval);
        }

        do Symbol.clear(retval);

        return;
    }


    function Symbol exec(Symbol argv) {
        var int cmd;

        if (argv = null) {
            return null;
        }

        if (argv.type() = BLOCK)  { return Exec.execBlock(argv.value()); }
        if (argv.type() = CMDLIN) { return Exec.exec(argv.value());      }

        do Exec.arg(argv);

        if (argv.type() = FUNC) {
            return Exec.call(argv);
        }

        if (~(argv.type() = CMD)) {
            return argv;
        }

        let cmd = argv.value();

        if (cmd = ASSIGN)           { do Exec.doAssign(argv.next());    }
        else { if (cmd = CLEAR)     { do Exec.doClear(argv.next());     }
        else { if (cmd = FORWARD)   { do Exec.doForward(argv.next());   }
        else { if (cmd = FUNCTION)  { do Exec.doFunction(argv.next());  }
        else { if (cmd = IF)        { do Exec.doIf(argv.next());        }
        else { if (cmd = PENDOWN)   { do Exec.doPendown(argv.next());   }
        else { if (cmd = PENUP)     { do Exec.doPenup(argv.next());     }
        else { if (cmd = PRINT)     { do Exec.doPrint(argv.next());     }
        else { if (cmd = REPEAT)    { do Exec.doRepeat(argv.next());    }
        else { if (cmd = TURNLEFT)  { do Exec.doTurnleft(argv.next());  }
        else { if (cmd = TURNRIGHT) { do Exec.doTurnright(argv.next()); }
        else { if (cmd = QUIT)      { do Exec.doQuit(argv.next());      }
        }}}}}}}}}}}

        if (cmd=128) {do DB.mv();}  // ##DB##

        do Symbol.clear(argv);

        return null;
    }

    function Symbol call(Symbol argv) {
        var int n;
        var Array farg;
        var String argname, fpres;
        var Symbol arg, ret;

        do symtab.pushScope(3);

        let farg = Array.new(1);
        let fpres = "$%d";
        let n = 0;

        let arg = argv.next();
        while (~(arg = null)) {
            let n = n + 1;
            let farg[0] = n;
            let argname = Str.format(fpres, farg);
            do Exec.arg(arg);
            do Eval.install(argname, arg.type(), arg.value());
            do argname.dispose();
            let arg = arg.next();
        }

        let ret = Exec.exec(Symbol.copy(argv.value()));

        do Symbol.clear(argv);
        do farg.dispose();
        do fpres.dispose();

        return ret;
    }


    function Symbol execBlock(Symbol b) {
        var Symbol p;

        let p = Exec.doBlock(b);
        do Symbol.clear(b);

        return p;
    }


    function Symbol doBlock(Symbol b) {

        if (b = null) {
            return null;
        }

        while (~(b.next() = null)) {
            do Symbol.clear(Exec.exec(Symbol.copy(b.value())));
            let b = b.next();
        }

        return Exec.exec(Symbol.copy(b.value()));
    }


    function void doAssign(Symbol arg) {
        do Exec.assign(arg);
        return;
    }


    function void doClear(Symbol arg) {
        do Exec.clear();
        return;
    }


    function void doForward(Symbol arg) {
        var int errno;  // ##TEMP##

        do Exec.arg(arg);

        let errno = t.forward(arg.value());  // ##TEMP##
        if (errno = 1) {
            do Error.send("won't go backwards");  // ##DB##
            do Error.set(1);  // won't go backwards
        }

        if (errno = 2) {
            do Error.send("target beyond boundary");  // ##DB##
            do Error.set(1);  // target beyond boundary
        }

        /* do Error.set(t.forward(arg.value())); will be this */

        return;
    }


    function void doFunction(Symbol arg) {

        if (arg = null) {
            do Error.send("no function name");  // ##DB##
            do Error.set(1);  // no function name
            return;
        }

        do symtab.install(arg.name(), FUNC, Symbol.copy(arg.next()));

        return;
    }


    function void doIf(Symbol arg) {

        do Exec.arg(arg);

        if (~(arg.value() = 0)) {
            do Exec.try(arg.next());
        }

        return;
    }

    function void doPendown(Symbol arg) {
        do t.pendown();
        return;
    }


    function void doPenup(Symbol arg) {
        do t.penup();
        return;
    }


    function void doPrint(Symbol arg) {

        if (tb.set(t.y()/11, (t.x()/8)+1) = 1) {
            do Error.send("illegal cursor coordinate");  // ##DB##
            do Error.set(1);  // illegal cursor coordinate
            return;
        }

        do Exec.arg(arg);

        do t.hide();

        do tb.puts(arg.value());

        do t.show();

        return;
    }


    function void doRepeat(Symbol arg) {
        var int i;

        do Exec.arg(arg);

        if ( (arg.type()=CMD) & (arg.value()=IF) ) {
            do Exec.doRepeatIf(arg.next());
            return;
        }

        /* todo: type check */

        let i = arg.value();
        while (i > 0) {
            do Exec.try(arg.next());
            let i = i - 1;
        }

        return;
    }


    function void doRepeatIf(Symbol arg) {
        var int condition;
        var Symbol p;

        do Exec.arg(arg);

        let condition = arg.value();
        while (~(condition = 0)) {
            do Exec.try(Symbol.copy(arg.next()));
            let p = Eval.eval(arg.name(), 0);
            let condition = p.value();
            do Symbol.clear(p);
        }

        return;
    }


    function void doTurnleft(Symbol arg) {
        do Exec.arg(arg);
        do t.turnleft(arg.value());
        return;
    }


    function void doTurnright(Symbol arg) {
        do Exec.arg(arg);
        do t.turnright(arg.value());
        return;
    }


    function void doQuit(Symbol arg) {
        do Sys.halt();
        return;
    }


    function void echo(Symbol sym) {
        while (~(sym = null)) {
            if (sym.type() = STR) {
                do IOBox.echo(sym.value());
            } else { if (sym.type() = SYM) {
                //do Exec.echo(sym.value());
            } else { if (sym.type() = INT) {
                do Exec.echoInt(sym);
            }}}
            let sym = sym.next();
        }
        return;
    }


    function void echoInt(Symbol sym) {
        var String s;

        let s = String.new(6);
        do s.setInt(sym.value());
        do IOBox.echo(s);
        do s.dispose();

        return;
    }


    function void install(String name, int type, int value) {
        do symtab.install(name, type, value);
        return;
    }


    function Symbol lookup(String s) {
        return symtab.lookup(s);
    }


    function void assign(Symbol argv) {
        var int type;
        var String name;
        var Symbol value;

        let value = Exec.arg(argv.next());

        if (value = null) {
            let type = 0;
        } else {
            let type = value.type();
        }

        if (value.type() = STR) {
            do symtab.install(argv.name(), type, Str.dup(value.value()));
        } else {
            do symtab.install(argv.name(), type, value.value());
        }

        return;
    }

    function Symbol arg(Symbol arg) {
        var int type;
        var Symbol p;

        if (arg = null) {
            return null;
        }

        let type = arg.type();
        let p = null;

        if (type = BLOCK) {
            let p = Exec.execBlock(arg.value());
            do Symbol.clear(arg.value());
        } else { if (type = SYM) {
            let p = Exec.lookup(arg.name());
            if (p = null) {
                do Error.send("undefined symbol");  // ##DB##
                do Error.set(1);  // undefined symbol
                return null;
            }
        } else { if (type = INT) {
            do arg.setValue(Exec.integer(arg.name(), 0, 0));
        } else {
            return arg;
        }}}

        if (~(p = null)) {
            if ( (p.type()=BLOCK) | (p.type()=FUNC) ) {
                do arg.setValue(Symbol.copy(p.value()));
            } else { if (p.type() = STR) {
                do arg.setValue(Str.dup(p.value()));
            } else {
                do arg.setValue(p.value());
            }}

            do arg.setType(p.type());
            if (type = BLOCK) {
                do p.dispose();
            }
        }

        return arg;
    }


    function int integer(String s, int i, int depth) {
        var char op;
        var int n;
        var String t;

        if (i = s.length()) {
            do Error.send("expected integer expression");  // ##DB##
            do Error.set(1);  //  expected integer expression
            return 0;
        }
            
        if (depth = TERM) {
            return Exec.term(s);
        }

        let t = String.new(s.length());
        let i = Lex.integer(s, t, INTOPS[depth], i);

        if (Error.isSet()) {
            do t.dispose();
            return 0;
        }

        let n = Exec.integer(t, 0, depth+1);

        do t.dispose();

        if (i < s.length()) {

            let op = s.charAt(i);

            if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                let op = op + 200;
                let i = i + 1;
            }}

            let n = Exec.operate(n, Exec.integer(s, i+1, depth), op);
        }

        return n;
    }


    function int term(String s) {
        var char c;
        var Symbol p;

        let c = s.charAt(0);

        if (c = 45) {
            do Str.shift(s, 1, 0);
            return -Exec.term(s);
        }

        if (c = 126) {
            do Str.shift(s, 1, 0);
            return ~Exec.term(s);
        }

        if ( (c>47) & (c<58) ) {
            return s.intValue();
        }

        if (c = 40) {
            return Exec.parenTerm(s);
        }

        if (c = 123) {
            return Exec.blockTerm(s);
        }

        return Exec.symbolTerm(s);

    }


    function int parenTerm(String s) {

        do s.eraseLastChar();
        do Str.shift(s, 1, 0);

        return Exec.integer(s, 0, 0);
    }


    function int blockTerm(String s) {
        var int n;
        var Symbol value;
        var Symbol block;

        let block = Eval.blockExpr(s);
        let value = Exec.execBlock(block.value());
        do Symbol.clear(block);

        if (~(value.type() = INT)) {
            do Error.send("wrong type; expected integer");  // ##DB##
            do Error.set(1);  // wrong type; expected integer
        }

        let n = value.value();

        do Symbol.clear(value);

        return n;
    }


    function int symbolTerm(String s) {
        var Symbol p;

        let p = Exec.lookup(s);

        if (p = null) {
            do Error.send("undefined symbol");  // ##DB##
            do Error.set(1);  // undefined symbol
            return 0;
        }

        if (~(p.type() = INT)) {
            do Error.send("wrong type; expected integer");  // ##DB##
            do Error.set(1);  // wrong type; expected integer
            return 0;
        }

        return p.value();
    }


    function int operate(int m, int n, char op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do Error.send("division by zero");  // ##DB##
            do Error.set(1);  // division by zero
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Lib.mod(m, n); }

        if (op = 261) { return   m = n;  }
        if (op = 233) { return ~(m = n); }
        if (op =  60) { return   m < n;  }
        if (op =  62) { return   m > n;  }
        if (op = 260) { return  (m<n) | (m=n); }
        if (op = 262) { return  (m>n) | (m=n); }

        do Error.send("unrecognized operator");  // ##DB##
        do Error.set(1);  // unrecognized operator
        return 0;
    }


}
