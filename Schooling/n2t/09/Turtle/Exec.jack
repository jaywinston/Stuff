// Site use of the "meta" namespace is bit[0] to classify executables.

class Exec {

    static int BIN, BLOCK, CMD, CMDLIN, EXE, FUNC, INT, LIST, SITE, STR;
    static int ASSIGN, FUNCTION, IF, REPEAT, QUIT;
    static String IFS, ELSES;


    function void init() {

        let IFS = "IF";
        let ELSES = "ELSE";

        let BIN = LibSym.BIN();
        let BLOCK = LibSym.BLOCK();
        let CMD = LibSym.CMD();
        let CMDLIN = LibSym.CMDLIN();
        let EXE = 1;  /* magic number! */
        let FUNC = LibSym.FUNC();
        let INT = LibSym.INT();
        let LIST = LibSym.LIST();
        let SITE = LibSym.SITE() | EXE;
        let STR = LibSym.STR();

        let ASSIGN   = 1;
        let FUNCTION = 2;
        let IF       = 3;
        let REPEAT   = 4;
        let QUIT     = 5;

        do Eval.install("MV", CMD,128);  // ##DB##

        do Eval.install("ASSIGN", CMD, ASSIGN);
        do Eval.install("FUNCTION", CMD, FUNCTION);
        do Eval.install("IF", CMD, IF);
        do Eval.install("REPEAT", CMD, REPEAT);
        do Eval.install("QUIT", CMD, QUIT);

        return;
    }


    function void kill() {
        do IFS.dispose();
        do ELSES.dispose();
        return;
    }


    function Symbol cmdlin(Symbol cmdlin) {
        var int cmd, type;
        var Collection argv;
        var Symbol arg;

        let argv = cmdlin.data();
        let arg = Eval.arg(argv.pop());

        if (arg = null) {
            return null;
        }

        if (~( (arg.meta()&SITE) = EXE )) {
            return arg;
        }

        let cmd = arg.data();
        let type = arg.meta();
        do arg.dispose();

        if (type = BIN)  { return Bin.exec(cmd, argv);  }
        if (type = CMD)  { return Exec.cmd(cmd, argv);  }
        if (type = FUNC) { return Exec.call(cmd, argv); }

        return null;
    }


    function Symbol cmd(int cmd, Collection argv) {

        if (cmd = ASSIGN)          { return Exec.doAssign(argv);   }
        else { if (cmd = FUNCTION) { return Exec.doFunction(argv); }
        else { if (cmd = IF)       { return Exec.doIf(argv);       }
        else { if (cmd = REPEAT)   { return Exec.doRepeat(argv);   }
        else { if (cmd = QUIT)     { return Exec.doQuit(argv);     }
        }}}}

        if (cmd=128) {do DB.mv();}  // ##DB##

        return null;
    }


    function Symbol call(Collection func, Collection argv) {
        var Symbol ret;

        do Eval.pushScope(3, argv);
        let ret = Exec.cmdlin(func);
        do Eval.dropScope();
        do LibSym.destroyList(func);

        return ret;
    }


    function Symbol block(Symbol block) {
        var Collection cmdlist;
        var Symbol cmd;

        if (block = null) {
            return null;
        }

        let cmdlist = block.data();

        while (cmdlist.length() > 1) {
            do LibSym.destroySym(
                Main.enqueue(
                    Exec.cmdlin(cmdlist.pop())));
        }

        return Exec.cmdlin(cmdlist.pop());
    }


    function void doAssign(Collection argv) {
        var String name;
        var Symbol arg;

        let arg = argv.pop();
        let name = arg.tag();
        do arg.dispose();
        let arg = Eval.arg(argv.pop());
        if (arg = null) {
            do LibIO.error("expected expression");
        }
        do Eval.install(name, arg.meta(), arg.data());
        do arg.dispose();

        return;
    }


    function void doFunction(Collection argv) {
        var Symbol arg;

        let arg = argv.pop();

        if (arg = null) {
            do LibIO.error("no function name");
            return;
        }

        do Eval.install(arg.tag(), FUNC, LibSym.copyList(argv));

        do arg.dispose();
        do LibSym.destroyList(argv);

        return;
    }


    function void doIf(Collection argv) {
        var Collection elsev;
        var Symbol arg;

        let arg = Eval.arg(argv.pop());
        let elsev = Exec.elseVector(argv);

        if (~(arg.data() = 0)) {
            do Exec.cmdlin(argv);
        } else { if (~(elsev = null)) {
            do Exec.cmdlin(elsev);
        }}

        do arg.dispose();
        do LibSym.destroyList(argv);
        do LibSym.destroyList(elsev);

        return;
    }


    function Collection elseVector(Collection argv) {
        var int i;
        var int nif;
        var Symbol arg;

        let nif = 0;

        let i = 0;
        while (i < argv.length()) {
            let arg = argv.nth(i);
            if (Str.eq(ELSES, arg.tag())) {
                if (nif = 0) {
                    return Exec.elsev(argv, i);
                } else { if (nif < 0) {
                    do LibIO.error("extra 'ELSE' (todo: a better message)");
                    return null;
                } else {
                    let nif = nif - 1;
                }}
            } else { if (Str.eq(IFS, argp.tag())) {
                let nif = nif + 1;
            }}
            let i = i + 1;
        }

        return null;
    }


    /* Collection.slice() would be easier to read but redundant to execute. */
    function Collection elsev(Collection argv, int i) {
        var Collection elsev;
        var Symbol elsep;

        let elsev = Collection.new();
        while (argv.length() > i) {
            do elsev.push(argv.remove(argv.length()-1));
        }

        let elsep = argv.remove(argv.length()-1);
        do elsep.dispose();

        return elsev;
    }


    function void doRepeat(Collection argv) {
        var int i;
        var Symbol arg, cmdp;

        let arg = Eval.arg(argv.pop());

        if (arg = null) {
            /* todo: abort */
            return;
        }

        if ( (arg.meta()=CMD) & (arg.data()=IF) ) {
            do arg.dispose();
            do Exec.doRepeatIf(argv);
            return;
        }

        /* todo: type check */

        let i = arg.data();
        do arg.dispose();
        while (i > 0) {
            do LibSym.destroySym(
                Main.enqueue(  /* syscall! */
                    Exec.cmdlin(
                        LibSym.copyList(argv))));
            let i = i - 1;
        }

        do LibSym.destroyList(argv);

        return;
    }


    function void doRepeatIf(Collection argv) {
        var int condition;
        var Symbol arg;

        let arg = argv.pop();

        let condition = Eval.condition(arg);
        while (~(condition = 0)) {
            do LibSym.destroySym(
                Main.enqueue(  /* syscall! */
                    Exec.cmdlin(
                        LibSym.copyList(argv))));
            let condition = Eval.condition(arg);
        }

        do LibSym.destroyList(argv);
        do LibSym.destroySym(arg);

        return;
    }


    function void doQuit(Symbol arg) {
        do Main.quit();  /* syscall! */
        return;
    }

}
