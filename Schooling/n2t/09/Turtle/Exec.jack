class Exec {

    static int bottom, left, right, top;
    static int CMD, CMDLIN, FUNC, INT, LIST, STR, TTL;
    static int ASSIGN, BLOCK, CLEAR, DIR, DISPOSE, FORWARD, FUNCTION, IF,
        PENDOWN, PENUP, POSX, POSY, PRINT, REPEAT, TURNLEFT, TURNRIGHT,
        TURTLE, QUIT;
    static TextBox tb;
    static Symbol turtles;
    static Turtle t;


    function void init(int i, int j, int h, int w) {

        let tb = TextBox.new(i, j, h, w);
        let top = i * 11;
        let left = j * 8;
        let bottom = (i+h) * 11;
        let right = (j+w) * 8;
        let t = Exec.defaultTurtle();
        let turtles = Symbol.new(null, null, t);

        do Exec.initKWs();

        return;
    }


    function void dispose() {
        var Symbol np;

        do tb.dispose();

        while (~(turtles = null)) {
            let np = turtles.next();
            let t = turtles.data();
            do t.dispose();
            do turtles.dispose();
            let turtles = np;
        }

        return;
    }


    function Turtle defaultTurtle() {
        return Turtle.new(left + ((right-left)/2),
                          top + ((bottom-top)/2),
                          90, top, left, bottom, right);
    }


    function void initKWs() {
        var int i;

        let BLOCK   = LibSym.BLOCK();
        let CMD     = LibSym.CMD();
        let CMDLIN  = LibSym.CMDLIN();
        let FUNC    = LibSym.FUNC();
        let INT     = LibSym.INT();
        let LIST    = LibSym.LIST();
        let STR     = LibSym.STR();
        let TTL     = LibSym.TTL();

        let ASSIGN    =  1;
        let CLEAR     =  2;
        let DIR       =  3;
        let DISPOSE   =  4;
        let FORWARD   =  5;
        let FUNCTION  =  6;
        let IF        =  7;
        let PENDOWN   =  8;
        let PENUP     =  9;
        let POSX      = 10;
        let POSY      = 11;
        let PRINT     = 12;
        let REPEAT    = 13;
        let TURNLEFT  = 14;
        let TURNRIGHT = 15;
        let TURTLE    = 16;
        let QUIT      = 17;

        do Exec.installKW("MV",128);  // ##DB##

        do Exec.installKW("ASSIGN", ASSIGN);
        do Exec.installKW("CLEAR", CLEAR);
        do Exec.installKW("DIR", DIR);
        do Exec.installKW("DISPOSE", DISPOSE);
        do Exec.installKW("FORWARD", FORWARD);
        do Exec.installKW("FUNCTION", FUNCTION);
        do Exec.installKW("IF", IF);
        do Exec.installKW("PENDOWN", PENDOWN);
        do Exec.installKW("PENUP", PENUP);
        do Exec.installKW("POSX", POSX);
        do Exec.installKW("POSY", POSY);
        do Exec.installKW("PRINT", PRINT);
        do Exec.installKW("REPEAT", REPEAT);
        do Exec.installKW("TURNLEFT", TURNLEFT);
        do Exec.installKW("TURNRIGHT", TURNRIGHT);
        do Exec.installKW("TURTLE", TURTLE);
        do Exec.installKW("QUIT", QUIT);

        return;
    }


    function void installKW(String name, int val) {
        do Eval.install(name, CMD, val);
        do name.dispose();
        return;
    }


    function void clear() {
        var Turtle tt;

        let tt = t;
        let t = turtles.data(); // todo: need get tail of turtles first?
        do t.dispose();
        do tb.clear();
        do turtles.setData(Exec.defaultTurtle());
        let t = tt;

        return;
    }


    function void try(Symbol argv) {
        var String s;
        var Symbol ret;

        if (LibIO.noerr()) {  /* This is the check for parse errors. */
            let ret = Exec.exec(argv);
            do Exec.fixBorders();
            if (LibIO.noerr()) {
                do Exec.enqueue(ret);
            }
            do LibSym.destroyList(ret);
        }

        /* Error messages are queued. */
        do LibIO.clearerr();

        while (LibIO.has()) {
            let s = LibIO.get();
            do LibIO.echo(s);
            do s.dispose();
        }

        return;
    }


    function Symbol exec(Symbol argv) {
        var int cmd;
        var Turtle tt;

        if (argv = null) {
            return null;
        }

        if (argv.meta() = BLOCK)  { return Exec.block(argv);   }
        if (argv.meta() = CMDLIN) { return Exec.exec(argv.data()); }

        do Eval.arg(argv);

        if (argv.meta() = TTL) {
            let tt = t;
            let t = argv.data();
            do Exec.try(argv.next());
            let t = tt;
            do argv.dispose();
            return null;
        }

        if   (argv.meta() = FUNC) { return Exec.call(argv);             }
        if (~(argv.meta() = CMD)) { return argv;                        }

        let cmd = argv.data();

        if (cmd = TURTLE) { return Exec.newTurtle(argv.next());         }
        if (cmd = DIR)    { return Exec.dir(argv.next());               }
        if (cmd = POSX)   { return Exec.posx(argv.next());              }
        if (cmd = POSY)   { return Exec.posy(argv.next());              }

        if (cmd = ASSIGN)           { do Exec.doAssign(argv.next());    }
        else { if (cmd = CLEAR)     { do Exec.doClear(argv.next());     }
        else { if (cmd = DISPOSE)   { do Exec.doDispose(argv.next());   }
        else { if (cmd = FORWARD)   { do Exec.doForward(argv.next());   }
        else { if (cmd = FUNCTION)  { do Exec.doFunction(argv.next());  }
        else { if (cmd = IF)        { do Exec.doIf(argv.next());        }
        else { if (cmd = PENDOWN)   { do Exec.doPendown(argv.next());   }
        else { if (cmd = PENUP)     { do Exec.doPenup(argv.next());     }
        else { if (cmd = PRINT)     { do Exec.doPrint(argv.next());     }
        else { if (cmd = REPEAT)    { do Exec.doRepeat(argv.next());    }
        else { if (cmd = TURNLEFT)  { do Exec.doTurnleft(argv.next());  }
        else { if (cmd = TURNRIGHT) { do Exec.doTurnright(argv.next()); }
        else { if (cmd = QUIT)      { do Exec.doQuit(argv.next());      }
        }}}}}}}}}}}}

        if (cmd=128) {do DB.mv();}  // ##DB##

        return null;
    }


    function Symbol call(Symbol argv) {
        var int n;
        var Array fargv;
        var String argname, fstr;
        var Symbol arg, ret;

        do Eval.pushScope(3);

        let fargv = Array.new(1);
        let fstr = "$%D";
        let n = 0;

        let arg = argv.next();
        while (~(arg = null)) {
            let n = n + 1;
            let fargv[0] = n;
            let argname = Str.format(fstr, fargv);
            do Eval.arg(arg);
            do Eval.install(argname, arg.meta(), arg.data());
            do argname.dispose();
            let arg = arg.next();
        }

        let ret = Exec.exec(argv.data());

        do Eval.dropScope();
        do fargv.dispose();
        do fstr.dispose();

        return ret;
    }


    function Symbol block(Symbol block) {
        var Symbol cmdlin;

        if (block = null) {
            return null;
        }

        if (block.data() = null) {
            return null;
        }

        let cmdlin = block.data();
        while (~(cmdlin.next() = null)) {
            do Exec.try(cmdlin.data());
            let cmdlin = cmdlin.next();
        }

        return Exec.exec(cmdlin.data());
    }


    function Symbol newTurtle(Symbol argv) {
        var int d, x, y;
        var Symbol p;

        if (argv = null) {
            let p = Symbol.new(null, TTL, Exec.defaultTurtle());
            do turtles.append(Symbol.new(null, TTL, p.data()));
            return p;
        }

        do Eval.arg(argv);
        let x = argv.data() + left;
        let argv = argv.next();

        do Eval.arg(argv);
        let y = argv.data() + top;
        let argv = argv.next();

        do Eval.arg(argv);
        let d = argv.data();

        let p = Symbol.new(null, TTL,
                           Turtle.new(x, y, d, top, left, bottom, right));

        do turtles.append(p); // ##DB##Symbol.new(null, TTL, p.data()));

        do Exec.try(argv.next());

        return p;
    }


    function void doAssign(Symbol arg) {
        var Symbol val;

        let val = Eval.arg(arg.next());
        do Eval.install(arg.tag(), val.meta(), val.data());
        do Exec.try(val.next());

        return;
    }


    function void doClear(Symbol arg) {

        do Exec.clear();
        do Exec.refreshTurtles();
        do Exec.try(arg);

        return;
    }


    function void refreshTurtles() {
        var Symbol tp;
        var Turtle tt;

        let tp = turtles.next();
        while (~(tp = null)) {
            let tt = tp.data();
            do tt.show();
            let tp = tp.next();
        }

        return;
    }


    function Symbol dir(Symbol arg) {
        return Symbol.new(null, INT, t.direction());
    }


    function void doDispose(Symbol arg) {
        var boolean continue;
        var Symbol p;
        var Symbol np, pp, tp;  // next, previous, turtle pointers
        var Turtle tt;

        if (arg = null) {
            /* todo: error */
            return;
        }

        if (turtles.next() = null) {
            /* todo: not sure, analyze this */
            return;
        }

        do Eval.arg(arg);

        if (arg.data() = null) {
            /* todo: error */
            return;
        }

        let tp = null;

        let p = turtles;
        while (~(p = null)) {
            let np = p.next();
            if (~(np = null)) {
                if (np.data() = arg.data()) {
                    let tp = np;
                    let pp = p;
                }
            }
            let p = p.next();
        }

        if (tp = null) {
            /* todo: not sure, analyze this */
            return;
        }

        let np = tp.next();
        do pp.setNext(np);

        let tt = arg.data();
        do tt.dispose();
        do Eval.install(arg.name(), null, null);

        return;
    }


    function void doForward(Symbol arg) {
        var Array target;

        do Eval.arg(arg);

        if (arg.data() < 0) {
            do LibIO.error("won't go backwards");
            return;
        }

        let target = t.aim(arg.data());

        if ( ((target[0] < left) | (target[0] > right))
                | ((target[1] < top) | (target[1] > bottom)) ) {
            do LibIO.error("target beyond boundary");
            return;
        }

        do t.forward(arg.data());

        return;
    }


    function void doFunction(Symbol arg) {

        if (arg = null) {
            do LibIO.error("no function name");
            return;
        }

        do Eval.install(arg.name(), FUNC, LibSym.copyList(arg.next()));

        return;
    }


    function void doIf(Symbol arg) {
        var Symbol elsep;

        let elsep = Exec.elsePointer(arg);

        do Eval.arg(arg);

        if (~(arg.data() = 0)) {
            do Exec.try(arg.next());
        } else { if (~(elsep = null)) {
            do Exec.try(elsep.next());
        }}

        return;
    }


    function Symbol elsePointer(Symbol argv) {
        var int nif;
        var String IFS, ELSES;
        var Symbol argp;

        let IFS = "IF";
        let ELSES = "ELSE";

        let argp = argv.next();
        while (~(argp = null)) {
            if (HashTable.streq(ELSES, argp.name())) {
                if (nif = 0) {
                    do IFS.dispose();
                    do ELSES.dispose();
                    return argp;
                } else {
                    let nif = nif - 1;
                }
            } else { if (HashTable.streq(IFS, argp.name())) {
                let nif = nif + 1;
            }}
            let argp = argp.next();
        }

        do IFS.dispose();
        do ELSES.dispose();

        return null;
    }


    function void doPendown(Symbol arg) {
        do t.pendown();
        return;
    }


    function void doPenup(Symbol arg) {
        do t.penup();
        return;
    }


    function Symbol posx(Symbol arg) {
        return Symbol.new(null, INT, t.x() - ((left+right)/2));
    }


    function Symbol posy(Symbol arg) {
        return Symbol.new(null, INT, -(t.y() - ((top+bottom)/2)));
    }


    function void doPrint(Symbol arg) {

        if (tb.set(t.y()/11, (t.x()/8)+1) = 1) {
            do LibIO.error("illegal cursor coordinate");
            return;
        }

        do Eval.arg(arg);

        if (~(arg.meta() = STR)) {
            do LibIO.error("exec print: expected string");
            return;
        }

        do Exec.hideAll();
        do tb.print(arg.data());
        do Exec.showAll();

        return;
    }


    function void hideAll() {
        var Symbol tp;
        var Turtle tt;

        let tp = turtles;
        while (~(tp = null)) {
            let tt = tp.data();
            do tt.hide();
            let tp = tp.next();
        }

        return;
    }


    function void showAll() {
        var Symbol tp;
        var Turtle tt;

        let tp = turtles;
        while (~(tp = null)) {
            let tt = tp.data();
            do tt.show();
            let tp = tp.next();
        }

        return;
    }


    function void doRepeat(Symbol arg) {
        var int i;
        var Symbol cmdp;

        do Eval.arg(arg);

        if ( (arg.meta()=CMD) & (arg.data()=IF) ) {
            do Exec.doRepeatIf(arg.next());
            return;
        }

        /* todo: type check */

        let i = arg.data();
        while (i > 0) {
            let cmdp = LibSym.copyList(arg.next());
            do Exec.try(cmdp);
            do LibSym.destroyList(cmdp);
            let i = i - 1;
        }

        return;
    }


    function void doRepeatIf(Symbol arg) {
        var int condition;
        var Symbol cmdp, condp;

        let condp = Eval.arg(LibSym.copySym(arg));
        let condition = condp.data();
        do LibSym.destroyList(condp);
        while (~(condition = 0)) {
            let cmdp = LibSym.copyList(arg.next());
            do Exec.try(cmdp);
            do LibSym.destroyList(cmdp);
            let condp = Eval.arg(LibSym.copySym(arg));
            let condition = condp.data();
            do LibSym.destroyList(condp);
        }

        return;
    }


    function void doTurnleft(Symbol arg) {
        do Eval.arg(arg);
        do t.turnleft(arg.data());
        return;
    }


    function void doTurnright(Symbol arg) {
        do Eval.arg(arg);
        do t.turnright(arg.data());
        return;
    }


    /* todo: fix this */
    function Symbol doQuit(Symbol arg) {
        do Main.stop();
        return Symbol.new(null, CMD, QUIT);
    }


    function void enqueue(Symbol sym) {
        var Array a;
        var String s;
        var Collection list;
        var Symbol p;

        if (sym = null) {
            return;
        }

        let a = Array.new(1);
        if (sym.meta() = STR) {
            let s = "'%S'";
            let a[0] = sym.data();
            do LibIO.put(Str.format(s, a));
            do s.dispose();
        } else { if (sym.meta() = INT) {
            let s = String.new(6);
            do s.setInt(sym.data());
            do LibIO.put(s);
        } else { if (sym.meta() = LIST) {
            let list = sym.data();
            do LibIO.put("[");
            while (list.length() > 0) {
                let p = Eval.arg(list.pop());
                if (p.meta() = INT) {
                    let s = " %D";
                    let a[0] = p.data();
                    do LibIO.put(Str.format(s, a));
                    do s.dispose();
                } else { if (p.meta() = STR) {
                    let s = " '%S'";
                    let a[0] = p.data();
                    do LibIO.put(Str.format(s, a));
                    do s.dispose();
                } else { if (p.meta() = LIST) {
                    do Exec.enqueue(p.data());
                }}}
            }
            do LibIO.put("]");
            do s.dispose();
        }}}
        do a.dispose();

        do Exec.try(sym.next());

        return;
    }


    function void fixBorders() {
        do Screen.setColor(false);
        do Screen.drawRectangle(249, 14, 511, 19);
        do Screen.drawRectangle(249, 14, 253, 244);
        do Screen.drawRectangle(249, 244, 511, 248);
        do Screen.drawRectangle(505, 14, 511, 248);
        return;
    }

}
