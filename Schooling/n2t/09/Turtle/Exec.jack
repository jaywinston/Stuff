class Exec {

    static int BLOCK, CMD, CMDLIN, FUNC, INT, LIST, STR;
    static int ASSIGN, FUNCTION, IF, REPEAT, QUIT;
    static String IFS, ELSES;


    function void init() {
        let IFS = "IF";
        let ELSES = "ELSE";
        do Exec.initKWs();
        return;
    }


    function void kill() {
        do IFS.dispose();
        do ELSES.dispose();
        return;
    }


    function void initKWs() {

        let BLOCK = LibSym.BLOCK();
        let CMD = LibSym.CMD();
        let CMDLIN = LibSym.CMDLIN();
        let FUNC = LibSym.FUNC();
        let INT = LibSym.INT();
        let LIST = LibSym.LIST();
        let STR = LibSym.STR();

        let ASSIGN   = 1;
        let FUNCTION = 2;
        let IF       = 3;
        let REPEAT   = 4;
        let QUIT     = 5;

        do Eval.install("MV", CMD,128);  // ##DB##

        do Eval.install("ASSIGN", CMD, ASSIGN);
        do Eval.install("FUNCTION", CMD, FUNCTION);
        do Eval.install("IF", CMD, IF);
        do Eval.install("REPEAT", CMD, REPEAT);
        do Eval.install("QUIT", CMD, QUIT);

        return;
    }


    function Symbol cmdlin(Collection argv) {
        var int cmd;
        var Symbol arg, ret;

        let arg = argv.pop();

        if (arg = null) {
            do argv.dispose();
            return null;
        }

        if (arg.meta() = BLOCK)  {
            let ret = Exec.block(arg.data());
            do arg.dispose();
        }

        if (arg.meta() = CMDLIN) { return Exec.cmdlin(arg.data()); }

        do Eval.arg(arg);

        if   (arg.meta() = FUNC) { return Exec.call(argv);             }
        if (~(arg.meta() = CMD)) { return argv;                        }

        let cmd = argv.data();

        if (cmd = ASSIGN)           { do Exec.doAssign(argv.next());    }
        else { if (cmd = FUNCTION)  { do Exec.doFunction(argv.next());  }
        else { if (cmd = IF)        { do Exec.doIf(argv.next());        }
        else { if (cmd = REPEAT)    { do Exec.doRepeat(argv.next());    }
        else { if (cmd = QUIT)      { do Exec.doQuit(argv.next());      }
        }}}}

        if (cmd=128) {do DB.mv();}  // ##DB##

        return null;
    }


    function Symbol call(Symbol argv) {
        var int n;
        var Array fargv;
        var String argname, fstr;
        var Symbol arg, ret;

        do Eval.pushScope(3);

        let fargv = Array.new(1);
        let fstr = "$%D";
        let n = 0;

        let arg = argv.next();
        while (~(arg = null)) {
            let n = n + 1;
            let fargv[0] = n;
            let argname = Str.format(fstr, fargv);
            do Eval.arg(arg);
            do Eval.install(argname, arg.meta(), arg.data());
            do argname.dispose();
            let arg = arg.next();
        }

        let ret = Exec.cmdlin(argv.data());

        do Eval.dropScope();
        do fargv.dispose();
        do fstr.dispose();

        return ret;
    }


    function Symbol block(Symbol block) {
        var Symbol cmdlin;

        if (block = null) {
            return null;
        }

        if (block.data() = null) {
            return null;
        }

        let cmdlin = block.data();
        while (~(cmdlin.next() = null)) {
            do Exec.cmdlin(cmdlin.data());
            let cmdlin = cmdlin.next();
        }

        return Exec.cmdlin(cmdlin.data());
    }


    function void doAssign(Symbol arg) {
        var Symbol val;

        let val = Eval.arg(arg.next());
        do Eval.install(arg.tag(), val.meta(), val.data());
        do Exec.cmdlin(val.next());

        return;
    }


    function void doFunction(Symbol arg) {

        if (arg = null) {
            do LibIO.error("no function name");
            return;
        }

        do Eval.install(arg.name(), FUNC, LibSym.copyList(arg.next()));

        return;
    }


    function void doIf(Symbol arg) {
        var Symbol elsep;

        let elsep = Exec.elsePointer(arg);

        do Eval.arg(arg);

        if (~(arg.data() = 0)) {
            do Exec.cmdlin(arg.next());
        } else { if (~(elsep = null)) {
            do Exec.cmdlin(elsep.next());
        }}

        return;
    }


    function Symbol elsePointer(Symbol argv) {
        var int nif;
        var Symbol argp;

        let argp = argv.next();
        while (~(argp = null)) {
            if (Str.eq(ELSES, argp.name())) {
                if (nif = 0) {
                    return argp;
                } else {
                    let nif = nif - 1;
                }
            } else { if (Str.eq(IFS, argp.name())) {
                let nif = nif + 1;
            }}
            let argp = argp.next();
        }

        return null;
    }


    function void doRepeat(Symbol arg) {
        var int i;
        var Symbol cmdp;

        do Eval.arg(arg);

        if ( (arg.meta()=CMD) & (arg.data()=IF) ) {
            do Exec.doRepeatIf(arg.next());
            return;
        }

        /* todo: type check */

        let i = arg.data();
        while (i > 0) {
            let cmdp = LibSym.copyList(arg.next());
            do Exec.cmdlin(cmdp);
            do LibSym.destroyList(cmdp);
            let i = i - 1;
        }

        return;
    }


    function void doRepeatIf(Symbol arg) {
        var int condition;
        var Symbol cmdp, condp;

        let condp = Eval.arg(LibSym.copySym(arg));
        let condition = condp.data();
        do LibSym.destroyList(condp);
        while (~(condition = 0)) {
            let cmdp = LibSym.copyList(arg.next());
            do Exec.cmdlin(cmdp);
            do LibSym.destroyList(cmdp);
            let condp = Eval.arg(LibSym.copySym(arg));
            let condition = condp.data();
            do LibSym.destroyList(condp);
        }

        return;
    }


    /* todo: fix this */
    function Symbol doQuit(Symbol arg) {
        do Main.stop();
        return Symbol.new(null, CMD, QUIT);
    }


    function int QUIT() {
        return QUIT;
    }

}
