class Eval {

    static int BLOCK, CMD, CMDLIN, END, EXPR, FUNC, INT, STR, SYM;
    static String PS1, PS2;
    static String ASGNDLMS, EXPDLMS;
    static String BLANKS, EQS, BRACES, PERCENTS;


    function void init() {

        let BLOCK = Symbol.BLOCK();
        let CMD = Symbol.CMD();
        let CMDLIN = Symbol.CMDLIN();
        let END = Symbol.END();
        let EXPR = Symbol.EXPR();
        let FUNC = Symbol.FUNC();
        let INT = Symbol.INT();
        let STR = Symbol.STR();
        let SYM = Symbol.SYM();

        let ASGNDLMS = String.new(3);
        do ASGNDLMS.append(34);   // '"'
        do ASGNDLMS.append(61);   // '='
        do ASGNDLMS.append(123);  // '{'

        let PS1 = ">";
        let PS2 = "|";

        let EXPDLMS = "=~!<>&|+-*/%";
        let BLANKS = " ";
        let EQS = "=";
        let BRACES = "{}";
        let PERCENTS = "%";

        return;
    }


    /* read and evaluate next command line */
    function Symbol next() {
        return Eval.eval(IOBox.read(PS1), 0);
    }


    /* parse s from index i */
    function Symbol eval(String s, int i) {
        var String t;
        var Symbol argv;

        if (i > s.length()) {
            return null;
        }

        let i = Str.lskip(s, 32, i);

        if (i = s.length()) {
            return null;
        }

        let t = String.new(s.length());
        let i = Lex.word(s, t, i);

        if (Error.isSet()) {
            do t.dispose();
            return null;
        }

        if (Eval.isAssign(t)) {
            let argv = Eval.assign(t);
        } else {
            let argv = Eval.expression(t);
        }

        do t.dispose();

        do argv.append(Eval.eval(s, i+1));

        if (Error.isSet()) {
            do Symbol.clear(argv);
            return null;
        }

        return argv;
    }

    function boolean isAssign(String s) {
        var int i;

        let i = Str.index(s, ASGNDLMS, 0);

        if (i < s.length()) {
            if (s.charAt(i) = 61) {
                if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                    return false;
                }} else { if (i > 0) {
                        if (  (s.charAt(i-1) = 33)
                           | ((s.charAt(i-1) = 60)
                           |  (s.charAt(i-1) = 62))
                           ) {
                    return false;
                }}}
                return true;
            }
        }

        return false;
    }

    function Symbol assign(String s) {
        var int i;
        var String name;
        var Symbol value;

        if (s.charAt(0) = 61) {
            do Error.send("expected name");  // ##DB##
            do Error.set(1);  // expected name
            return null;
        }

        let name = String.new(s.length());
        let i =  Str.tkn(s, name, EQS, 0);
        let value = Symbol.new("=", CMD, null);
        do value.append(Symbol.new(name, SYM, null));
        do value.append(Eval.eval(s, i+1));

        if (Error.isSet()) {
            do name.dispose();
            do Symbol.clear(value);
            return null;
        }

        if (value.type() = STR) {
            do Exec.install(name, value.type(), Str.dup(value.value()));
        } else {
            do Exec.install(name, value.type(), value.value());
        }

        do name.dispose();
        do Symbol.clear(value);

        return value;
    }


    function Symbol expression(String s) {
        var char c;

        let c = s.charAt(0);

        if (c = 34) {
            return Symbol.new(s, STR, Eval.StringExpr(s));
        }

        if (c = 123) {
            return Eval.blockExpr(s);
        }

        if ( (Str.index(s, EXPDLMS, 0) = s.length()) & ~((c>47) & (c<58)) ) {
            return Symbol.new(s, SYM, null);
        }

        return Symbol.new(s, INT, 0);  // s is evaluated at execution
    }


    /* todo: use Str.format(), no destruct, symbol param */
    function String StringExpr(String s) {
        do s.eraseLastChar();
        do Str.shift(s, 1, 0);
        return Str.dup(Eval.format(s));
    }


    function String format(String s) {
        var int i;

        let i = 0;

        while (i < s.length()) {

            let i = Str.index(s, PERCENTS, i);

            if ((i+1) < s.length()) {
                if (s.charAt(i+1) = 81) {
                    do s.setCharAt(i, 34);
                } else { if (s.charAt(i+1) = 80) {
                    do s.setCharAt(i, 37);
                } else { if (s.charAt(i+1) = 78) {
                    do s.setCharAt(i, 128);
                } else {
                    do Error.send("unrecognized format specifier");  // ##DB##
                    do Error.set(1);
                    do t.dispose();
                    return null;
                }}}

                let i = i + 1;
                do Str.shift(s, 1, i);

            }  // todo: error no fspec
        }

        return s;
    }


    function Symbol blockExpr(String s) {
        var int i, n;
        var Symbol block, end, line;

        let line = Eval.blockLine(s, 1);
        let end = Eval.eval(line.value(), 0);

        if (~(end = null)) { if (end.type() = END) {
            do line.dispose();  // end is prepended with line.next
            return Eval.toSuperBlock(end);  // destroys end
        }}

        let block = Symbol.new(null, CMDLIN, end);

        while (~(line.type() = END)) {
            do line.dispose();
            let line = Eval.blockLine(IOBox.read(PS2), 0);
            let end = Eval.eval(line.value(), 0);
            if (~(end = null)) {
                do block.append(Symbol.new(null, CMDLIN, end));
            }
        }

        if (block.value() = null) {
            let end = block;
            let block = block.next();
            do end.dispose();
        }

        do line.append(Symbol.new(null, BLOCK, block));
        let block = line.next();
        do line.dispose();

        if (block.type() = EXPR) {
            do Eval.blockToExpr(block);
        }

        return block;
    }


    /* return a list of strings representing block endings */
    function Symbol blockLine(String s, int i) {
        var String t;
        var Symbol line,p;

        /* look for end of block */
        let t = String.new(s.length());
        let i = Eval.blockTkn(s, t, i);

        if (i < s.length()) {
            let line = Symbol.new(null, END, t);
        } else {
            let line = Symbol.new(null, STR, t);
        }

        if ( (i+1) < s.length() ) {

            /* If this block is in an expression,
               append the rest of the expression. */
            let t = String.new(s.length());
            let i = Eval.blockTkn(s, t, i+1);

            if (i < s.length()) {
                do line.append(Symbol.new(null, END, t));
            } else {
                do line.append(Symbol.new(null, EXPR, t));
            }

            /* append any ends of super blocks */
            while ( (i+1) < s.length() ) {
                let t = String.new(s.length());
                let i = Eval.blockTkn(s, t, i+1);
                do line.append(Symbol.new(null, END, t));
            }
        }

        return line;
    }


    function int blockTkn(String s, String t, int i) {

        if (~(i < s.length())) {
            return i;
        }

        while (i < s.length()) {
            let i = Str.tkn(s, t, BRACES, i);

            if (i < s.length()) {
                if (s.charAt(i) = 125) {
                    return i;
                }
                if (s.charAt(i) = 123) {
                    let i = Lex.block(s, t, 123, 125, i);
                }
            }
        }

        return i;
    }


    function Symbol toSuperBlock(Symbol end) {
        var String s, t;
        var Symbol block, super;

        /* make block a sub-block of the super-block */
        let block = end;
        while (~(block.next() = null)) {  // the last node holds the block
            let block = block.next();
        }

        let super = end;
        while (~(super.next() = block)) {
            let super = super.next();
        }

        do super.setNext(Symbol.new(null, BLOCK, block));

        /* if this block is an expression, evaluate the expression */
        let s = end.value();

        if (s.length() > 0) {
            let s = String.new(Str.MAXLEN());
            let t = Eval.blockToStr(block);
            do Str.cat(s, t);
            do t.dispose();
            do Str.cat(s, end.value());
            do end.append(Eval.eval(s, 0));
            do s.dispose();
        }

        let block = end.next();
        do end.dispose();

        return block;
    }


    function String blockToStr(Symbol block) {
        var int n;
        var String s;
        var Symbol expr;

        let expr = Exec.execBlock(block);

        if (expr = null) {
            return "";
        }

        if (expr.type() = STR) {
            let s = Str.dup(expr.value());
        } else {
            let s = String.new(6);
            do s.setInt(expr.value());
        }

        do expr.dispose();

        return s;
    }


    /* evaluate block's execution, represent value as a String,
     * concatenate continuation of expression, overwite block
     * with expression's evaluation
     */
    function Symbol blockToExpr(Symbol block) {
        var String expr, term;
        var Symbol p1, p2;

        /* get block */
        let p1 = block;
        while (~(p1.next() = null)) {
            let p1 = p1.next();
        }

        let expr = String.new(Str.MAXLEN());
        let term = Eval.blockToStr(p1);

        /* get block's parent, dispose block */
        let p2 = block;
        while (~(p2.next() = p1)) {
            let p2 = p2.next();
        }
        do p1.dispose();

        do Str.cat(expr, term);
        do term.dispose();
        do Str.cat(expr, block.value());

        /* overwrite block */
        do p2.setNext(Eval.eval(expr, 0));

        do expr.dispose();

        let p1 = block;
        let block = block.next();
        do p1.dispose();

        return block;
    }

    function Symbol symbolExpr(String s) {
        var Symbol p;

        let p = Exec.lookup(s);

        if (p = null) {
            return Symbol.new(s, SYM, null);
        }

        return Symbol.copy1(p);
    }


    function void install(String name, int type, int value) {
        do Exec.install(name, type, value);
        return;
    }


    function void delete(String name) {
        do symtab.delete(name);
        return;
    }

}
