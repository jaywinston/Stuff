class Eval {

    static int BLOCK, CMD, CMDLIN, END, EXPR, FUNC, INT, STR, SYM;
    static int TERM;
    static Array INTOPS;
    static String PS1, PS2;
    static String ASGNDLMS, EXPDLMS;
    static String EQS, BRACES, PERCENTS;
    static SymbolTable symtab;


    function void init() {

        let BLOCK = Symbol.BLOCK();
        let CMD = Symbol.CMD();
        let CMDLIN = Symbol.CMDLIN();
        let END = Symbol.END();
        let EXPR = Symbol.EXPR();
        let FUNC = Symbol.FUNC();
        let INT = Symbol.INT();
        let STR = Symbol.STR();
        let SYM = Symbol.SYM();

        let TERM = 4;
        let INTOPS = Array.new(4);
        let INTOPS[0] = "&|({";
        let INTOPS[1] = "=!<>({";
        let INTOPS[2] = "+-({";
        let INTOPS[3] = "*/%({";

        let ASGNDLMS = String.new(3);
        do ASGNDLMS.appendChar(34);   // '"'
        do ASGNDLMS.appendChar(61);   // '='
        do ASGNDLMS.appendChar(123);  // '{'

        let PS1 = ">";
        let PS2 = "|";

        let EXPDLMS = "=~!<>&|+-*/%";
        let EQS = "=";
        let BRACES = "{}";
        let PERCENTS = "%";

        let symtab = SymbolTable.new(15);

        return;
    }


    /* read and evaluate next command line */
    function Symbol next() {
        return Eval.eval(IOBox.read(PS1), 0);
    }


    /* parse s from index i */
    function Symbol eval(String s, int i) {
        var String t;
        var Symbol argv;

        if (i > s.length()) {
            return null;
        }

        let i = Str.lskip(s, 32, i);

        if (i = s.length()) {
            return null;
        }

        let t = String.new(s.length());
        let i = Lex.word(s, t, i);

        if (Error.isSet()) {
            do t.dispose();
            return null;
        }

        if (Eval.isAssign(t)) {
            do Eval.assign(t);
            let argv = Eval.eval(s, i+1);
        } else {
            let argv = Eval.expression(t);
        }

        do t.dispose();

        do argv.append(Eval.eval(s, i+1));

        if (Error.isSet()) {
            do Symbol.clear(argv);
            return null;
        }

        return argv;
    }

    function boolean isAssign(String s) {
        var int i;

        let i = Str.index(s, ASGNDLMS, 0);

        if (i < s.length()) {
            if (s.charAt(i) = 61) {
                if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                    return false;
                }} else { if (i > 0) {
                        if (  (s.charAt(i-1) = 33)
                           | ((s.charAt(i-1) = 60)
                           |  (s.charAt(i-1) = 62))
                           ) {
                    return false;
                }}}
                return true;
            }
        }

        return false;
    }


    function void assign(String s) {
        var int i;
        var String name;
        var Symbol value;

        if (s.charAt(0) = 61) {
            do Error.send("expected name");  // ##DB##
            do Error.set(1);  // expected name
            return;
        }

        let name = String.new(s.length());
        let i =  Str.tkn(s, name, EQS, 0);
        let value = Eval.arg(Eval.eval(s, i+1));

        if (Error.isSet()) {
            do name.dispose();
            do Symbol.clear(value);
            return;
        }

        if (value = null) {
            do symtab.install(name, SYM, null);
            return;
        }

        if (value.type() = STR) {
            do symtab.install(name, value.type(), Str.dup(value.value()));
        } else {
            do symtab.install(name, value.type(), value.value());
        }

        do name.dispose();
        do Symbol.clear(value);

        return;
    }


    function Symbol expression(String s) {
        var char c;

        let c = s.charAt(0);

        if (c = 34) {
            return Symbol.new(s, STR, Eval.StringExpr(s));
        }

        if (c = 123) {
            return Eval.blockExpr(s);
        }

        if ( (Str.index(s, EXPDLMS, 0) = s.length()) & ~((c>47) & (c<58)) ) {
            return Symbol.new(s, SYM, null);
        }

        return Symbol.new(s, INT, 0);  // s is evaluated at execution
    }


    /* todo: use Str.format(), no destruct, symbol param */
    function String StringExpr(String s) {
        do s.eraseLastChar();
        do Str.shift(s, 1, 0);
        return Str.dup(Eval.format(s));
    }


    function String format(String s) {
        var int i;

        let i = 0;

        while (i < s.length()) {

            let i = Str.index(s, PERCENTS, i);

            if ((i+1) < s.length()) {
                if (s.charAt(i+1) = 81) {
                    do s.setCharAt(i, 34);
                } else { if (s.charAt(i+1) = 80) {
                    do s.setCharAt(i, 37);
                } else { if (s.charAt(i+1) = 78) {
                    do s.setCharAt(i, 128);
                } else {
                    do Error.send("unrecognized format specifier");  // ##DB##
                    do Error.set(1);
                    do t.dispose();
                    return null;
                }}}

                let i = i + 1;
                do Str.shift(s, 1, i);

            }  // todo: error no fspec
        }

        return s;
    }


    function Symbol blockExpr(String s) {
        var int i, n;
        var Symbol block, end, line;

        let line = Eval.blockLine(s, 1);
        let end = Eval.eval(line.value(), 0);

        if (~(end = null)) { if (end.type() = END) {
            do line.dispose();  // end is prepended with line.next
            return Eval.toSuperBlock(end);  // destroys end
        }}

        let block = Symbol.new(null, CMDLIN, end);

        while (~(line.type() = END)) {
            do line.dispose();
            let line = Eval.blockLine(IOBox.read(PS2), 0);
            let end = Eval.eval(line.value(), 0);
            if (~(end = null)) {
                do block.append(Symbol.new(null, CMDLIN, end));
            }
        }

        if (block.value() = null) {
            let end = block;
            let block = block.next();
            do end.dispose();
        }

        do line.append(Symbol.new(null, BLOCK, block));
        let block = line.next();
        do line.dispose();

        if (block.type() = EXPR) {
            do Eval.blockToExpr(block);
        }

        return block;
    }


    /* return a list of strings representing block endings */
    function Symbol blockLine(String s, int i) {
        var String t;
        var Symbol line;

        if (~(i < s.length())) {
            return null;
        }

        /* look for end of block */
        let t = String.new(s.length());
        let i = Lex.block(s, t, i);

        if (i < s.length()) {
            let line = Symbol.new(null, END, t);
        } else {
            let line = Symbol.new(null, STR, t);
        }

        if ( (i+1) < s.length() ) {

            let t = String.new(s.length());
            let i = Lex.block(s, t, i+1);

            /* append any ends of super blocks */
            while ( (i+1) < s.length() ) {
                let t = String.new(s.length());
                let i = Lex.block(s, t, i+1);
                if (i < s.length()) {
                    do line.append(Symbol.new(null, END, t));
                } else {
                    /* If this block is in an expression,
                       append the rest of the expression. */
                    do line.append(Symbol.new(null, EXPR, t));
                }
            }
        }

        return line;
    }


    function Symbol toSuperBlock(Symbol end) {
        var String s, t;
        var Symbol block, super;

        /* make block a sub-block of the super-block */
        let block = end;
        while (~(block.next() = null)) {  // the last node holds the block
            let block = block.next();
        }

        let super = end;
        while (~(super.next() = block)) {
            let super = super.next();
        }

        do super.setNext(Symbol.new(null, BLOCK, block));

        /* if this block is an expression, evaluate the expression */
        let s = end.value();

        if (s.length() > 0) {
            let s = String.new(Str.MAXLEN());
            let t = Eval.blockToStr(super.next());  // detroys argument
            do Str.cat(s, t);
            do t.dispose();
            do Str.cat(s, end.value());
            do super.setNext(Eval.eval(s, 0));
            do s.dispose();
        }

        let block = end.next();
        do end.dispose();

        return block;
    }


    function String blockToStr(Symbol block) {
        var int n;
        var String s;
        var Symbol expr;

        let expr = Exec.execBlock(block);

        if (expr = null) {
            return "";
        }

        if (expr.type() = STR) {
            let s = Str.dup(expr.value());
        } else {
            let s = String.new(6);
            do s.setInt(expr.value());
        }

        do expr.dispose();

        return s;
    }


    /* evaluate block's execution, represent value as a String,
     * concatenate continuation of expression, overwite block
     * with expression's evaluation
     */
    function Symbol blockToExpr(Symbol block) {
        var String expr, term;
        var Symbol p1, p2;

        /* get block */
        let p1 = block;
        while (~(p1.next() = null)) {
            let p1 = p1.next();
        }

        let expr = String.new(Str.MAXLEN());
        let term = Eval.blockToStr(p1);

        /* get block's parent, dispose block */
        let p2 = block;
        while (~(p2.next() = p1)) {
            let p2 = p2.next();
        }
        do p1.dispose();

        do Str.cat(expr, term);
        do term.dispose();
        do Str.cat(expr, block.value());

        /* overwrite block */
        do p2.setNext(Eval.eval(expr, 0));

        do expr.dispose();

        let p1 = block;
        let block = block.next();
        do p1.dispose();

        return block;
    }


    function void install(String name, int type, int value) {
        do symtab.install(name, type, value);
        return;
    }


    function void pushScope(int hsize) {
        do symtab.pushScope(hsize);
        return;
    }


    function void dropScope() {
        do symtab.dropScope();
        return;
    }


    function Symbol arg(Symbol arg) {
        var int type;
        var Symbol p;

        if (arg = null) {
            return null;
        }

        let type = arg.type();
        let p = null;

        if (type = BLOCK) {
            let p = Exec.execBlock(arg.value());
            do Symbol.clear(arg.value());
        } else { if (type = SYM) {
            let p = symtab.lookup(arg.name());
            if (p = null) {
                do Error.send("undefined symbol");  // ##DB##
                do Error.set(1);  // undefined symbol
                return null;
            }
        } else { if (type = INT) {
            do arg.setValue(Eval.integer(arg.name(), 0, 0));
        } else {
            return arg;
        }}}

        if (~(p = null)) {
            if ( (p.type()=BLOCK) | (p.type()=FUNC) ) {
                do arg.setValue(Symbol.copy(p.value()));
            } else { if (p.type() = STR) {
                do arg.setValue(Str.dup(p.value()));
            } else {
                do arg.setValue(p.value());
            }}

            do arg.setType(p.type());
            if (type = BLOCK) {
                do p.dispose();
            }
        }

        return arg;
    }


    function int integer(String s, int i, int depth) {
        var char op;
        var int n;
        var String t;

        if (i = s.length()) {
            do Error.send("expected integer expression");  // ##DB##
            do Error.set(1);  //  expected integer expression
            return 0;
        }
            
        if (depth = TERM) {
            return Eval.term(s);
        }

        let t = String.new(s.length());
        let i = Lex.integer(s, t, INTOPS[depth], i);

        if (Error.isSet()) {
            do t.dispose();
            return 0;
        }

        let n = Eval.integer(t, 0, depth+1);

        do t.dispose();

        if (i < s.length()) {

            let op = s.charAt(i);

            if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                let op = op + 200;
                let i = i + 1;
            }}

            let n = Eval.operate(n, Eval.integer(s, i+1, depth), op);
        }

        return n;
    }


    function int term(String s) {
        var char c;
        var Symbol p;

        let c = s.charAt(0);

        if (c = 45) {
            do Str.shift(s, 1, 0);
            return -Eval.term(s);
        }

        if (c = 126) {
            do Str.shift(s, 1, 0);
            return ~Eval.term(s);
        }

        if ( (c>47) & (c<58) ) {
            return s.intValue();
        }

        if (c = 40) {
            return Eval.parenTerm(s);
        }

        if (c = 123) {
            return Eval.blockTerm(s);
        }

        return Eval.symbolTerm(s);

    }


    function int parenTerm(String s) {

        do s.eraseLastChar();
        do Str.shift(s, 1, 0);

        return Eval.integer(s, 0, 0);
    }


    function int blockTerm(String s) {
        var int n;
        var Symbol value;
        var Symbol block;

        let block = Eval.blockExpr(s);
        let value = Exec.execBlock(block);
        do Symbol.clear(block);

        if (value = null) {
            do Error.send("invalid integer");  // ##DB##
            do Error.set(1);  // invalid integer
            return 0;
        }

        if (~(value.type() = INT)) {
            do Error.send("expected integer");  // ##DB##
            do Error.set(1);  // expected integer
            return 0;
        }

        let n = value.value();

        do Symbol.clear(value);

        return n;
    }


    function int symbolTerm(String s) {
        var Symbol p;

        let p = symtab.lookup(s);

        if (p = null) {
            do Error.send("undefined symbol");  // ##DB##
            do Error.set(1);  // undefined symbol
            return 0;
        }

        if (~(p.type() = INT)) {
            do Error.send("wrong type; expected integer");  // ##DB##
            do Error.set(1);  // wrong type; expected integer
            return 0;
        }

        return p.value();
    }


    function int operate(int m, int n, char op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do Error.send("division by zero");  // ##DB##
            do Error.set(1);  // division by zero
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Lib.mod(m, n); }

        if (op = 261) { return   m = n;  }
        if (op = 233) { return ~(m = n); }
        if (op =  60) { return   m < n;  }
        if (op =  62) { return   m > n;  }
        if (op = 260) { return  (m<n) | (m=n); }
        if (op = 262) { return  (m>n) | (m=n); }

        do Error.send("unrecognized operator");  // ##DB##
        do Error.set(1);  // unrecognized operator
        return 0;
    }


}
