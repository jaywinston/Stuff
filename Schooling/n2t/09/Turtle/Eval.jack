// Site use of the meta namespace is bit[0..2] to classify unary operator.

class Eval {

    static int BLOCK, FUNC, INT, INTEX, OP, STR, STREX, SYM, UOP;
    static Array FSPECTAB, TYPETAB;
    static Array FERRARGV;
    static String FERRFS;
    static Collection scope;
    static HashTable symtab;


    function void init() {
        let BLOCK = LibSym.BLOCK();
        let FUNC = LibSym.FUNC();
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let OP = LibSym.OP();
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();
        let FSPECTAB = Eval.fspectab();
        let TYPETAB = Eval.typetab();
        let FERRFS = "expected %S argument";
        let FERRARGV = Array.new(1);
        let scope = Collection.new();
        let symtab = HashTable.new(15);
        return;
    }


    function Array fspectab() {
        var int i;
        var Array fspectab;

        let fspectab = Array.new(3);  /* magic number! */
        let i = 0;

        let fspectab[i] = LibIO.escseq(68, INT);
        let i = i + 1;

        let fspectab[i] = LibIO.escseq(83, STR);
        let i = i + 1;

        let fspectab[i] = null;

        return fspectab;
    }


    function Array typetab() {
        var int i;
        var Array typetab;

        let typetab = Array.new(3);  /* magic number! */
        let i = 0;

        let typetab[i] = LibIO.escseq(INT, "integer");
        let i = i + 1;

        let typetab[i] = LibIO.escseq(STR, "string");
        let i = i + 1;

        let typetab[i] = null;

        return typetab;
    }


    function int integer(Collection queue) {
        var int lo, ro;  /* left operand, right operand */
        var int n;
        var Collection stack;
        var Symbol p1, p2, p3;

        let stack = Collection.new();

        while (queue.length() > 0) {

            let p1 = queue.pop();

            if (p1.meta() = UOP) {
                do stack.push(Eval.uoperate(stack.pop(), p1.data()));
            } else { if (p1.meta() = OP) {
                let ro = stack.pop();
                let lo = stack.pop();
                do stack.push(Eval.operate(lo, ro, p1.data()));
            } else {
                do Eval.arg(p1);
                if (~(p1.meta() = INT)) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(stack);
                    do LibSym.destroySym(p1);
                    return 0;
                }
                do stack.push(p1.data());
            }}

            do p1.dispose();
        }

        let n = stack.pop();

        if (stack.length() > 0) {
            do LibIO.error("expected operator");
        }

        do stack.dispose();
        do queue.dispose();

        return n;
    }


    function String string(Collection argv) {
        var boolean fspec;
        var char c;
        var int a, i;
        var int type;
        var Array fargv;
        var String s, t;
        var Symbol arg;

        let arg = Eval.arg(argv.pop());

        if (~(arg.meta() = STR)) {
            do LibIO.error("expected format string");
            do LibSym.destroySym(arg);
            return "";
        }

        let s = arg.data();
        do arg.dispose();

        if (s.length() < 2) {
            return s;
        }

        let fargv = Array.new(s.length()/2);
        let fspec = false;
        let a = 0;
        let i = 0;
        while (i < s.length()) {
            let c = s.charAt(i);
            if (fspec) {
                let arg = Eval.arg(argv.nth(a));
                if (arg = null) {
                    do LibIO.error("expected format argument");
                    do LibSym.destroyList(argv);
                    do s.dispose();
                    return "";
                }
                let type = Lex.escape(c, FSPECTAB);
                if (~(arg.meta() = type)) {
                    let FERRARGV[0] = Lex.escape(type, TYPETAB);
                    do LibIO.error(Str.format(FERRFS, FERRARGV));
                    do LibSym.destroyList(argv);
                    do LibSym.destroySym(arg);
                    do s.dispose();
                    return "";
                }
                let fargv[a] = arg.data();
                let a = a + 1;
                let fspec = false;
            } else { if (c = 37) {  /* magic number! interpreter esc char */
                let fspec = true;
            }}
            let i = i + 1;
        }

        if (fspec) {
            do LibIO.error("expected format specifier");
            let t = "";
        } else {
            let t = Str.format(s, argv);
        }

        do LibSym.destroyList(argv);
        do fargv.dispose();
        do s.dispose();

        return t;
    }


    function void intex(Symbol intex) {
        do intex.setData(Eval.integer(intex.data()));
        do intex.setMeta(INT);
        return;
    }


    function void strex(Symbol strex) {
        do strex.setData(Eval.string(strex.data()));
        do strex.setMeta(STR);
        return;
    }


    function void sym(Symbol sym) {
        var Symbol p;

        let p = Eval.lookup(sym.tag());

        if (p = null) {
            do LibIO.error("undefined symbol");
            return;
        }

        if (p.meta() = STR) {
            do sym.setData(Str.dup(p.data()));
        } else { if (p.meta() = FUNC) {
            do sym.setData(LibSym.copyList(p.data()));
        } else {
            do sym.setData(p.data());
        }}

        do sym.setMeta(p.meta());

        return;
    }


    function void block(Symbol block) {
        var Symbol ret;

        let ret = Exec.block(block.data());
        do LibSym.destroyList(block.data());

        if (ret = null) {
            do block.setData(null);
            do block.setMeta(null);
            return;
        }

        if (ret.meta() = STR) {
            do block.setData(Str.dup(ret.data()));
        } else {
            do block.setData(ret.data());
        }

        do block.setMeta(ret.meta());

        do LibSym.destroySym(ret);

        return;
    }


    function int condition(Symbol arg) {
        var int c;
        var Symbol cp;

        let cp = Eval.arg(LibSym.copySym(arg));
        if (cp = null) {
            /* todo: error? */
            return 0;
        }
        let c = cp.data();
        do LibSym.destroySym(cp);

        return c;
    }


    function Symbol arg(Symbol arg) {

        if (arg = null) {
            return null;
        }

        if (arg.meta() = SYM) {
            do Eval.sym(arg);
        } else { if (arg.meta() = INTEX) {
            do Eval.intex(arg);
        } else { if (arg.meta() = STREX) {
            do Eval.strex(arg);
        } else { if (arg.meta() = BLOCK) {
            do Eval.block(arg);
        }}}}

        return arg;
    }


    function int uoperate(int n, int op) {

        if (op =  43) { return Math.abs(n); }
        if (op =  45) { return -n;          }
        if (op = 126) { return ~n;          }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function int operate(int m, int n, int op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do LibIO.error("division by zero");
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }
        if (op =  94) { return (m|n) & ~(m&n); }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Vector.mod(m, n); }

        if (op = 6161) { return   m = n;  }
        if (op = 3361) { return ~(m = n); }
        if (op =   60) { return   m < n;  }
        if (op =   62) { return   m > n;  }
        if (op = 6061) { return  (m<n) | (m=n); }
        if (op = 6261) { return  (m>n) | (m=n); }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function void pushContext(Collection argv) {
        do context.push(argv);
        return;
    }


    function void dropContext() {
        do LibSym.destroyList(context.pop());
        return;
    }


    function Symbol lookup(String s) {
        //var int i;
        //var HashTable table;
        //var Symbol sym;

        if (Eval.isArg(s)) {
            return Eval.lookupArg(s);
        }

        return symtab.lookup(s);
/*
        let i = 0;
        while (i < symtab.length()) {
            let table = symtab.nth(i);
            let sym = table.lookup(s);
            if (~(sym = null)) {
                return sym;
            }
            let i = i + 1;
        }

        return null;
*/
    }


    function boolean isArg(String s) {
        var char c;
        var int i;

        if (s.length() < 2) {
            return false;
        }

        if (~(s.charAt(0) = 36)) {
            return false;
        }

        let i = 1;
        while (i < s.length()) {
            let c = s.charAt(i);
            if ( (c<48) | (c>57) ) {
                return false;
            }
            let i = i + 1;
        }

        return true;
    }


    function Symbol lookupArg(String s) {
        var Collection argv;

        let argv = scope.nth(0);
        do Str.shift(s, 1, 0);  // ##DB## this might need a dup

        return argv.nth(s.intValue());
    }


    function void install(String name, int type, int value) {
        do LibSym.install(symtab/*.nth(0)*/, name, type, value);
        return;
    }

}
