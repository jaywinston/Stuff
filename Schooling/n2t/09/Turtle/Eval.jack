class Eval {

    static int BLOCK, CMD, CMDLIN, END, FUNC, INT, STR, SYM;
    static int TERM;
    static Array INTOPS;
    static String PS1, PS2;
    static String WORDDLMS, EXPDLMS;
    static String BLANKS, EQS, BRACES, PERCENTS;
    static HashTable symtab;


    function void init() {

        let BLOCK = Symbol.BLOCK();
        let CMD = Symbol.CMD();
        let CMDLIN = Symbol.CMDLIN();
        let END = Symbol.END();
        let FUNC = Symbol.FUNC();
        let INT = Symbol.INT();
        let STR = Symbol.STR();
        let SYM = Symbol.SYM();

        let TERM = 4;

        let WORDDLMS = String.new(4);
        do WORDDLMS.appendChar(32);   // ' '
        do WORDDLMS.appendChar(34);   // '"'
        do WORDDLMS.appendChar(61);   // '='
        do WORDDLMS.appendChar(123);  // '{'

        let PS1 = ">";
        let PS2 = "|";

        let EXPDLMS = "=~!<>&|+-*/%";
        let BLANKS = " ";
        let EQS = "=";
        let BRACES = "{}";
        let PERCENTS = "%";

        let INTOPS = Array.new(4);
        let INTOPS[0] = "&|({";
        let INTOPS[1] = "=!<>({";
        let INTOPS[2] = "+-({";
        let INTOPS[3] = "*/%({";

        let symtab = HashTable.new();

        return;
    }


    function void installKW(String name, int val) {
        do symtab.install(name, CMD, val);
        do name.dispose();
        return;
    }


    function Symbol next() {
        return Eval.eval(Terminal.read(PS1), 0);
    }


    function Symbol eval(String s, int i) {
        var String t;
        var Symbol argv;

        if (i > s.length()) {
            return null;
        }

        let i = Str.lskip(s, 32, i);

        if (i = s.length()) {
            return null;
        }

        let t = String.new(s.length());
        let i = Eval.argTkn(s, t, i);

        if (Error.isSet()) {
            do t.dispose();
            return null;
        }

        if (Eval.isAssign(t)) {
            let argv = Eval.symbolExpr(EQS);
            do argv.append(Symbol.new(null, STR, t));  // todo: fix type?
        } else {
            let argv = Eval.expression(t);
            do t.dispose();
        }

        do argv.append(Eval.eval(s, i+1));

        if (Error.isSet()) {
            do Symbol.clear(argv);
            return null;
        }

        return argv;
    }

    function int argTkn(String s, String t, int i) {

        let i = Str.tkn(s, t, WORDDLMS, i);

        if (i < s.length()) {
            if (s.charAt(i) = 34) {
                let i = Str.quotes(s, t, i);
                if (i > s.length()) {
                    do Error.send("unclosed quote");  // ##DB##
                    do Error.set(1);  // unclosed quote
                }
            } else { if (s.charAt(i) = 123) {
                let i = Str.block(s, t, 123, 125, i);
            } else { if (s.charAt(i) = 61) {
                do t.appendChar(61);
                let i = Eval.argTkn(s, t, i+1);
            }}}
        }

        if (i < s.length()) { if (~(s.charAt(i) = 32)) {
            let i = Eval.argTkn(s, t, i);
        }}

        return i;
    }

    function boolean isAssign(String s) {
        var int i;

        let i = Str.index(s, WORDDLMS, 0);

        if (i < s.length()) {
            if (s.charAt(i) = 61) {
                if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                    return false;
                }} else { if (i > 0) {
                        if (  (s.charAt(i-1) = 33)
                           | ((s.charAt(i-1) = 60)
                           |  (s.charAt(i-1) = 62))
                           ) {
                    return false;
                }}}
                return true;
            }
        }

        return false;
    }

    function void assign(String s) {
        var String name;
        var Symbol value;

        if (s.charAt(0) = 61) {
            do Error.send("expected name");  // ##DB##
            do Error.set(1);  // expected name
            return;
        }

        let name = String.new(s.length());
        let value = Eval.args(Eval.eval(s, Str.tkn(s, name, EQS, 0)+1));

        if (Error.isSet()) {
            do name.dispose();
            do Lib.clearSym(value);
            return;
        }

        if (value.type() = STR) {
            do symtab.install(name, value.type(), Str.dup(value.value()));
        } else {
            do symtab.install(name, value.type(), value.value());
        }

        do name.dispose();
        do Lib.clearSym(value);

        return;
    }


    /* stub */
    function Symbol args(Symbol arg) {
        return arg;
    }


    function Symbol expression(String s) {
        var char c;

        let c = s.charAt(0);

        if (c = 34) {
            return Symbol.new(s, STR, Eval.StringExpr(s));
        }

        if (c = 123) {
            return Eval.blockExpr(s);
        }

        if ( (Str.index(s, EXPDLMS, 0) = s.length()) & ~((c>47) & (c<58)) ) {
            return Eval.symbolExpr(s);
        }

        return Symbol.new(s, INT, Eval.intExpr(s, 0, 0));
    }


    /* todo: use Str.format(), no destruct, symbol param */
    function String StringExpr(String s) {
        do s.eraseLastChar();
        do Str.shift(s, 1, 0);
        return Str.dup(Eval.format(s));
    }


    function String format(String s) {
        var int i;

        let i = 0;

        while (i < s.length()) {

            let i = Str.index(s, PERCENTS, i);

            if ((i+1) < s.length()) {
                if (s.charAt(i+1) = 81) {
                    do s.setCharAt(i, 34);
                } else { if (s.charAt(i+1) = 80) {
                    do s.setCharAt(i, 37);
                } else { if (s.charAt(i+1) = 78) {
                    do s.setCharAt(i, 128);
                } else {
                    do Error.send("unrecognized format specifier");  // ##DB##
                    do Error.set(1);
                    do t.dispose();
                    return null;
                }}}

                let i = i + 1;
                do Str.shift(s, 1, i);

            }  // todo: error no fspec
        }

        return s;
    }


    function Symbol blockExpr(String s) {
        var int i, n;
        var Symbol block, end, line;

        let line = Eval.blockLine(s, 1);
        let end = Eval.eval(line.value(), 0);
        if (end.type() = END) {
            do line.dispose();
            // something with superblock and return
        }
        let block = Symbol.new(null, CMDLIN, end);

        while (~(line.type() = END)) {
            do line.dispose();
            let line = Eval.blockLine(Terminal.read(PS2), 0);
            let end = Eval.eval(line.value(), 0);
            do block.append(Symbol.new(null,
                            CMDLIN,
                            Eval.eval(end.value(), 0)));
        }
        do line.dispose();

        do end.append(Symbol.new(null, BLOCK, block));
        let block = end.next();
        do end.dispose();

        return block;
    }


    function Symbol superBlock(/* ? */) {
        var String s;

        let s = end.value();
        if (s.length() > 0) {
            let s = Eval.blockToStr(/* ? */null);
            do Str.cat(s, end.value());
            // eval s here
        }
        return null;
    }


    function String blockToStr(Symbol block) {
        var int n;
        var String s;

        return s;
    }


    function Symbol blockLine(String s, int i) {
        var String t;
        var Symbol line;

        let t = String.new(s.length());
        let i = Eval.blockTkn(s, t, 1);

        if (i < s.length()) {
            let line = Symbol.new(null, END, t);
        } else {
            let line = Symbol.new(null, STR, t);
        }

        while (i < s.length()) {
            let t = String.new(s.length());
            let i = Eval.blockTkn(s, t, i+1);
            do line.append(Symbol.new(null, END, t));
        }

        return line;
    }


    function int blockTkn(String s, String t, int i) {

        if (~(i < s.length())) {
            return i;
        }

        while (i < s.length()) {
            let i = Str.tkn(s, t, BRACES, i);

            if (i < s.length()) {
                if (s.charAt(i) = 125) {
                    return i;
                }
                if (s.charAt(i) = 123) {
                    let i = Str.block(s, t, 123, 125, i);
                }
            }
        }

        return i;
    }


    function Symbol endBlock() {
        return null;
    }


    function Symbol blockEnd(String s, int i) {
        var String t, name;
        var Symbol end;

        if (i = s.length()) {
            return null;
        }

        let t = String.new(s.length());

        let i = Eval.blockTkn(s, t, i);

        if (t.length() > 0) {
            let name = t;
        } else {
            let name = null;
        }

        let end = Symbol.new(name, END, null);

        do t.dispose();

        do end.append(Eval.blockEnd(s, i+1));

        return end;
    }


    function Symbol blockToInt(Symbol block, String s, int i) {
        var String t;

        let t = String.new(s.length() + 6);
        do t.setIntValue(Eval.blockTerm(block));
        do Lib.clearSym(block);
        do Str.tkn(s, t, null, i);
        let block = Eval.eval(t, 0);
        do t.dispose();

        return block;
    }


    function boolean isOp(char c) {
        return ((((c=33) | (c=37)) | ((c=38) | (c=42)))
                | (((c=43) | (c=45)) | ((c=47) | (c=60))))
                | ((c=61) | (c=62));
    }


    function Symbol symbolExpr(String s) {
        var Symbol p;

        let p = symtab.lookup(s);

        if (p = null) {
            return Symbol.new(s, SYM, null);
        }

        return Symbol.clone(p);
    }


    function int intExpr(String s, int i, int depth) {
        var char op;
        var int n;
        var String t;

        if (i = s.length()) {
            do Error.send("expected integer expression");  // ##DB##
            do Error.set(1);  //  expected integer expression
            return 0;
        }
            
        if (depth = TERM) {
            return Eval.term(s);
        }

        let t = String.new(s.length());
        let i = Eval.intTkn(s, t, INTOPS[depth], i);  // sets Error

        if (Error.isSet()) {
            do t.dispose();
            return 0;
        }

        let n = Eval.intExpr(t, 0, depth+1);

        do t.dispose();

        if (i < s.length()) {

            let op = s.charAt(i);

            if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                let op = op + 200;
                let i = i + 1;
            }}

            let n = Eval.operate(n, Eval.intExpr(s, i+1, depth), op);
        }

        return n;
    }


    function int term(String s) {
        var char c;
        var Symbol p;

        let c = s.charAt(0);

        if (c = 45) {
            do Str.shift(s, 1, 0);
            return -Eval.term(s);
        }

        if (c = 126) {
            do Str.shift(s, 1, 0);
            return ~Eval.term(s);
        }

        if ( (c>47) & (c<58) ) {
            return s.intValue();
        }

        if (c = 40) {
            return Eval.parenTerm(s);
        }

        if (c = 123) {
            return Eval.blockTerm(Eval.blockExpr(s));
        }

        if (Error.isSet()) {
            return 0;
        }

        return Eval.symbolTerm(s);

    }

    function int parenTerm(String s) {

        do s.eraseLastChar();
        do Str.shift(s, 1, 0);

        return Eval.intExpr(s, 0, 0);
    }

    function int blockTerm(Symbol b) {
        var int n;
        var Symbol p;

        let p = Exec.execBlock(b.value());
        do Lib.clearSym(b);

        if (~(p.type() = INT)) {
            do Error.send("wrong type; expected integer");  // ##DB##
            do Error.set(1);  // wrong type; expected integer
        }

        let n = p.value();

        do Lib.clearSym(p);

        return n;
    }


    function int symbolTerm(String s) {
        var Symbol p;

        let p = symtab.lookup(s);

        if (p = null) {
            do Error.send("undefined symbol");  // ##DB##
            do Error.set(1);  // undefined symbol
            return 0;
        }

        if (~(p.type() = INT)) {
            do Error.send("wrong type; expected integer");  // ##DB##
            do Error.set(1);  // wrong type; expected integer
            return 0;
        }

        return p.value();
    }

    function int intTkn(String s, String t, String list, int i) {

        while ((s.charAt(i)=45) | (s.charAt(i)=126)) {
            do t.appendChar(s.charAt(i));
            let i = i + 1;
        }

        let i = Str.tkn(s, t, list, i);

        if (t.length() = 0) {
            do Error.send("unexpected operator");  // ##DB##
            do Error.set(1);  // unexpected operator
            return i;
        }

        if ( (s.charAt(i-1)=45) | (s.charAt(i-1)=126) ) {
            do Error.send("unexpected operator");  // ##DB##
            do Error.set(1);  // unexpected operator
            return i;
        }

        if (i < s.length()) {
            if (s.charAt(i) = 40) {
                let i = Str.block(s, t, 40, 41, i);
                if (i > s.length()) {
                    do Error.send("unclosed parentheses");  // ##DB##
                    do Error.set(1);  // unclosed parentheses
                    return i;
                }
                if (i < s.length()) {
                    let i = Eval.intTkn(s, t, list, i);
                }
            } else { if (s.charAt(i) = 123) {
                let i = Str.block(s, t, 123, 125, i);
            }}
        }

        return i;
    }

    function int operate(int m, int n, char op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do Error.send("division by zero");  // ##DB##
            do Error.set(1);  // division by zero
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Lib.mod(m, n); }

        if (op = 261) { return   m = n;  }
        if (op = 233) { return ~(m = n); }
        if (op =  60) { return   m < n;  }
        if (op =  62) { return   m > n;  }
        if (op = 260) { return  (m<n) | (m=n); }
        if (op = 262) { return  (m>n) | (m=n); }

        do Error.send("unrecognized operator");  // ##DB##
        do Error.set(1);  // unrecognized operator
        return 0;
    }

    function void install(String name, int type, int value) {
        do symtab.install(name, type, value);
        return;
    }

}
