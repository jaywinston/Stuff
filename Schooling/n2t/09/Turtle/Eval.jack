class Eval {

    static int BLOCK, FUNC, INT, INTEX, OP, STR, STREX, SYM, UOP;
    static Array FSPECTAB, TYPETAB;
    static Array FERRARGV;
    static String FERRFS;
    static Collection scope, symtab;


    function void init() {
        let BLOCK = LibSym.BLOCK();
        let FUNC = LibSym.FUNC();
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let OP = LibSym.OP();
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();
        let FSPECTAB = Eval.fspectab();
        let TYPETAB = Eval.typetab();
        let FERRFS = "expected format argument of type %S";
        let FERRARGV = Array.new(1);
        let scope = Collection.new();
        let symtab = Collection.new();
        do symtab.append(HashTable.new(15));
        return;
    }


    function Array fspectab() {
        var int i;
        var Array fspectab;

        let fspectab = Array.new(3);  /* magic number! */
        let i = 0;

        let fspectab[i] = LibIO.escseq(68, INT);
        let i = i + 1;

        let fspectab[i] = LibIO.escseq(83, STR);
        let i = i + 1;

        let fspectab[i] = null;

        return fspectab;
    }


    function Array typetab() {
        var int i;
        var Array typetab;

        let typetab = Array.new(3);  /* magic number! */
        let i = 0;

        let typetab[i] = LibIO.escseq(INT, "INT");
        let i = i + 1;

        let typetab[i] = LibIO.escseq(STR, "STR");
        let i = i + 1;

        let typetab[i] = null;

        return typetab;
    }


    function int integer(Collection queue) {
        var int lo, ro, n;
        var Collection stack;
        var Symbol p1, p2, p3;

        let queue = arg.data();
        let stack = Collection.new();

        while (queue.length() > 0) {

            let p1 = queue.pop();

            if (p1.meta() = UOP) {
                do stack.push(Eval.uoperate(stack.pop(), p1.data()));
            } else { if ( (p1.meta()&OP) = OP) {
                let ro = stack.pop();
                let lo = stack.pop();
                do stack.push(Eval.operate(lo, ro, p1.data()));
            } else {
                do Eval.arg(p1);
                if (~(p1.meta() = INT)) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(stack);
                    do LibSym.destroySym(p1);
                    return 0;
                }
                do stack.push(p1.data());
            }}

            do p1.dispose();
        }

        let n = stack.pop();

        if (stack.length() > 0) {
            do LibIO.error("expected operator");
        }

        do stack.dispose();

        return n;
    }


    function String string(Collection fstrex) {
        var boolean fspec;
        var char c;
        var int a, i;
        var int type;
        var Array argv;
        var String s, t;
        var Symbol argp;

        let argp = Eval.arg(fstrex.pop());

        if (~(argp.meta() = STR)) {
            do LibIO.error("expected string");
            do LibSym.destroySym(argp);
            return "";
        }

        let s = argp.data();
        do argp.dispose();

        if (s.length() < 2) {
            return s;
        }

        let argv = Array.new(s.length()/2);
        let fspec = false;
        let a = 0;
        let i = 0;
        while (i < s.length()) {
            let c = s.charAt(i);
            if (fspec) {
                let argp = Eval.arg(argv.nth(a));
                if (argp = null) {
                    do LibIO.error("expected format argument");
                    do LibSym.destroyList(argv);
                    return "";
                }
                let type = Lex.escape(c, FSPECTAB);
                if (~(argp.meta() = type)) {
                    let FERRARGV[0] = Lex.escape(type, TYPETAB);
                    do LibIO.error(Str.format(FERRFS, FERRARGV));
                    do LibSym.destroyList(argv);
                    do LibSym.destroySym(argp);
                    return "";
                }
                let argv[a] = argp.data();
                let a = a + 1;
                let fspec = false;
            } else { if (c = 37) {  /* magic number! interpreter esc char */
                let fspec = true;
            }}
            let i = i + 1;
        }

        if (fspec) {
            do LibIO.error("expected format specifier");
            let t = "";
        } else {
            let t = Str.format(s, argv);
        }

        do LibSym.destroyList(argv);
        do s.dispose();

        return t;
    }


    function void intex(Symbol intex) {
        do intex.setData(Eval.integer(intex.data()));
        do intex.setMeta(INT);
        return;
    }


    function void strex(Symbol strex) {
        do strex.setData(Eval.string(strex.data()));
        do strex.setMeta(STR);
        return;
    }


    function void sym(Symbol sym) {
        var Symbol p;

        let p = Eval.lookup(sym.tag());

        if (p = null) {
            do LibIO.error("undefined symbol");
            return;
        }

        if (p.meta() = STR) {
            do sym.setData(Str.dup(p.data()));
        } else { if (p.meta() = FUNC) {
            do sym.setData(LibSym.copyList(p.data()));
        } else {
            do sym.setData(p.data());
        }}

        do sym.setMeta(p.meta());

        return;
    }


    function void block(Symbol block) {
        var Symbol new, old;

        let old = block.data();
        let new = Exec.block(block);
        do LibSym.destroyList(old);

        if (new = null) {
            do block.setData(null);
            do block.setMeta(null);
            return;
        }

        if (new.meta() = STR) {
            do block.setData(Str.dup(new.data()));
        } else {
            do block.setData(new.data());
        }

        do block.setMeta(new.meta());

        return;
    }


    function Symbol arg(Symbol arg) {

        if (arg = null) {
            return null;
        }

        if (arg.meta() = SYM) {
            do Eval.sym(arg);
        } else { if (arg.meta() = INTEX) {
            do Eval.intex(arg);
        } else { if (arg.meta() = STREX) {
            do Eval.strex(arg);
        } else { if (arg.meta() = BLOCK) {
            do Eval.block(arg);
        }}}}

        return arg;
    }


    function int uoperate(int n, int op) {

        if (op =  43) { return Math.abs(n); }
        if (op =  45) { return -n;          }
        if (op = 126) { return ~n;          }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function int operate(int m, int n, int op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do LibIO.error("division by zero");
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }
        if (op =  94) { return ~(m&n) & (m|n); }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Vector.mod(m, n); }

        if (op = 6161) { return   m = n;  }
        if (op = 3361) { return ~(m = n); }
        if (op =   60) { return   m < n;  }
        if (op =   62) { return   m > n;  }
        if (op = 6061) { return  (m<n) | (m=n); }
        if (op = 6261) { return  (m>n) | (m=n); }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function void pushScope(int hsize, Collection argv) {
        do symtab.push(HashTable.new(hsize));
        do scope.push(argv);
        return;
    }


    function void dropScope() {
        do LibSym.destroyHashTable(symtab.pop());
        do LibSym.destroyList(scope.pop());
        return;
    }


    function Symbol lookup(String s) {
        var int i;
        var HashTable table;
        var Symbol sym;

        if (Eval.isArg(s)) {
            return Eval.lookupArg(s);
        }

        let i = 0;
        while (i < symtab.length()) {
            let table = symtab.nth(i);
            let sym = table.lookup(s);
            if (~(sym = null)) {
                return sym;
            }
            let i = i + 1;
        }

        return null;
    }


    function boolean isArg(String s) {
        var char c;
        var int i;

        if (s.length() < 2) {
            return false;
        }

        if (~(s.charAt(0) = 36)) {
            return false;
        }

        let i = 1;
        while (i < s.length()) {
            let c = s.charAt(i);
            if (~( (c>47) & (c<58) )) {
                return false;
            }
            let i = i + 1;
        }

        return true;
    }


    function Symbol lookupArg(String s) {
        var Collection argv;

        let argv = scope.nth(0);
        do Str.shift(s, 1, 0);  // ##DB## this might need a dup

        return argv.nth(s.intValue());
    }


    function void install(String name, int type, int value) {
        do LibSym.install(symtab.nth(0), name, type, value);
        return;
    }

}
