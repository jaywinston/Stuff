class Eval {



    static int EQ, BLANK, DELIM, BLOCK, END, EOS, CMDLIN, INT, COMMA,
                INTEX, OP, STR, STREX, SYM, UOP, LPAREN, RPAREN;
    static int CLASSMASK;
    static Symbol symtab;

function void eval(int i, int u) {return;} // ##DB##

    function void init() {
        let EQ = Lex.cclass(61);
        let BLANK = Lex.cclass(32);
        let BLOCK = LibSym.BLOCK();
        let END = Lex.cclass(125);
        let EOS = Lex.cclass(0);
        let CMDLIN = LibSym.CMDLIN();
        let INT = LibSym.INT();
        let INTEX = LibSym.INTEX();
        let OP = LibSym.OP();
        let STR = LibSym.STR();
        let STREX = LibSym.STREX();
        let SYM = LibSym.SYM();
        let UOP = LibSym.UOP();
        let LPAREN = Lex.cclass(40);
        let RPAREN = Lex.cclass(41);
        let CLASSMASK = -16;
        return;
    }


    function int integer(Symbol queue) {
        var int n;
        var Symbol p, stack;
        var Symbol np;

        while (~(queue = null)) {
            if ( (queue.meta()&OP) = OP) {
                let np = stack;
                let stack = stack.next();
                do stack.setData(Eval.operate(stack.data(), np.data(),
                                              queue.data()));
                do np.dispose();
            } else { if (queue.meta() = UOP) {
                do stack.setData(Eval.uoperate(stack.data(), queue.data()));
            } else {
                let p = Eval.arg(LibSym.copySym(queue));
                /* todo: type check */
                do p.setNext(stack);
                let stack = p;
            }}
            let queue = queue.next();
        }

        let n = stack.data();
        do stack.dispose();

        return n;
    }


    function String string(Symbol argv) {
        var String s;

        return s;
    }


    function void strex(Symbol argv) {
        return;
    }


    function void sym(Symbol sym) {
        return;
    }


    function void block(Symbol block) {
        return;
    }


    function Symbol arg(Symbol arg) {
        return arg;
    }


    function int uoperate(int n, int op) {

        if (op =  43) { return Math.abs(n); }
        if (op =  45) { return -n;          }
        if (op = 126) { return ~n;          }

        do Error.send("unrecognized operator");  // ##DB##
        do Error.set(1);  // unrecognized operator
        return 0;
    }


    function int operate(int m, int n, int op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do Error.send("division by zero");  // ##DB##
            do Error.set(1);  // division by zero
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Vector.mod(m, n); }

        if (op = 6161) { return   m = n;  }
        if (op = 3361) { return ~(m = n); }
        if (op =   60) { return   m < n;  }
        if (op =   62) { return   m > n;  }
        if (op = 6061) { return  (m<n) | (m=n); }
        if (op = 6261) { return  (m>n) | (m=n); }

        do Error.send("unrecognized operator");  // ##DB##
        do Error.set(1);  // unrecognized operator
        return 0;
    }


    function void assign(String name) { // ##DB## , int type, int value) {
        return;
    }

}
