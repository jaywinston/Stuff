class Eval {

    static int BLOCK, CMD, CMDLIN, END, EXPR, FUNC, INT, STR, SYM;
    static int TERM;
    static Array INTOPS;
    static String PS1, PS2;
    static String ASGNDLMS, EXPDLMS;
    static String EQS, LBRACES;
    static Symbol symtab;


    function void init() {

        let BLOCK = LibSym.BLOCK();
        let CMD = LibSym.CMD();
        let CMDLIN = LibSym.CMDLIN();
        let END = LibSym.END();
        let EXPR = LibSym.EXPR();
        let FUNC = LibSym.FUNC();
        let INT = LibSym.INT();
        let STR = LibSym.STR();
        let SYM = LibSym.SYM();

        let TERM = 4;
        let INTOPS = Array.new(4);
        let INTOPS[0] = "&|({";
        let INTOPS[1] = "=!<>({";
        let INTOPS[2] = "+-({";
        let INTOPS[3] = "*/%({";

        let ASGNDLMS = String.new(3);
        do ASGNDLMS.appendChar(34);   // '"'
        do ASGNDLMS.appendChar(61);   // '='
        do ASGNDLMS.appendChar(123);  // '{'

        let PS1 = ">";
        let PS2 = "|";

        let EXPDLMS = "=~!<>&|+-*/%";
        let EQS = "=";
        let LBRACES = "{";
        let symtab = Symbol.new(null, LibSym.HASHTAB(), HashTable.new(15));

        return;
    }


    /* read and evaluate next command line */
    function Symbol next() {
        return Eval.eval(IOBox.read(PS1), 0);
    }


    /* parse one word from s from index i */
    function Symbol eval(String s, int i) {
        var String t;
        var Symbol argv,p;

        if (i > s.length()) {
            return null;
        }

        let i = Str.lskip(s, 32, i);

        if (i = s.length()) {
            return null;
        }

        let t = String.new(s.length());
        let i = Lex.word(s, t, i);

        if (Error.isSet()) {
            do t.dispose();
            return null;
        }

        if (Eval.isAssign(t)) {
            let argv = Symbol.new("=", SYM, null);
            do argv.append(Symbol.new(null, STR, t));
        } else {
            let argv = Eval.expression(t);
            do t.dispose();
        }

        do argv.append(Eval.eval(s, i+1));

        if (Error.isSet()) {
            do LibSym.destroyList(argv);
            return null;
        }

        return argv;
    }

    function boolean isAssign(String s) {
        var int i;

        let i = Str.index(s, ASGNDLMS, 0);

        if (i < s.length()) {
            if (s.charAt(i) = 61) {
                if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                    return false;
                }} else { if (i > 0) {
                        if (  (s.charAt(i-1) = 33)
                           | ((s.charAt(i-1) = 60)
                           |  (s.charAt(i-1) = 62))
                           ) {
                    return false;
                }}}
                return true;
            }
        }

        return false;
    }


    function void assign(String s) {
        var int i;
        var String name;
        var Symbol value;

        if (s.charAt(0) = 61) {
            do Error.send("expected name");  // ##DB##
            do Error.set(1);  // expected name
            return;
        }

        let name = String.new(s.length());
        let i = Str.tkn(s, name, EQS, 0);
        let value = Eval.arg(Eval.eval(s, i+1));

        if (Error.isSet()) {
            do name.dispose();
            do LibSym.destroyList(value);
            return;
        }

        if (value = null) {
            do Eval.install(name, SYM, null);
            return;
        }

        if (value.meta() = STR) {
            do Eval.install(name, value.meta(), Str.dup(value.data()));
        } else {
            do Eval.install(name, value.meta(), value.data());
        }

        do name.dispose();
        do LibSym.destroyList(value);

        return;
    }


    function Symbol arg(Symbol arg) {
        var int type;
        var Symbol p;

        if (arg = null) {
            return null;
        }

        let type = arg.meta();
        let p = null;

        if (type = BLOCK) {
            let p = Exec.execBlock(arg.data());
            do LibSym.destroyList(arg.data());
        } else { if (type = EXPR) {
            let p = Eval.blockToExpr(arg);
            //do LibSym.destroyList(arg.next());
            //do arg.setNext(null);
        } else { if (type = SYM) {
            let p = Eval.lookup(arg.name());
            if (p = null) {
                do Error.send("undefined symbol");  // ##DB##
                do Error.set(1);  // undefined symbol
                return null;
            }
        } else { if (type = INT) {
            do arg.setData(Eval.integer(arg.name(), 0, 0));
        } else {
            return arg;
        }}}}

        if (~(p = null)) {
            if (p.meta() = FUNC) {
                do arg.setData(LibSym.copyList(p.data()));
            } else { if (p.meta() = STR) {
                do arg.setData(Str.dup(p.data()));
            } else {
                do arg.setData(p.data());
            }}

            do arg.setMeta(p.meta());
            if ( (type=BLOCK) | (type=EXPR) ) {
                do LibSym.destroyList(p);
            }
        }


        return arg;
    }


    function Symbol expression(String s) {
        var char c;

        let c = s.charAt(0);

        if (c = 34) {
            return Symbol.new(Str.dup(s), STR, Eval.StringExpr(s));
        }

        if (c = 123) {
            return Eval.blockExpr(s);
        }

        if ( (Str.index(s, EXPDLMS, 0) = s.length()) & ~((c>47) & (c<58)) ) {
            return Symbol.new(Str.dup(s), SYM, null);
        }

        return Symbol.new(Str.dup(s), INT, 0);  // s is evaluated at execution
    }


    function String StringExpr(String s) {
        var int a, i, n;
        var Array args, reg;
        var String f, t, arg;
        var Symbol p;

        let s = Str.dup(s);

        let f = String.new(s.length());
        let n = 0;
        let i = 1;
        while (~(s.charAt(i) = 34)) {
            if (s.charAt(i) = 92) {
                let i = i + 1;
            }
            do f.appendChar(s.charAt(i));
            if (s.charAt(i) = 37) {
                /* i+1 is assured less than s.length() */
                if ( (s.charAt(i+1)=68) | (s.charAt(i+1)=83) ) {
                    let n = n + 1;
                }
            }
            let i = i + 1;
        }

        if (n = 0) {
            return Str.format(f, null);
        }

        let args = Array.new(n);
        let reg = Array.new(n);

        let a = 0;
        while (i < s.length()) {
            let arg = String.new(s.length());
            let i = Lex.fArg(s, arg, i+1);
            if (i > s.length()) {
                do s.dispose();
                let s = Eval.openBlock(arg);
                do arg.dispose();
                let arg = String.new(s.length());
                let i = Lex.fArg(s, arg, 0);
            }
            if (i < 0) {
                do arg.dispose();
                do Error.send("no argument for format specifier");  // ##DB##
                do Error.set(1);  // no argument for format specifier
                return null;
            }
            let p = Eval.fArg(arg);
            let reg[a] = p.meta();
            let args[a] = p.data();
            do p.dispose();
            do arg.dispose();
            let a = a + 1;
        }

        do s.dispose();

        let t = Str.format(f, args);

        do f.dispose();
        let a = 0;
        while (a < n) {
            if (reg[a] = STR) {
                let arg = args[a];
                do arg.dispose();
            }
            let a = a + 1;
        }
        do args.dispose();
        do reg.dispose();

        return t;
    }


    function Symbol fArg(String s) {
        var Symbol p;

        if (s.length() = 0) {
            return Symbol.new(null, null, null);
        }

        let p = Eval.arg(Eval.eval(s, 0));

        if (p = null) {
            return Symbol.new(null, null, null);
        }

        return p;
    }


    function Symbol blockExpr(String s) {
        var int i, n;
        var Symbol block, end, line;

        let line = Eval.blockLine(s, 1);
        let end = Eval.eval(line.data(), 0);

        if (~(end = null)) { if (end.meta() = END) {
            do line.dispose();  // end is prepended with line.next
            return Eval.toSuperBlock(end);  // destroys end
        }}
        let block = Symbol.new(null, CMDLIN, end);

        while (~(line.meta() = END)) {
            do LibSym.destroySym(line);
            let line = Eval.blockLine(IOBox.read(PS2), 0);
            let end = Eval.eval(line.data(), 0);
            if (~(end = null)) {
                do block.append(Symbol.new(null, CMDLIN, end));
            }
        }

        if (block.data() = null) {
            let end = block;
            let block = block.next();
            do LibSym.destroySym(end);
        }

        do line.append(Symbol.new(null, BLOCK, block));
        let block = line.next();
        do LibSym.destroySym(line);

        return block;
    }


    /* return a list of strings representing block endings */
    function Symbol blockLine(String s, int i) {
        var String t;
        var Symbol line;

        if (~(i < s.length())) {
            return Symbol.new(null, STR, "");
        }

        /* look for end of block */
        let t = String.new(s.length());
        let i = Lex.block(s, t, i);

        if (i < s.length()) {
            let line = Symbol.new(null, END, t);
        } else {
            let line = Symbol.new(null, STR, t);
        }

        /* append any ends of super blocks or expressions */
        while ( (i+1) < s.length() ) {
            let t = String.new(s.length());
            let i = Lex.block(s, t, i+1);
            if (i < s.length()) {
                do line.append(Symbol.new(null, END, t));
            } else {
                do line.append(Symbol.new(null, EXPR, t));
            }
        }

        return line;
    }


    function Symbol toSuperBlock(Symbol end) {
        var String s, t;
        var Symbol block, super;

        /* make block a sub-block of the super-block */
        let block = end;
        while (~(block.next() = null)) {  // the last node holds the block
            let block = block.next();
        }

        let super = end;
        while (~(super.next() = block)) {
            let super = super.next();
        }

        do super.setNext(Symbol.new(null, BLOCK, block));

        /* if this block is an expression, evaluate the expression */
        let s = end.data();

        if (s.length() > 0) {
            let block = LibSym.copySym(end);
            do block.append(super.next());
            do super.setNext(Eval.blockToExpr(block));
            do LibSym.destroyList(block);
        }

        let block = end.next();
        do LibSym.destroySym(end);

        return block;
    }


    function String blockToStr(Symbol block) {
        var int n;
        var String s;
        var Symbol expr;

        let expr = Exec.execBlock(block.data());

        if (expr = null) {
            return "";
        }

        if (expr.meta() = STR) {
            let s = expr.data();
            let s = String.new(s.length()+2);
            do s.appendChar(34);
            do Str.cat(s, expr.data());
            do s.appendChar(34);
        } else {
            let s = String.new(6);
            do s.setInt(expr.data());
        }

        do LibSym.destroySym(expr);

        return s;
    }


    function Symbol blockToExpr(Symbol block) {
        var String expr, term;
        var Symbol p1, p2;

        /* get block, convert to string */
        let p1 = block;
        while (~(p1.next() = null)) {
            let p1 = p1.next();
        }

        let expr = String.new(Str.MAXLEN());
        let term = Eval.blockToStr(p1);
        do Str.cat(expr, term);
        do term.dispose();

        let p2 = block;
        while (~(p2.next() = p1)) {
            let p2 = p2.next();
        }
        do LibSym.destroySym(p1);

        do Str.cat(expr, block.data());

        /* overwrite block */
        do p2.setNext(Eval.arg(Eval.eval(expr, 0)));

        do expr.dispose();

        let p1 = block;
        let block = block.next();
        do LibSym.destroySym(p1);

        return block;
    }


    function int integer(String s, int i, int depth) {
        var char op;
        var int n;
        var String t;

        if (i = s.length()) {
            do Error.send("expected integer expression");  // ##DB##
            do Error.set(1);  //  expected integer expression
            return 0;
        }
            
        if (depth = TERM) {
            return Eval.term(s);
        }

        let t = String.new(s.length());
        let i = Lex.integer(s, t, INTOPS[depth], i);

        if (i > s.length()) {
            let n = Eval.intOpenBlock(t);
            do t.dispose();
            return n;
        }

        if (Error.isSet()) {
            do t.dispose();
            return 0;
        }

        let n = Eval.integer(t, 0, depth+1);

        do t.dispose();

        if (i < s.length()) {

            let op = s.charAt(i);

            if ( (i+1) < s.length() ) { if (s.charAt(i+1) = 61) {
                let op = op + 200;
                let i = i + 1;
            }}

            let n = Eval.operate(n, Eval.integer(s, i+1, depth), op);
        }

        return n;
    }


    function int term(String s) {
        var char c;
        var Symbol p;

        let c = s.charAt(0);

        if (c = 45) {
            do Str.shift(s, 1, 0);
            return -Eval.term(s);
        }

        if (c = 126) {
            do Str.shift(s, 1, 0);
            return ~Eval.term(s);
        }

        if ( (c>47) & (c<58) ) {
            return s.intValue();  // allows malformed tokens but won't break
        }

        if (c = 40) {
            return Eval.parenTerm(s);
        }

        if (c = 123) {
            return Eval.blockTerm(s);
        }

        return Eval.symbolTerm(s);

    }


    function int parenTerm(String s) {

        do s.eraseLastChar();
        do Str.shift(s, 1, 0);

        return Eval.integer(s, 0, 0);
    }


    function int blockTerm(String s) {
        var int n;
        var Symbol value;
        var Symbol block;

        let block = Eval.blockExpr(s);
        if (block.meta() = BLOCK) {
            let value = Exec.execBlock(block);
            do LibSym.destroyList(block);
        } else {
            let value = block;
        }

        if (value = null) {
            do Error.send("invalid integer");  // ##DB##
            do Error.set(1);  // invalid integer
            return 0;
        }

        if (~(value.meta() = INT)) {
            do LibSym.destroyList(value);
            do Error.send("expected integer");  // ##DB##
            do Error.set(1);  // expected integer
            return 0;
        }

        let n = value.data();

        do LibSym.destroyList(value);

        return n;
    }


    function int symbolTerm(String s) {
        var Symbol p;

        let p = Eval.lookup(s);

        if (p = null) {
            do Error.send("undefined symbol");  // ##DB##
            do Error.set(1);  // undefined symbol
            return 0;
        }

        if (~(p.meta() = INT)) {
            do Error.send("expected integer");  // ##DB##
            do Error.set(1);  // expected integer
            return 0;
        }

        return p.data();
    }


    function String openBlock(String s) {
        var int i;
        var String t, exprs;
        var Symbol exprp;

        let exprs = String.new(Str.MAXLEN());
        let t = String.new(s.length());

        let i = Str.tkn(s, t, LBRACES, 0);
        do Str.cat(exprs, t);
        do t.dispose();

        let t = String.new(s.length());
        let i = Str.tkn(s, t, null, i);

        let exprp = Eval.blockExpr(t);
        do t.dispose();

        if (exprp.data() = null) {
            do exprp.dispose();
            do exprs.dispose();
            do Error.send("expected expression");  // ##DB##
            do Error.set(1);  // expected expression
        }

        if (exprp.meta() = EXPR) {
            let t = Eval.blockToStr(exprp.next());
            do Str.cat(exprs, t);
            do t.dispose();
            do Str.cat(exprs, exprp.data());
        } else {
            let t = Eval.blockToStr(exprp);
            do Str.cat(exprs, t);
            do t.dispose();
        }

        do LibSym.destroyList(exprp);

        return exprs;
    }


    function int intOpenBlock(String s) {
        var int n;
        var String exprs;
        var Symbol exprp;

        let exprs = Eval.openBlock(s);
        let exprp = Eval.arg(Eval.eval(exprs, 0));
        do exprs.dispose();

        if (exprp = null) {
            // error
        }

        if (~(exprp.meta() = INT)) {
            // error
        }

        let n = exprp.data();
        do LibSym.destroyList(exprp);

        return n;
    }


    function int operate(int m, int n, char op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do Error.send("division by zero");  // ##DB##
            do Error.set(1);  // division by zero
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Vector.mod(m, n); }

        if (op = 261) { return   m = n;  }
        if (op = 233) { return ~(m = n); }
        if (op =  60) { return   m < n;  }
        if (op =  62) { return   m > n;  }
        if (op = 260) { return  (m<n) | (m=n); }
        if (op = 262) { return  (m>n) | (m=n); }

        do Error.send("unrecognized operator");  // ##DB##
        do Error.set(1);  // unrecognized operator
        return 0;
    }


    function void pushScope(int hsize) {
        var Symbol scope;

        let scope = Symbol.new(null, 0, HashTable.new(hsize));
        do scope.setNext(symtab);
        let symtab = scope;

        return;
    }


    function void dropScope() {
        var Symbol scope;

        let scope = symtab;
        let symtab = scope.next();
        do LibSym.destroySym(scope);

        return;
    }


    function Symbol lookup(String s) {
        var HashTable table;
        var Symbol scope, sym;

        let scope = symtab;
        while (~(scope = null)) {
            let table = scope.data();
            let sym = table.lookup(s);
            if (~(sym = null)) {
                return sym;
            }
            let scope = scope.next();
        }

        return null;
    }


    function void install(String name, int type, int value) {
        do LibSym.install(symtab.data(), Str.dup(name), type, value);
        return;
    }

}
