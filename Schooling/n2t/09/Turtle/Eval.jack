// Site use of the meta namespace is bit[0..2] to classify unary operator.

class Eval {

    static int ESC;
    static int BLOCK, FUNC, GLOBL, LIST, INT, ARTEX, OP, STR, FMTEX, NAME, UOP;
    static Array FSPECTAB, TYPETAB;
    static Array FERRARGV;
    static String FERRFS;
    static Collection context, symtab;


    function void init() {
        let ESC = 37;  /* magic number! */
        let BLOCK = LibSym.BLOCK();
        let FUNC = LibSym.FUNC();
        let INT = LibSym.INT();
        let LIST = LibSym.LIST();
        let ARTEX = LibSym.ARTEX();
        let OP = LibSym.OP();
        let GLOBL = ~LibSym.SITE();
        let STR = LibSym.STR();
        let FMTEX = LibSym.FMTEX();
        let NAME = LibSym.NAME();
        let UOP = LibSym.UOP();
        let FSPECTAB = Eval.fspectab();
        let TYPETAB = Eval.typetab();
        let FERRFS = "expected %S argument";
        let FERRARGV = Array.new(1);
        let context = Collection.new();
        let symtab = Collection.new();
        do symtab.push(HashTable.new(15));
        return;
    }


    function Array fspectab() {
        var int i;
        var Array fspectab;

        let fspectab = Array.new(5);  /* magic number! */
        let i = 0;

        let fspectab[i] = 68;
        let fspectab[i+1] = INT;
        let i = i + 2;

        let fspectab[i] = 83;
        let fspectab[i+1] = STR;
        let i = i + 2;

        let fspectab[i] = null;

        return fspectab;
    }


    function Array typetab() {
        var int i;
        var Array typetab;

        let typetab = Array.new(5);  /* magic number! */
        let i = 0;

        let typetab[i] = INT;
        let typetab[i+1] = "integer";
        let i = i + 2;

        let typetab[i] = STR;
        let typetab[i+1] = "string";
        let i = i + 2;

        let typetab[i] = null;

        return typetab;
    }


    function Symbol arg(Symbol arg) {

        if (arg = null) {
            return null;
        }

        if (arg.meta() = NAME)  { return Eval.name(arg);  }
        if (arg.meta() = ARTEX) { return Eval.artex(arg); }
        if (arg.meta() = FMTEX) { return Eval.fmtex(arg); }
        if (arg.meta() = BLOCK) { return Eval.block(arg); }
        if (arg.meta() = LIST)  { return Eval.list(arg);  }

        return arg;
    }


    function Symbol name(Symbol sym) {
        var int type;
        var String tag;
        var Symbol p;

        let tag = sym.data();
        do sym.setTag(tag);
        let p = Eval.lookup(tag);

        if (p = null) {
            do LibIO.error("undefined symbol");
            return sym;
        }

        let type = p.meta();
        if (type = STR) {
            do sym.setData(Str.dup(p.data()));
        } else { if (type = FUNC) {
            do sym.setData(LibSym.copyList(p.data()));
        } else {
            do sym.setData(p.data());
        }}

        do sym.setMeta(type);

        return sym;
    }


    function Symbol lookup(String s) {
        var int i;
        var HashTable table;
        var Symbol sym;

        if ( Eval.isArg(s) & (context.length()>0) ) {
            return Eval.lookupArg(s);
        }

        let i = 0;
        while (i < symtab.length()) {
            let table = symtab.nth(i);
            let sym = table.lookup(s);
            if (~(sym = null)) {
                return sym;
            }
            let i = i + 1;
        }

        return null;
    }


    function boolean isArg(String s) {
        var char c;
        var int i;

        if (s.length() < 2) {
            return false;
        }

        if (~(s.charAt(0) = 36)) {
            return false;
        }

        let i = 1;
        while (i < s.length()) {
            let c = s.charAt(i);
            if ( (c<48) | (c>57) ) {
                return false;
            }
            let i = i + 1;
        }

        return true;
    }


    function Symbol lookupArg(String s) {
        var int i;
        var Collection argv;

        do Str.shift(s, 1, 0);  // todo: this might need a dup
        let i = s.intValue();
        do s.dispose();

        if (i < 0) {
            do LibIO.error("invalid index");
            return null;
        }

        let argv = context.nth(0);

        if (~(i < argv.length())) {
            do LibIO.error("expected argument");
            return null;
        }

        return Eval.arg(argv.nth(i));
    }


    function Symbol artex(Symbol artex) {
        var Collection q;

        let q = artex.data();

        if (q.length() = 0) {
            do q.dispose();
            do artex.setMeta(null);
        } else {
            do artex.setData(Eval.arithmeticExpression(q));
            do artex.setMeta(INT);
        }

        return artex;
    }


    function int arithmeticExpression(Collection queue) {
        var int lo, ro;  /* left, right operand */
        var int n;
        var Collection stack;
        var Symbol tok;

        let stack = Collection.new();

        while (queue.length() > 0) {

            let tok = queue.pop();

            if (tok.meta() = UOP) {
                if (stack.length() = 0) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(queue);
                    do stack.dispose();
                    do tok.dispose();
                    return 0;
                }
                do stack.push(Eval.uoperate(stack.pop(), tok.data()));
            } else { if ( (tok.meta()&OP) = OP) {
                if (stack.length() < 2) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(queue);
                    do stack.dispose();
                    do tok.dispose();
                    return 0;
                }
                let ro = stack.pop();
                let lo = stack.pop();
                do stack.push(Eval.operate(lo, ro, tok.data()));
            } else {
                do Eval.arg(tok);
                if (~(tok.meta() = INT)) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(queue);
                    do LibSym.destroySym(tok);
                    do stack.dispose();
                    return 0;
                }
                do stack.push(tok.data());
            }}

            do tok.dispose();
        }

        let n = stack.pop();

        if (stack.length() > 0) {
            do LibIO.error("expected operator");
        }

        do stack.dispose();
        do queue.dispose();

        return n;
    }


    function int uoperate(int n, int op) {

        if (op =  43) { return Math.abs(n); }
        if (op =  45) { return -n;          }
        if (op = 126) { return ~n;          }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function int operate(int m, int n, int op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do LibIO.error("division by zero");
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }
        if (op =  94) { return (m|n) & ~(m&n); }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Vector.mod(m, n); }

        if (op = 6161) { return   m = n;  }
        if (op = 3361) { return ~(m = n); }
        if (op =   60) { return   m < n;  }
        if (op =   62) { return   m > n;  }
        if (op = 6061) { return  (m<n) | (m=n); }
        if (op = 6261) { return  (m>n) | (m=n); }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function Symbol fmtex(Symbol fmtex) {
        do fmtex.setData(Eval.formatExpression(fmtex.data()));
        do fmtex.setMeta(STR);
        return fmtex;
    }


    function String formatExpression(Collection argv) {
        var boolean fspec;
        var int c;
        var int a, i;
        var int type;
        var Array fargv;
        var String s, t;
        var Symbol arg;

        let arg = Eval.arg(argv.pop());

        if (arg = null) {
            do LibIO.error("expected format string");
            do LibSym.destroyList(argv);
            return "";
        }

        if (~(arg.meta() = STR)) {
            do LibIO.error("expected format string");
            do LibSym.destroyList(argv);
            do LibSym.destroySym(arg);
            return "";
        }

        let s = arg.data();
        do arg.dispose();

        if (s.length() < 2) {
            do LibSym.destroyList(argv);
            return s;
        }

        let fargv = Array.new(s.length()/2);
        let fspec = false;
        let a = 0;

        let i = 0;
        while (i < s.length()) {
            let c = s.charAt(i);
            if ( fspec & ~(c=ESC) ) {

                let arg = Eval.arg(argv.nth(a));

                if (arg = null) {
                    do LibIO.error("expected format argument");
                    do LibSym.destroyList(argv);
                    do s.dispose();
                    return "";
                }

                let type = Lex.escape(c, FSPECTAB);

                if (type = c) {
                    do LibIO.error("unrecognized format specifier");
                    do LibSym.destroyList(argv);
                    do s.dispose();
                    return "";
                }

                if (~(arg.meta() = type)) {
                    let FERRARGV[0] = Lex.escape(type, TYPETAB);
                    do LibIO.error(Str.format(FERRFS, FERRARGV));
                    do LibSym.destroyList(argv);
                    do s.dispose();
                    return "";
                }

                let fargv[a] = arg.data();
                let a = a + 1;
            }

            let fspec = ~fspec & (c=ESC);
            let i = i + 1;
        }

        if (fspec) {
            do LibIO.error("expected format specifier");
            let t = "";
        } else {
            let t = Str.format(s, fargv);
        }

        do LibSym.destroyList(argv);
        do fargv.dispose();
        do s.dispose();

        return t;
    }


    function Symbol block(Symbol block) {
        var Symbol ret;

        let ret = Exec.block(block.data());

        if (ret = null) {
            do block.setMeta(null);
            return block;
        }

        do block.setData(ret.data());
        do block.setMeta(ret.meta());
        do ret.dispose();

        return block;
    }


    function Symbol list(Symbol arg) {
        var int i;
        var Collection list;

        let list = arg.data();
        let i = 0;
        while (i < list.length()) {
            do Eval.arg(list.nth(i));
            let i = i + 1;
        }

        return arg;
    }


    function int condition(Symbol arg) {
        var int c;
        var Symbol cp;

        let cp = Eval.arg(LibSym.copySym(arg));
        if (cp = null) {
            /* todo: error? */
            return 0;
        }
        let c = cp.data();
        do LibSym.destroySym(cp);

        return c;
    }


    function void pushContext(Symbol arg0, Collection argv) {
        do argv.push(Symbol.new(null, STR, arg0.tag()));
        do arg0.setTag(null);
        do context.push(argv);
        do symtab.push(HashTable.new(3));
        return;
    }


    function void dropContext() {
        var Collection argv;

        let argv = context.pop();
        do LibSym.destroySym(argv.pop());
        do LibSym.destroyHashTable(symtab.pop());

        return;
    }


    function void install(String name, int type, int value) {
        do LibSym.install(symtab.nth(0), name, type, value);
        return;
    }

}
