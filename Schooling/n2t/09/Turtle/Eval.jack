// Site use of the meta namespace is bit[0..2] to classify unary operator.

class Eval {

    static int ESC;
    static int ARTEX, BLOCK, FMTEX, FUNC, GLOBL, INDEX, INT, LIST, NAME, OP,
        STR, UOP;
    static Array FSPECTAB, TYPETAB;
    static Array FERRARGV;
    static String FERRFS;
    static Collection context, symtab;


    function void init() {

        let ESC = 37;  /* magic number! */

        let ARTEX = LibSym.ARTEX();
        let BLOCK = LibSym.BLOCK();
        let FMTEX = LibSym.FMTEX();
        let FUNC = LibSym.FUNC();
        let GLOBL = ~LibSym.SITE();
        let INDEX = LibSym.INDEX();
        let INT = LibSym.INT();
        let LIST = LibSym.LIST();
        let NAME = LibSym.NAME();
        let OP = LibSym.OP();
        let STR = LibSym.STR();
        let UOP = LibSym.UOP();

        let FSPECTAB = Eval.fspectab();
        let TYPETAB = Eval.typetab();
        let FERRFS = "expected %S argument";
        let FERRARGV = Array.new(1);

        let context = Collection.new();
        let symtab = Collection.new();
        do symtab.push(HashTable.new(15));

        return;
    }


    function void kill() {

        do FSPECTAB.dispose();
        do TYPETAB.dispose();
        do FERRFS.dispose();
        do FERRARGV.dispose();

        while (context.length() > 0) {
            do LibSym.destroyList(context.pop());
        }
        do context.dispose();

        while (symtab.length() > 0) {
            do LibSym.destroyHashTable(symtab.pop());
        }
        do symtab.dispose();

        return;
    }


    /** format specifiers must not map to themselves
     */
    function Array fspectab() {
        var int i;
        var Array fspectab;

        let fspectab = Array.new(5);  /* magic number! */
        let i = 0;

        let fspectab[i] = 68;
        let fspectab[i+1] = INT;
        let i = i + 2;

        let fspectab[i] = 83;
        let fspectab[i+1] = STR;
        let i = i + 2;

        let fspectab[i] = null;

        return fspectab;
    }


    function Array typetab() {
        var int i;
        var Array typetab;

        let typetab = Array.new(5);  /* magic number! */
        let i = 0;

        let typetab[i] = INT;
        let typetab[i+1] = "integer";
        let i = i + 2;

        let typetab[i] = STR;
        let typetab[i+1] = "string";
        let i = i + 2;

        let typetab[i] = null;

        return typetab;
    }


    function Symbol arg(Symbol arg) {
        var int type;

        if (arg = null) {
            return null;
        }

        let type = arg.meta();

        if (type = NAME)  { return Eval.name(arg);  }
        if (type = ARTEX) { return Eval.artex(arg); }
        if (type = FMTEX) { return Eval.fmtex(arg); }
        if (type = BLOCK) { return Eval.block(arg); }
        if (type = LIST)  { return Eval.list(arg);  }
        if (type = INDEX) { return Eval.index(arg); }

        return arg;
    }


    function Symbol name(Symbol name) {
        var String tag;
        var Symbol p;

        let tag = name.data();
        do name.setTag(tag);
        let p = Eval.lookup(tag);

        if (p = null) {
            do LibIO.error("undefined name");
            return name;
        }

        do name.setData(p.data());
        do name.setMeta(p.meta());

        return name;
    }


    function Symbol lookup(String s) {
        var int i;
        var HashTable table;
        var Symbol sym;

        if (Eval.isArg(s)) {
            return Eval.lookupArg(s);
        }

        let i = 0;
        while (i < symtab.length()) {
            let table = symtab.nth(i);
            let sym = table.lookup(s);
            if (~(sym = null)) {
                return sym;
            }
            let i = i + 1;
        }

        return null;
    }


    function boolean isArg(String s) {
        var char c;
        var int i;

        if (s.length() < 2) {
            return false;
        }

        if (~(s.charAt(0) = 36)) {
            return false;
        }

        let i = 1;
        while (i < s.length()) {
            let c = s.charAt(i);
            if ( (c<48) | (c>57) ) {
                return false;
            }
            let i = i + 1;
        }

        return true;
    }


    function Symbol lookupArg(String s) {
        var int i;
        var String t;
        var Collection argv;

        if (context.length() = 0) {
            return null;
        }

        let t = Str.dup(s);
        do Str.shift(t, 1, 0);
        let i = t.intValue();
        do t.dispose();

        let argv = context.nth(0);

        if (~(i < argv.length())) {
            do LibIO.error("undefined name");
            // todo: unexpected 's';
            return null;
        }

        return Eval.arg(argv.nth(i));
    }


    function Symbol artex(Symbol artex) {
        var Collection q;

        let q = artex.data();

        if (q.length() = 0) {
            do q.dispose();
            do artex.setMeta(null);
        } else {
            do artex.setData(Eval.arithmeticExpression(q));
            do artex.setMeta(INT);
        }

        return artex;
    }


    function int arithmeticExpression(Collection queue) {
        var int lo, ro;  /* left, right operand */
        var int n;
        var Collection stack;
        var Symbol tok;

        let stack = Collection.new();

        while (queue.length() > 0) {

            let tok = queue.pop();

            if (tok.meta() = UOP) {
                if (stack.length() = 0) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(queue);
                    do stack.dispose();
                    do tok.dispose();
                    return 0;
                }
                do stack.push(Eval.uoperate(stack.pop(), tok.data()));
            } else { if ( (tok.meta()&OP) = OP) {
                if (stack.length() < 2) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(queue);
                    do stack.dispose();
                    do tok.dispose();
                    return 0;
                }
                let ro = stack.pop();
                let lo = stack.pop();
                do stack.push(Eval.operate(lo, ro, tok.data()));
            } else {
                do Eval.arg(tok);
                if (~(tok.meta() = INT)) {
                    do LibIO.error("expected integer");
                    do LibSym.destroyList(queue);
                    do LibSym.destroySym(tok);
                    do stack.dispose();
                    return 0;
                }
                do stack.push(tok.data());
            }}

            do tok.dispose();
        }

        let n = stack.pop();

        if (stack.length() > 0) {
            do LibIO.error("expected operator");
        }

        do stack.dispose();
        do queue.dispose();

        return n;
    }


    function int uoperate(int n, int op) {

        if (op =  43) { return Math.abs(n); }
        if (op =  45) { return -n;          }
        if (op = 126) { return ~n;          }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function int operate(int m, int n, int op) {

        if ( ((op=47) | (op=37)) & (n=0) ) {
            do LibIO.error("division by zero");
            return 0;
        }

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }
        if (op =  94) { return (m|n) & ~(m&n); }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return Vector.mod(m, n); }

        if (op = 6161) { return   m = n;  }
        if (op = 3361) { return ~(m = n); }
        if (op =   60) { return   m < n;  }
        if (op =   62) { return   m > n;  }
        if (op = 6061) { return  (m<n) | (m=n); }
        if (op = 6261) { return  (m>n) | (m=n); }

        do LibIO.error("unrecognized operator");
        return 0;
    }


    function Symbol fmtex(Symbol fmtex) {
        do fmtex.setData(Eval.formatExpression(fmtex.data()));
        do fmtex.setMeta(STR);
        return fmtex;
    }


    function String formatExpression(Collection argv) {
        var boolean fspec;
        var int c;
        var int a, i;
        var int type;
        var Array fargv;
        var String s, t;
        var Symbol arg;

        let arg = Eval.arg(argv.pop());

        if (arg = null) {
            do LibIO.error("expected format string");
            do LibSym.destroyList(argv);
            return "";
        }

        if (~(arg.meta() = STR)) {
            do LibIO.error("expected format string");
            do LibSym.destroyList(argv);
            do LibSym.destroySym(arg);
            return "";
        }

        let s = arg.data();
        do arg.dispose();

        if (s.length() < 2) {
            do LibSym.destroyList(argv);
            return Str.dup(s);
        }

        let fargv = Array.new(s.length()/2);
        let fspec = false;
        let a = 0;

        let i = 0;
        while (i < s.length()) {
            let c = s.charAt(i);
            if ( fspec & ~(c=ESC) ) {

                let arg = Eval.arg(argv.nth(a));

                if (arg = null) {
                    do LibIO.error("expected format argument");
                    do LibSym.destroyList(argv);
                    do s.dispose();
                    return "";
                }

                let type = Lex.escape(c, FSPECTAB);

                if (type = c) {
                    do LibIO.error("unrecognized format specifier");
                    do LibSym.destroyList(argv);
                    do s.dispose();
                    return "";
                }

                if (~(arg.meta() = type)) {
                    let FERRARGV[0] = Lex.escape(type, TYPETAB);
                    do LibIO.error(Str.format(FERRFS, FERRARGV));
                    do LibSym.destroyList(argv);
                    do s.dispose();
                    return "";
                }

                let fargv[a] = arg.data();
                let a = a + 1;
            }

            let fspec = ~fspec & (c=ESC);
            let i = i + 1;
        }

        if (fspec) {
            do LibIO.error("expected format specifier");
            let t = "";
        } else {
            let t = Str.format(s, fargv);
        }

        do LibSym.destroyList(argv);
        do fargv.dispose();

        return t;
    }


    function Symbol block(Symbol arg) {
        var Symbol block;

        let block = Exec.block(arg.data());

        if (block = null) {
            do arg.setMeta(null);
            return arg;
        }

        do arg.setData(block.data());
        do arg.setMeta(block.meta());
        do block.dispose();

        return arg;
    }


    function Symbol list(Symbol arg) {
        var int i;
        var Collection list;

        let list = arg.data();
        let i = 0;
        while (i < list.length()) {
            do Eval.arg(list.nth(i));
            let i = i + 1;
        }

        return arg;
    }


    function Symbol index(Symbol ref) {
        var int i;
        var Collection l;
        var Symbol name, index;
        var Symbol deref;

        let l = ref.data();
        let name = Eval.arg(l.pop());
        if (~(name.meta() = LIST)) {
            do LibIO.error("expected list");
            do LibSym.destroySym(name);
            return ref;
        }

        let index = Eval.arg(l.pop());
        if (~(index.meta() = INT)) {
            do LibIO.error("expected integer");
            do LibSym.destroySym(index);
            do LibSym.destroySym(name);
            return ref;
        }

        do l.dispose();
        let l = name.data();

        let i = index.data();
        if ( (i<0) | ~(i<l.length()) ) {
            do LibIO.error("invalid index");
            do LibSym.destroySym(name);
            do index.dispose();
            return ref;
        }

        let deref = l.nth(i);

        do LibSym.destroySym(name);
        do index.dispose();

        do ref.setData(deref.data());
        do ref.setMeta(deref.meta());

        return ref;
    }


    function int condition(Symbol arg) {
        var int c;
        var String cs;
        var Collection cl;
        var Symbol cp;

        let cp = Eval.arg(LibSym.copySym(arg));

        if (cp.meta() = STR) {
            let cs = cp.data();
            let c = cs.length();
        } else { if (cp.meta() = LIST) {
            let cl = cp.data();
            let c = cl.length();
        } else {
            let c = cp.data();
        }}

        do LibSym.destroySym(cp);

        return c;
    }


    function void pushContext(Symbol arg0, Collection argv) {
        do argv.push(Symbol.new(null, STR, arg0.tag()));
        do arg0.setTag(null);
        do context.push(argv);
        do symtab.push(HashTable.new(3));
        return;
    }


    function void dropContext() {
        var Collection argv;

        do LibSym.clearList(context.pop());
        do LibSym.destroyHashTable(symtab.pop());

        return;
    }


    function void install(String name, int type, int value) {
        do LibSym.install(symtab.nth(0), name, type, value);
        return;
    }

}
