class Canvas {

    field int bottom, left, right, top;
    field int braces;
    field int repeat;
    field String PS1, PS2, ps;
    field String TKN_DLMS, EXP_DLMS;
    field String ADDS, BLANKS, EQS, MULS, RBLOCKS, EQOPS, LOGOPS, PERCENTS;
    field String CL_DLMS;
    field String fName;
    field TextBox tb;
    field Turtle t;
    field HashTable symtab;
    field Symbol block, blocks, cmdp, cmds;

    static int
        NULL,
        BLK,
        CMD,
        CMDLIN,
        FUNC,
        INT,
        STR,
        SYM,

        ASSGN,
        BLOCK,
        CLEAR,
        FORWARD,
        FUNCTION,
        PENDOWN,
        PENUP,
        PRINT,
        REPEAT,
        TURNLEFT,
        TURNRIGHT,
        QUIT,
        _ECHO;

    constructor Canvas new(int i, int j, int h, int w,
                           String ps1, String ps2) {

        let symtab = HashTable.new();

        do initKWs();

        let top = i;
        let left = j;
        let bottom = i + h;
        let right = j + w;
        let block = null;
        let blocks = null;
        let braces = 0;
        let repeat = 1;
        let fName = null;
        let PS1 = ps1;
        let PS2 = ps2;
        let ps = PS1;
        let TKN_DLMS = " =";
        let EXP_DLMS = "=!<>&|+-*/%";
        let BLANKS = " ";
        let EQS = "=";
        let RBLOCKS = "({";
        let PERCENTS = "%";
        let LOGOPS = "&|";
        let EQOPS = "=!<>";
        let CL_DLMS = String.new(5);
        do CL_DLMS.appendChar(34);
        do Str.cat(CL_DLMS, TKN_DLMS);
        do Str.cat(CL_DLMS, RBLOCKS);
        let ADDS = "+-";
        let MULS = "*/%";

        let tb = TextBox.new(i, j, h, w);
        let t = newTurtle();

        return this;
    }

    method void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do TKN_DLMS.dispose();
        do EXP_DLMS.dispose();
        do t.dispose();
        do tb.dispose();
        do Memory.deAlloc(this);
        return;
    }

    /* intialize key words and internal symbols */
    method void initKWs() {
        var int i;

        let NULL   = Const.NULL();
        let BLK    = Const.BLK();
        let CMD    = Const.CMD();
        let CMDLIN = Const.CMDLIN();
        let FUNC   = Const.FUNC();
        let INT    = Const.INT();
        let STR    = Const.STR();
        let SYM    = Const.SYM();

        let ASSGN     = Const.ASSGN();
        let BLOCK     = Const.BLOCK();
        let CLEAR     = Const.CLEAR();
        let FORWARD   = Const.FORWARD();
        let FUNCTION  = Const.FUNCTION();
        let PENDOWN   = Const.PENDOWN();
        let PENUP     = Const.PENUP();
        let PRINT     = Const.PRINT();
        let REPEAT    = Const.REPEAT();
        let TURNLEFT  = Const.TURNLEFT();
        let TURNRIGHT = Const.TURNRIGHT();
        let QUIT      = Const.QUIT();

        do installKW("{",         CMD, BLOCK);
        do installKW("CLEAR",     CMD, CLEAR);
        do installKW("FORWARD",   CMD, FORWARD);
        do installKW("FUNCTION",  CMD, FUNCTION);
        do installKW("PENDOWN",   CMD, PENDOWN);
        do installKW("PENUP",     CMD, PENUP);
        do installKW("PRINT",     CMD, PRINT);
        do installKW("REPEAT",    CMD, REPEAT);
        do installKW("TURNLEFT",  CMD, TURNLEFT);
        do installKW("TURNRIGHT", CMD, TURNRIGHT);
        do installKW("QUIT",      CMD, QUIT);

        return;
    }

    method void installKW(String name, int type, int val) {
        do symtab.install(name, type, val);
        do name.dispose();
        return;
    }

    method void clear() {
        do t.dispose();
        do tb.clear();
        let t = newTurtle();
        return;
    }

    method Turtle newTurtle() {
        return Turtle.new(((2*left) + (right-left)) * 4,
                           ((2*bottom) + (top-bottom)) * 5,
                           90);
    }

    method Symbol ready(Symbol p) {
        if (~(p = null)) {
            do Canvas.clearSym(p);
        }
        return ps;
    }

    /* execute a command line */
    method Symbol exec(String s) {
        var int cmd;
        var Symbol argv;

        if (s = null) {
            return null;
        }

        if (s.length() = 0) {
            return null;
        }

        let argv = eval(s, 0);

        if (argv = null) {
            //do Error.send("null argv"); // ##DB##
            //do Error.set(1);  // null argv
            return null;
        }

        if (argv.type() = NULL) {
            do Error.send("unrecognized token"); // ##DB##
            do Error.set(1);  // unrecognized token
            return null;
        }

        if (argv.type() = CMD) {
            let cmd = argv.value();
        } else { if (argv.type() = FUNC) {
            do call(argv);
            let cmd = NULL;
        } else {
            return argv;
        }}

        /*if (cmd = _ECHO)            { do echo(argv);               }
        else {*/ if (cmd = ASSGN)     { do doAssign(argv.next());    }
        else { if (cmd = BLOCK)     { do doBlock(argv);            }
        else { if (cmd = CLEAR)     { do doClear(argv.next());     }
        else { if (cmd = FORWARD)   { do doForward(argv.next());   }
        else { if (cmd = FUNCTION)  { do doFunction(argv.next());  }
        else { if (cmd = PENDOWN)   { do doPendown(argv.next());   }
        else { if (cmd = PENUP)     { do doPenup(argv.next());     }
        else { if (cmd = PRINT)     { do doPrint(argv.next());     }
        else { if (cmd = REPEAT)    { do doRepeat(argv.next());    }
        else { if (cmd = TURNLEFT)  { do doTurnleft(argv.next());  }
        else { if (cmd = TURNRIGHT) { do doTurnright(argv.next()); }
        else { if (cmd = QUIT)      { do doQuit(argv.next());      }
        /*else {
            return argv;*/
        }}}}}}}}}}}//}

        do Canvas.clearSym(argv);

        return null;
    }

    method void call(Symbol argv) {
        var int n, type;
        var String arg, intfs;
        var Symbol p;

        let intfs = "$%d";
        let n = 1;
        let p = argv.next();
        while (~(p = null)) {
            do symtab.install(Str.format(intfs, n), p.type(), p.value());
            let n = n + 1;
            let p = p.next();
        }

        do execBlock(argv.value());

        do intfs.dispose();

        return;
    }

    method void execBlock(Symbol b) {
        var int blkd;

        let blkd = braces;
        let braces = 0;
        while (~(b = null)) {
            do exec(b.value());
            let b = b.next();
        }
        let braces = blkd;
        return;
    }

    method Symbol eval(String s, int i) {
        var char c;
        var int j;
        var String t;

        if ( (s.length()=0) | (s.length()=i) ) {
            return null;
        }

        let i = Str.lskip(s, 32, i);
        let j = Str.index(s, CL_DLMS, i);

        if ( (j+1) < s.length()) {
            if (s.charAt(j) = 61) {
                if (j = 0) {
                    do Error.send("equal at index 0");  // ##DB##
                    do Error.set(1);
                    return null;
                }
                if ( ~( ((s.charAt(j-1)=33)
                      |  (s.charAt(j-1)=60))
                      | ((s.charAt(j+1)=61)
                      |  (s.charAt(j-1)=62)) ) ) {
                    return evalAssgn(s, i);
                }
            }
        } /* todo: cldlm at EOS */

        return evalArgList(s, i);
    }

    method Symbol evalAssgn(String s, int i) {
        var String t;
        var Symbol argv;

        if (s.charAt(i) = 61) {
            do Error.send("no name in assignment");  // ##DB##
            do Error.set(1);
            return null;
        }

        let t = String.new(s.length());
        let i = Str.tkn(s, t, EQS, i);
        let argv = Symbol.new(null, CMD, ASSGN);
        do argv.append(evalName(t));
        do t.dispose();
        do argv.append(evalArgList(s, i+1));  // arglist for error check later

        return argv;
    }

    method Symbol evalName(String s) {
        /* todo: this */
        return Symbol.new(s, null, null);
    }

    method Symbol evalArgList(String s, int i) {
        var String t;
        var Symbol argv;

        let t = String.new(s.length());
        let i = Str.lskip(s, 32, i);

        if (i = s.length()) {
            return null;
        }

        if (s.charAt(i) = 34) {
            let i = Str.quotes(s, t, i);
        } else { if (s.charAt(i) = 123) {
            let i = Str.block(s, t, 123, 125, i);
        } else {
            let i = Str.tkn(s, t, BLANKS, i);
        }}

        let argv = evalWord(t);
        do t.dispose();

        if (i < s.length()) {
            do argv.append(evalArgList(s, i+1));
        }

        return argv;
    }

    method Symbol evalWord(String s) {
        var int i;
        var String t;
        var Symbol argv;

        if (s.length() = 0) {
            return null;
        }

        //let i = Str.lskip(s, 32, 0);

        if (s.charAt(0) = 123) {
            return evalBlock(s, i);
        }

        return evalExpression(s);
    }

    method Symbol evalBlock(String s, int i) {
        return null;
    }

    method Symbol evalExpression(String s) {
        var char c;

        let c = s.charAt(0);

        if (c = 34) {
            return Symbol.new(null, STR, evalStringExpr(s));
        }

        if ( (((c|32)>96) & ((c|32)<123))
                & (Str.index(s, EXP_DLMS, 0)=s.length()) ) {
            return evalSymbolExpr(s);
        }

        return Symbol.new(null, INT, evalIntExpr(s, 0));
    }

    method String evalStringExpr(String s) {
        do s.eraseLastChar();
        do Str.shift(s, 1, 0);
        return Str.dup(format(s));
    }

    method String format(String s) {
        var int i;

        let i = -2;

        while (i < s.length()) {

            let i = Str.index(s, PERCENTS, i+2);

            if ((i+1) < s.length()) {
                if (s.charAt(i+1) = 81) {
                    do s.setCharAt(i, 34);
                } else { if (s.charAt(i+1) = 80) {
                    do s.setCharAt(i, 37);
                } else { if (s.charAt(i+1) = 78) {
                    do s.setCharAt(i, 128);
                } else {
                    do Error.send("unrecognized format specifier");  // ##DB##
                    do Error.set(1);
                    do t.dispose();
                    return null;
                }}}

                do Str.shift(s, 1, i+1);

            }  // todo: error no fspec
        }

        return s;
    }

    method Symbol evalSymbolExpr(String s) {
        var Symbol p;

        let p = symtab.lookup(s);
        if (p = null) {
            do Error.send("undefined symbol");  // ##DB##
            do Error.set(1);
            return null;
        }
        return Symbol.new(null, p.type(), p.value());
    }

    method int evalIntExpr(String s, int i) {
        var int n;
        var String t;

        let t = String.new(s.length());
        let i = Str.tkn(s, t, RBLOCKS, i);

        if (t.length() = 0) {
            if (s.charAt(i) = 40) {
                let i = Str.block(s, t, 40, 41, i);
                if (i > s.length()) {
                    do t.dispose();
                    do Error.send("unclosed parnetheses");  // ##DB##
                    do Error.set(1);
                    return 0;
                }
            } else { if (s.charAt(i) = 123) {
                let i = Str.block(s, t, 123, 125, i);
                if (i > s.length()) {
                    /* todo: build block */
                }
            }}
            let n = evalBlockExpr(t);
            if (i < s.length()) {
                let n = operate(n, evalIntExpr(s, i+1), s.charAt(i));
            }
        } else {
            if (i < s.length()) {
                do t.eraseLastChar();  /* kill op */
                let n = operate(evalLogicExpr(t, 0), evalIntExpr(s, i),
                                s.charAt(i-1));
            } else {
                let n = evalLogicExpr(t, 0);
            }
        }

        do t.dispose();

        return n;
    }

    method int evalBlockExpr(String s) {
        var int n;
        var String t;

        if (s.charAt(0) = 40) {
            do s.eraseLastChar();
            do Str.shift(s, 1, 0);
            return evalIntExpr(s, 0);
        }

        return n;
    }

    method int evalLogicExpr(String s, int i) {
        var int n;
        var String t;

        let t = String.new(s.length());
        let i = Str.tkn(s, t, LOGOPS, i);
        let n = evalEqualityExpr(t, 0);
        if (i < s.length()) {
            let n = operate(n, evalLogicExpr(s, i+1), s.charAt(i));
        }
        do t.dispose();
        return n;
    }

    method int evalEqualityExpr(String s, int i) {
        var char op;
        var int n;
        var String t;

        let t = String.new(s.length());
        let i = Str.tkn(s, t, EQOPS, i);
        let n = evalAddExpr(t, 0);
        if (i < s.length()) {
            let op = s.charAt(i);
            if (s.charAt(i+1) = 61) {
                let i = i + 1;
                let op = 200 + op;
            }
            let n = operate(n, evalEqualityExpr(s, i+1), op);
        }
        do t.dispose();
        return n;
    }

    method int evalAddExpr(String s, int i) {
        var int n;
        var String t;

        let t = String.new(s.length());
        let i = Str.tkn(s, t, ADDS, i);
        let n = evalMulExpr(t, 0);
        if (i < s.length()) {
            let n = operate(n, evalAddExpr(s, i+1), s.charAt(i));
        }
        do t.dispose();
        return n;
    }

    method int evalMulExpr(String s, int i) {
        var int n;
        var String t;

        let t = String.new(s.length());
        let i = Str.tkn(s, t, MULS, i);
        let n = evalTerm(t);
        if (i < s.length()) {
            let n = operate(n, evalMulExpr(s, i+1), s.charAt(i));
        }
        do t.dispose();
        return n;
    }

    method int evalTerm(String s) {
        var Symbol p;

        if ( (s.charAt(0)>47) & (s.charAt(0)<58) ) {
            return s.intValue();
        }

        let p = evalSymbolExpr(s);

        if (Error.isSet()) {
            return 0;
        }

        if (~(p.type() = INT)) {
            do Error.send("non integer symbol in int expr");  // ##DB##
            do Error.set(1);
            return 0;
        }

        return p.value();
    }

    method int operate(int m, int n, char op) {

        if (op =  38) { return m & n; }
        if (op = 124) { return m | n; }

        if (op =  43) { return m + n; }
        if (op =  45) { return m - n; }
        if (op =  42) { return m * n; }
        if (op =  47) { return m / n; }
        if (op =  37) { return lib.mod(m, n); }

        if (op = 261) { return   m = n;  }
        if (op = 233) { return ~(m = n); }
        if (op =  60) { return   m < n;  }
        if (op =  62) { return   m > n;  }
        if (op = 260) { return  (m=n) | (m<n); }
        if (op = 262) { return  (m=n) | (m>n); }

        do Error.send("unrecognized operator");  // ##DB##
        do Error.set(1);
        return 0;
    }

    method void doAssign(Symbol arg) {
        var Symbol p;

        if (arg = null) {
            do Error.set(1);  // no symbol name
            return;
        }

        let p = arg.next();

        if (p = null) {
            do Error.set(1);  // no value to assign
            return;
        }

        if (~(p.next() = null)) {
            do Error.set(1);  // unexpected token
            return;
        }

        if (p.type() = STR) {
            do symtab.install(arg.name(), p.type(), Str.dup(p.value()));
        } else {
            do symtab.install(arg.name(), p.type(), p.value());
        }

        return;
    }

    method void doBlock(Symbol arg) {
        if (arg = null) {
            do Error.set(1);  // doBlock(): arg is null
            return;
        }

        if ( (~(arg.type()=CMD)) & (~(arg.value()=BLOCK)) ) {
            do Error.set(1);  // doBlock(): not CMD or not BLOCK
            return;
        }

        /* might not */
        if (~(arg.next() = null)) {
            do Error.set(1);  // token after lbrace
            return;
        }

        let braces = braces + 1;
        do pushBlock(block);
        let block = null;
        let ps = PS2;

        return;
    }

    method void doClear(Symbol arg) {
        do clear();
        return;
    }

    method void doForward(Symbol arg) {
        do t.forward(arg.value());
        return;
    }

    method void doFunction(Symbol arg) {

        if (arg = null) {
            do Error.set(1);  // no function name
            return;
        }

        if (~(arg.type() = SYM)) {
            //do Error.set(1);  // no function name
            //return;
        }

        let fName = Str.dup(arg.name());

        return;
    }

    method void doPendown(Symbol arg) {
        do t.pendown();
        return;
    }

    method void doPenup(Symbol arg) {
        do t.penup();
        return;
    }

    method void doPrint(Symbol arg) {
        return;
    }

    method void doRepeat(Symbol arg) {
        let repeat = arg.value();
        return;
    }

    method void doTurnleft(Symbol arg) {
        do t.turnleft(arg.value());
        return;
    }

    method void doTurnright(Symbol arg) {
        do t.turnright(arg.value());
        return;
    }

    method void doQuit(Symbol arg) {
        do Sys.halt();
        return;
    }

    method void echo(Symbol sym) {
        if (sym.type() = STR) {
            do Error.send(sym.value());
        } else {
            do echoInt(sym);
        }
        return;
    }

    method void echoInt(Symbol sym) {
        var String s;

        let s = String.new(5);
        do s.setInt(sym.value());
        do Error.send(s);
        return;
    }

    method void pushBlock(Symbol blk) {
        var Symbol top;

        let top = Symbol.new(null, SYM, blk);
        do top.append(blocks);
        let blocks = top;
        return;
    }

    method Symbol popBlock() {
        var Symbol blk, top;

        let top = blocks;
        let blocks = blocks.next();
        let blk = top.value();
        do top.dispose();
        return blk;
    }

    method void pushCmd(Symbol cmd) {
        var Symbol top;

        let top = Symbol.new(null, SYM, cmd);
        do top.append(cmds);
        let cmds = top;
        return;
    }

    method Symbol popCmd() {
        var Symbol cmd, top;

        let top = cmds;
        let cmds = cmds.next();
        let cmd = top.value();
        do top.dispose();
        return cmd;
    }

    function void clearSym(Symbol sym) {
        var int type;
        var String s;
        var Symbol p;

        while (~(sym = null)) {
            let p = sym;
            let sym = sym.next();

            let type = p.type();
            if ( (type=STR) | (type=CMDLIN) ) {
                let s = p.value();
                if (~(s = null)) {
                    do s.dispose();
                }
            } else { if (type = BLK) {
                do Canvas.clearSym(p.value());
            }}
            do p.dispose();
        }

        return;
    }

}
