class Canvas {

    field int bottom, left, right, top;
    field boolean inBlock;
    field String PS1, PS2, ps;
    field String fName;
    field TextBox tb;
    field Turtle t;
    field HashTable symtab;
    field Symbol block;

    static int
        CMD,
        CMDLIN,
        FUNC,
        INT,
        OP,
        STR,
        SYM,

        BLOCK,
        CLEAR,
        FORWARD,
        FUNCTION,
        PENDOWN,
        PENUP,
        PRINT,
        REPEAT,
        TURNLEFT,
        TURNRIGHT,
        QUIT;

    constructor Canvas new(int i, int j, int h, int w,
                           String ps1, String ps2) {
        let top = i;
        let left = j;
        let bottom = i + h;
        let right = j + w;
        let inBlock = false;
        let fName = null;
        let PS1 = ps1;
        let PS2 = ps2;
        let ps = PS1;
        let tb = TextBox.new(i, j, h, w);
        let symtab = HashTable.new();

        let CMD    = const.CMD();
        let CMDLIN = const.CMDLIN();
        let FUNC   = const.FUNC();
        let INT    = const.INT();
        let OP     = const.OP();
        let STR    = const.STR();
        let SYM    = const.SYM();

        do initKWs();
        do Error.set(0);  // init
        do getTurtle();

        return this;
    }

    method void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do t.dispose();
        do tb.dispose();
        do Memory.deAlloc(this);
        return;
    }

    method void initKWs() {
        var int i;

        let i = 0;
        do installKW("BLOCK",     CMD, i);  let BLOCK     = i;  let i = i + 1;
        do installKW("CLEAR",     CMD, i);  let CLEAR     = i;  let i = i + 1;
        do installKW("FORWARD",   CMD, i);  let FORWARD   = i;  let i = i + 1;
        do installKW("FUNCTION",  CMD, i);  let FUNCTION  = i;  let i = i + 1;
        do installKW("PENDOWN",   CMD, i);  let PENDOWN   = i;  let i = i + 1;
        do installKW("PENUP",     CMD, i);  let PENUP     = i;  let i = i + 1;
        do installKW("PRINT",     CMD, i);  let PRINT     = i;  let i = i + 1;
        do installKW("REPEAT",    CMD, i);  let REPEAT    = i;  let i = i + 1;
        do installKW("TURNLEFT",  CMD, i);  let TURNLEFT  = i;  let i = i + 1;
        do installKW("TURNRIGHT", CMD, i);  let TURNRIGHT = i;  let i = i + 1;
        do installKW("QUIT",      CMD, i);  let QUIT      = i;

        return;
    }

    method void installKW(String name, int type, int val) {
        do symtab.install(name, type, val);
        do name.dispose();
        return;
    }

    method void clear() {
        do t.dispose();
        do tb.clear();
        do getTurtle();
        return;
    }

    method void getTurtle() {
        let t = Turtle.new(((2*left) + (right-left)) * 4,
                           ((2*bottom) + (top-bottom)) * 5,
                           90);
        return;
    }

    /* stub */
    method String exec(String s) {
        var int cmd, type, nval;
        var Symbol arg, argv;

        if (s.length() = 0) {
            return ps;
        }

        if (inBlock) {
            if (false) { // s == "}"
                // install function here (if fName)?
                // execute block
            } else {
                do block.append(Symbol.new(null, CMDLIN, Str.dup(s)));
            }
            return ps;
        }

        let argv = Parser.parse(s);
        do deref(argv);
        do eval(argv);
        let arg = argv.next();

        if (arg.value() = 61) {
            let arg = eval(arg.next());
                           /* argv! */   /* arg! */  /* arg! */
            do symtab.install(argv.value(), arg.type(), arg.value());
            return ps;
        }

        if (argv.type() = CMD) {
            let cmd = argv.value();
        } else {
            let argv = eval(argv);
            do echo(argv);
            return ps;
        }

/*
            if (arg = null) {
                do Error.set(0);  // too few arguments
            } else {
                do t.forward(arg.value());
            }

            if (~(arg = null)) {
                do Error.set(0);  // too many arguments
            } else {
                do t.pendown();
            }

            if (~(arg = null)) { //block
                do Error.set(0);  // no newline after lbrace
            } else {
                let block = Symbol.new(null, CMDLIN, null);
                let inBlock = true;
                let ps = PS2;
            }
*/

        if (cmd = BLOCK)            { do block(arg);     }
        else { if (cmd = CLEAR)     { do clear(arg);     }
        else { if (cmd = FORWARD)   { do forward(arg);   }
        else { if (cmd = FUNCTION)  { do function(arg);  }
        else { if (cmd = PENDOWN)   { do pendown(arg);   }
        else { if (cmd = PENUP)     { do penup(arg);     }
        else { if (cmd = PRINT)     { do print(arg);     }
        else { if (cmd = REPEAT)    { do repeat(arg);    }
        else { if (cmd = TURNLEFT)  { do turnleft(arg);  }
        else { if (cmd = TURNRIGHT) { do turnright(arg); }
        else { if (cmd = QUIT)      { do quit(arg);      }
        }}}}}}}}}}

        do Canvas.clearSym(argv);

        return ps;
    }


    method void deref(Symbol sym) {
        var Symbol p;

        while (~(sym = null)) {
            if (sym.type() = SYM) {
                let p = symtab.lookup(sym.name());
                do sym.setName(p.name());
                do sym.setType(p.type());
                do sym.setValue(p.value());
            }
            let sym = sym.next();
        }

        return;
    }

    /* stub */
    method void eval(Symbol sym) {
        var int type;

        if (sym = null) {
            return;
        }

        let type = sym.type();

        if (type = CMD) { do  eval(sym.next()); }
        else { if ( (type=INT) | (type=OP) ) { do evalInt(sym); }
        else { if (type = STR) { do evalStr(sym); }}}

        return;
    }

    method void evalInt(Symbol sym) {
        return;
    }

    method void evalStr(Symbol sym) {
        var String s, t;
        var Symbol p;

        
        return;
    }

/*
    method int expr(String s, int i) {
        var char c, op;
        var int n, sLen;
        var String token;
        var Symbol p;

        if (s.charAt(0) = 34) {     // "
            do s.eraseLastChar();
            do Str.shift(s, 1);
            return Str.dup(s);
        }

        if (s.charAt(0) = 40) {     // (
            do Str.shift(s, 1);
        }

        let token = String.new(s.length());

        let i = Str.tkn(s, token, EX_DLMS, i);

        let c = token.charAt(0);
        if ( (c>47) & (c<58) ) {
            let n = String.intValue(token);
        } else {
            let c = c | 32;
            if ( (c>96) & (c<127) ) {
                if (i < s.length()) {  /* fix me * /
                    let op = token.charAt(token.length()-1);
                    do token.eraseLastChar();
        return;
    }

    method void evalStr(Symbol sym) {
        return;
    }

    method int expr(String s, int i) {
        var char c, op;
        var int n, sLen;
        var String token;
        var Symbol p;

        if (s.charAt(0) = 34) {     // "
            do s.eraseLastChar();
            do Str.shift(s, 1);
            return Str.dup(s);
        }

        if (s.charAt(0) = 40) {     // (
            do Str.shift(s, 1);
        }

        let token = String.new(s.length());

        let i = Str.tkn(s, token, EX_DLMS, i);

        let c = token.charAt(0);
        if ( (c>47) & (c<58) ) {
            let n = String.intValue(token);
        } else {
            let c = c | 32;
            if ( (c>96) & (c<127) ) {
                if (i < s.length()) {  /* fix me * /
                    let op = token.charAt(token.length()-1);
                    do token.eraseLastChar();
                } else {
                    let op = 0;
                }
                let p = symtab.lookup(token);
                /* todo: type check * /
                let n = p.value();
            } else {
                do Error.set(0);  // Parser.expr(): unrecognized char
                return null;
            }
        }

        if (i < s.length()) {
            if (op=0) {let op = token.charAt(token.length()-1);}
            if ( (op=42) | ((op=47) | (op=37)) ) {
                do Str.truncate(token);
                let i = Str.tkn(s, token, EX_DLMS, i);
                let n = operate(n, expr(token, 0), op);
                let op = token.charAt(token.length()-1);
            }
            if (i < s.length()) {
                let n = operate(n, expr(s, i), op);
            }
        }

        do token.dispose();

        return n;
    }

*/
    method int operate(int m, int n, char op) {
        if (op = 43) { return m + n; }
        if (op = 45) { return m - n; }
        if (op = 42) { return m * n; }
        if (op = 47) { return m / n; }
        if (op = 37) { return lib.mod(m, n); }
        do Error.set(0);  // unrecognized operator
        return 0;
    }

    method void block(Symbol arg) {
        return;
    }

//    method void clear(Symbol arg) {
//        return;
//    }

    method void forward(Symbol arg) {
        return;
    }

    method void function(Symbol arg) {
        return;
    }

    method void pendown(Symbol arg) {
        return;
    }

    method void penup(Symbol arg) {
        return;
    }

    method void print(Symbol arg) {
        return;
    }

    method void repeat(Symbol arg) {
        return;
    }

    method void turnleft(Symbol arg) {
        return;
    }

    method void turnright(Symbol arg) {
        return;
    }

    method void quit(Symbol arg) {
        return;
    }

    method void echo(Symbol sym) {
        return;
    }

    function void clearSym(Symbol sym) {
        var int type;
        var String s;
        var Symbol p;

        while (~(sym = null)) {
            let p = sym;
            let sym = sym.next();

            let type = p.type();
            if ( (type=STR) | (type=CMDLIN) ) {
                let s = p.value();
                if (~(s = null)) {
                    do s.dispose();
                }
            }
            do p.dispose();
        }

        return;
    }

}
