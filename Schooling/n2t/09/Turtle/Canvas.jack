class Canvas {

    static int bottom, left, right, top;
    static int braces;
    static int repeat;
    static String PS1, PS2, ps;
    static String fName;
    static TextBox tb;
    static Turtle t;
    static Symbol block, blocks, cmdp, cmds;

    static int
        NULL,
        BLK,
        CMD,
        CMDLIN,
        FUNC,
        INT,
        STR,
        SYM,

        ASSGN,
        BLOCK,
        CLEAR,
        FORWARD,
        FUNCTION,
        PENDOWN,
        PENUP,
        PRINT,
        REPEAT,
        TURNLEFT,
        TURNRIGHT,
        QUIT,
        _ECHO;


    function void init(int i, int j, int h, int w, String ps1, String ps2) {

        do Canvas.initKWs();

        let top = i;
        let left = j;
        let bottom = i + h;
        let right = j + w;
        let block = null;
        let blocks = null;
        let braces = 0;
        let repeat = 1;
        let fName = null;
        let PS1 = ps1;
        let PS2 = ps2;
        let ps = PS1;

        let tb = TextBox.new(i, j, h, w);
        let t = Canvas.newTurtle();

        return;
    }


    function void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do TKN_DLMS.dispose();
        do EXP_DLMS.dispose();
        do t.dispose();
        do tb.dispose();
        return;
    }


    /* intialize key words and internal symbols */
    function void initKWs() {
        var int i;

        let NULL   = Const.NULL();
        let BLK    = Const.BLK();
        let CMD    = Const.CMD();
        let CMDLIN = Const.CMDLIN();
        let FUNC   = Const.FUNC();
        let INT    = Const.INT();
        let STR    = Const.STR();
        let SYM    = Const.SYM();

        let ASSGN     = Const.ASSGN();
        let BLOCK     = Const.BLOCK();
        let CLEAR     = Const.CLEAR();
        let FORWARD   = Const.FORWARD();
        let FUNCTION  = Const.FUNCTION();
        let PENDOWN   = Const.PENDOWN();
        let PENUP     = Const.PENUP();
        let PRINT     = Const.PRINT();
        let REPEAT    = Const.REPEAT();
        let TURNLEFT  = Const.TURNLEFT();
        let TURNRIGHT = Const.TURNRIGHT();
        let QUIT      = Const.QUIT();

        return;
    }


    function void clear() {
        do t.dispose();
        do tb.clear();
        let t = Canvas.newTurtle();
        return;
    }


    function Turtle newTurtle() {
        return Turtle.new(((2*left) + (right-left)) * 4,
                           ((2*bottom) + (top-bottom)) * 5,
                           90);
    }


    /* prepare to execute next command line */
    function Symbol ready(Symbol p) {

        do Canvas.clearSym(p);

        if (Eval.isStoring()) {
            return PS2;
        }

        return PS1;
    }


    /* execute a command line */
    function Symbol exec(String s) {
        var int cmd;
        var Symbol argv;

        if (s = null) {
            return null;
        }

        if (s.length() = 0) {
            return null;
        }

        let argv = Eval.eval(s);

        if (Error.isSet()) {
            do Canvas.clearSym(argv);
            return null;
        }

        if (argv = null) {
            return null;
        }

        if (argv.type() = NULL) {
            do Error.send("unrecognized token"); // ##DB##
            do Error.set(1);  // unrecognized token
            do Canvas.clearSym(argv);
            return null;
        }

        if (argv.type() = CMD) {
            do Canvas.execute(argv);
        } else { if (argv.type() = FUNC) {
            do Canvas.call(argv);
        } else {
            return argv;
        }}

        do Canvas.clearSym(argv);

        return null;
    }

    function void execute(Symbol argv) {
        var int cmd;

        if (argv = null) {
            return;
        }

        let cmd = argv.value();

        if (cmd = ASSGN)            { do Canvas.doAssign(argv.next());    }
        else { if (cmd = BLOCK)     { do Canvas.doBlock(argv);            }
        else { if (cmd = CLEAR)     { do Canvas.doClear(argv.next());     }
        else { if (cmd = FORWARD)   { do Canvas.doForward(argv.next());   }
        else { if (cmd = FUNCTION)  { do Canvas.doFunction(argv.next());  }
        else { if (cmd = PENDOWN)   { do Canvas.doPendown(argv.next());   }
        else { if (cmd = PENUP)     { do Canvas.doPenup(argv.next());     }
        else { if (cmd = PRINT)     { do Canvas.doPrint(argv.next());     }
        else { if (cmd = REPEAT)    { do Canvas.doRepeat(argv.next());    }
        else { if (cmd = TURNLEFT)  { do Canvas.doTurnleft(argv.next());  }
        else { if (cmd = TURNRIGHT) { do Canvas.doTurnright(argv.next()); }
        else { if (cmd = QUIT)      { do Canvas.doQuit(argv.next());      }
        }}}}}}}}}}}

        return;
    }

    function void call(Symbol argv) {
        var int n, type;
        var Array farg;
        var String arg, name, fpres;
        var Symbol p;

        let farg = Array.new(1);
        let fpres = "$%d";
        let n = 1;
        let p = argv.next();
        while (~(p = null)) {
            let farg[0] = n;
            let name = Str.format(fpres, farg);
            do symtab.install(name, p.type(), p.value());
            do name.dispose();
            let n = n + 1;
            let p = p.next();
        }

        do Canvas.execBlock(argv.value());

        do farg.dispose();
        do fpres.dispose();

        return;
    }


    function void execBlock(Symbol b) {
        var int blkd;

        let blkd = braces;
        let braces = 0;
        while (~(b = null)) {
            do Canvas.exec(b.value());
            let b = b.next();
        }
        let braces = blkd;
        return;
    }


    function void doAssign(Symbol arg) {
        do Eval.assign(arg.value());
        do Canvas.execute(arg.next());
        return;
    }


    function void doBlock(Symbol arg) {
        if (arg = null) {
            do Error.set(1);  // doBlock(): arg is null
            return;
        }

        if ( (~(arg.type()=CMD)) & (~(arg.value()=BLOCK)) ) {
            do Error.set(1);  // doBlock(): not CMD or not BLOCK
            return;
        }

        /* might not */
        if (~(arg.next() = null)) {
            do Error.set(1);  // token after lbrace
            return;
        }

        let braces = braces + 1;
        do Canvas.pushBlock(block);
        let block = null;
        let ps = PS2;

        return;
    }


    function void doClear(Symbol arg) {
        do Canvas.clear();
        return;
    }


    function void doForward(Symbol arg) {
        do t.forward(arg.value());
        return;
    }


    function void doFunction(Symbol arg) {

        if (arg = null) {
            do Error.set(1);  // no function name
            return;
        }

        if (~(arg.type() = SYM)) {
            //do Error.set(1);  // no function name
            //return;
        }

        let fName = Str.dup(arg.name());

        return;
    }


    function void doPendown(Symbol arg) {
        do t.pendown();
        return;
    }


    function void doPenup(Symbol arg) {
        do t.penup();
        return;
    }


    function void doPrint(Symbol arg) {
        return;
    }


    function void doRepeat(Symbol arg) {
        let repeat = arg.value();
        return;
    }


    function void doTurnleft(Symbol arg) {
        do t.turnleft(arg.value());
        return;
    }


    function void doTurnright(Symbol arg) {
        do t.turnright(arg.value());
        return;
    }


    function void doQuit(Symbol arg) {
        do Sys.halt();
        return;
    }

/*
    function void echo(Symbol sym) {
        if (sym.type() = STR) {
            do Error.send(sym.value());
        } else {
            do echoInt(sym);
        }
        return;
    }

    function void echoInt(Symbol sym) {
        var String s;

        let s = String.new(5);
        do s.setInt(sym.value());
        do Error.send(s);
        return;
    }
*/


    function void pushBlock(Symbol blk) {
        var Symbol top;

        let top = Symbol.new(null, SYM, blk);
        do top.append(blocks);
        let blocks = top;
        return;
    }


    function Symbol popBlock() {
        var Symbol blk, top;

        let top = blocks;
        let blocks = blocks.next();
        let blk = top.value();
        do top.dispose();
        return blk;
    }


    function void pushCmd(Symbol cmd) {
        var Symbol top;

        let top = Symbol.new(null, SYM, cmd);
        do top.append(cmds);
        let cmds = top;
        return;
    }


    function Symbol popCmd() {
        var Symbol cmd, top;

        let top = cmds;
        let cmds = cmds.next();
        let cmd = top.value();
        do top.dispose();
        return cmd;
    }


    function void clearSym(Symbol sym) {
        var int type;
        var String s;
        var Symbol p;

        while (~(sym = null)) {
            let p = sym;
            let sym = sym.next();

            let type = p.type();
            if ( (type=STR) | (type=CMDLIN) ) {
                let s = p.value();
                if (~(s = null)) {
                    do s.dispose();
                }
            } else { if (type = BLK) {
                do Canvas.clearSym(p.value());
            }}
            do p.dispose();
        }

        return;
    }

}
