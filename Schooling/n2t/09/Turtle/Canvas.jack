class Canvas {

    field int bottom, left, right, top;
    field String PS1, PS2, ps;
    field TextBox tb;
    field Turtle t;
    field HashTable symtab;
    field Parser parser;

    static int
        TYPE,
        CMD,
        CMDLIN,
        FUNC,
        INT,
        STR,

        BLOCK,
        CLEAR,
        FORWARD,
        FUNCTION,
        PENDOWN,
        PENUP,
        PRINT,
        REPEAT,
        TURNLEFT,
        TURNRIGHT,
        QUIT;

    constructor Canvas new(int i, int j, int h, int w,
                           String ps1, String ps2) {
        let top = i;
        let left = j;
        let bottom = i + h;
        let right = j + w;
        let PS1 = ps1;
        let PS2 = ps2;
        let ps = PS1;
        let tb = TextBox.new(i, j, h, w);
        let symtab = HashTable.new();
        let parser = Parser.new(symtab);

        //do initKWs();
        do Error.set(0);
        do getTurtle();

        return this;
    }

    method void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do parser.dispose();
        do t.dispose();
        do tb.dispose();
        do Memory.deAlloc(this);
        return;
    }

/*
    method void initKWs() {
        var int i;
        var Symbol p;

        let i = 0;
        do installKW("type",    0, i);  let i = i + 1;  // 'type' must be first
        do installKW("cmd",     0, i);  let i = i + 1;
        do installKW("cmdlin",  0, i);  let i = i + 1;
        do installKW("func",    0, i);  let i = i + 1;
        do installKW("int",     0, i);  let i = i + 1;
        do installKW("str",     0, i);

        let p = symtab.lookup("type");    let TYPE   = p.value();
        let p = symtab.lookup("cmd");     let CMD    = p.value();
        let p = symtab.lookup("cmdlin");  let CMDLIN = p.value();
        let p = symtab.lookup("func");    let FUNC   = p.value();
        let p = symtab.lookup("int");     let INT    = p.value();
        let p = symtab.lookup("str");     let STR    = p.value();

        let i = 0;
        do installKW("BLOCK",     CMD, i);  let i = i + 1;
        do installKW("CLEAR",     CMD, i);  let i = i + 1;
        do installKW("FORWARD",   CMD, i);  let i = i + 1;
        do installKW("FUNCTION",  CMD, i);  let i = i + 1;
        do installKW("PENDOWN",   CMD, i);  let i = i + 1;
        do installKW("PENUP",     CMD, i);  let i = i + 1;
        do installKW("PRINT",     CMD, i);  let i = i + 1;
        do installKW("REPEAT",    CMD, i);  let i = i + 1;
        do installKW("TURNLEFT",  CMD, i);  let i = i + 1;
        do installKW("TURNRIGHT", CMD, i);  let i = i + 1;
        do installKW("QUIT",      CMD, i);

        let BLOCK     = parser.lookup("BLOCK");
        let CLEAR     = parser.lookup("CLEAR");
        let FORWARD   = parser.lookup("FORWARD");
        let FUNCTION  = parser.lookup("FUNCTION");
        let PENUP     = parser.lookup("PENUP");
        let PENDOWN   = parser.lookup("PENDOWN");
        let PRINT     = parser.lookup("PRINT");
        let PRINT     = parser.lookup("REPEAT");
        let TURNLEFT  = parser.lookup("TURNLEFT");
        let TURNRIGHT = parser.lookup("TURNRIGHT");
        let QUIT      = parser.lookup("QUIT");

        return;
    }
*/

    method void installKW(String name, int type, int val) {
        do symtab.install(name, type, val);
        do name.dispose();
        return;
    }

    method void clear() {
        do t.dispose();
        do tb.clear();
        do getTurtle();
        return;
    }

    method void getTurtle() {
        let t = Turtle.new(((2*left) + (right-left)) * 4,
                           ((2*bottom) + (top-bottom)) * 5,
                           90);
        return;
    }

    /* stub */
    method String exec(String s) {
        var int cmd, type, nval;
        var int n;
        var String sval;
        var Symbol argv, p;

        if (s.length() = 0) {
            return ps;
        }

        let argv = parser.parse(s);

        if (argv = true) {
            return ps;
        }

        if (argv = null) {
            do Error.set(0);  // Canvas.exec(): parser ruturned null
            return ps;
        }

        if (~(argv.type() = CMD)) {
            do Error.set(0);  // Canvas.exec(): argv.type not CMD
            return ps;
        }

        let cmd = argv.value();
        let p = argv;
        let argv = argv.next();
        do p.dispose();

        if (cmd = PENUP) {
            if (~(argv = null)) {
                do Error.set(1);
            } else {
                do t.penup();
            }
        }
        if (cmd = CLEAR) {
            if (~(argv = null)) {
                do Error.set(1);
            } else {
                do clear();
            }
        }
        if (cmd = PENDOWN) {
            if (~(argv = null)) {
                do Error.set(1);
            } else {
                do t.pendown();
            }
        }
        if (cmd = TURNLEFT) {
            if (argv = null) {
                do Error.set(2);
            } else { if (~(argv.next() = null)) {
                do Error.set(1);
            } else {
                do t.turnleft(argv.value());
            }}
        }
        if (cmd = TURNRIGHT) {
            if (argv = null) {
                do Error.set(2);
            } else { if (~(argv.next() = null)) {
                do Error.set(1);
            } else {
                do t.turnright(argv.value());
            }}
        }
        if (cmd = FORWARD) {
            if (argv = null) {
                do Error.set(2);
            } else { if (~(argv.next() = null)) {
                do Error.set(1);
            } else {
                do t.forward(argv.value());
            }}
        }
        if (cmd = BLOCK) {
            let ps = PS2;
        }

/* will be ...
        if (cmd = BLOCK) {
        } else { if (cmd = CLEAR) {
        } else { if (cmd = FORWARD) {
        } else { if (cmd = FUNCTION) {
        } else { if (cmd = PENDOWN) {
        } else { if (cmd = PENUP) {
        } else { if (cmd = PRINT) {
        } else { if (cmd = REPEAT) {
        } else { if (cmd = TURNLEFT) {
        } else { if (cmd = TURNRIGHT) {
        } else { if (cmd = QUIT) {
        }}}}}}}}}}}
*/

        if (~(argv = null)) {
            do argv.dispose();
        }

        return ps;
    }

}
/*

    method int lookup(String s) {
        var Symbol p;

        let p = symtab.lookup(s);
        return p.value();
    }

    /* stub * /
    method Symbol parse(String s) {
        var char op;
        var int i;
        var String name, token;
        var Symbol argv;

        do Str.truncate(_token);

        let i = Str.tkn(s, _token, ST_DLMS, 0);

        if (i = s.length()) {
            return Symbol.dup(symtab.lookup(_token));
        }

        let op = _token.charAt(_token.length()-1);
        do _token.eraseLastChar();

        if (op = 61) {
            let name = Str.dup(_token);
            do Str.truncate(_token);
            if (Str.tkn(s, _token, ST_DLMS, i) < s.length()) {
                do Error.set(0);  // too many arguments for assignment
                return null;
            }
            let argv = eval(_token);
            do symtab.install(name, argv.type(), argv.value());
            do argv.dispose();
            return true;  // don't like this
        }

        if (~(op = 32)) {
            do Error.set(0);  // Parser.parse(): op not ' ' or =
        }

        let argv = Symbol.dup(symtab.lookup(_token));

        if (argv = null) {
            do Error.set(0);  // Parser.parse(): sym not found
            return null;
        }

        if (~(argv.type() = CMD)) {
            do Error.set(0);  // Parser.parse(): sym not cmd
            return null;
        }

        while (i < s.length()) {
            do Str.truncate(_token);
            let i = Str.tkn(s, _token, ST_DLMS, i);
            if (_token.charAt(_token.length()-1) = 32) {
                do _token.eraseLastChar();
            }
            do argv.append(eval(_token));
        }

        return argv;
    }

    /* stub * /
    method Symbol eval(String s) {
        var char c;
        var Symbol arg;

        let c = s.charAt(0);

        if (c = 34) {
            if (s.charAt(s.length()-1) = 34) {
                let arg = Symbol.new(lib.NULLS(), STR, expr(s, 0));
            } else {
                do Error.set(0);  // Parser.eval(): open string
                return null;
            }

        } else { if ( ((c>47) & (c<58)) | (((c|32)>96) & ((c|32)<123)) ) {
            /* todo: string symbols * /
            let arg = Symbol.new(s, INT, expr(s, 0));

        } else {
            do Error.set(0);  // Parser.eval(): unrecognized char
            return null;
        }}

        return arg;
    }

    method int expr(String s, int i) {
        var char c, op;
        var int n, sLen;
        var String token;
        var Symbol p;

        if (s.charAt(0) = 34) {     // "
            do s.eraseLastChar();
            do Str.shift(s, 1);
            return Str.dup(s);
        }

        if (s.charAt(0) = 40) {     // (
            do Str.shift(s, 1);
        }

        let token = String.new(s.length());

        let i = Str.tkn(s, token, EX_DLMS, i);

        let c = token.charAt(0);
        if ( (c>47) & (c<58) ) {
            let n = String.intValue(token);
        } else {
            let c = c | 32;
            if ( (c>96) & (c<127) ) {
                if (i < s.length()) {  /* fix me * /
                    let op = token.charAt(token.length()-1);
                    do token.eraseLastChar();
                } else {
                    let op = 0;
                }
                let p = symtab.lookup(token);
                /* todo: type check * /
                let n = p.value();
            } else {
                do Error.set(0);  // Parser.expr(): unrecognized char
                return null;
            }
        }

        if (i < s.length()) {
            if (op=0) {let op = token.charAt(token.length()-1);}
            if ( (op=42) | ((op=47) | (op=37)) ) {
                do Str.truncate(token);
                let i = Str.tkn(s, token, EX_DLMS, i);
                let n = operate(n, expr(token, 0), op);
                let op = token.charAt(token.length()-1);
            }
            if (i < s.length()) {
                let n = operate(n, expr(s, i), op);
            }
        }

        do token.dispose();

        return n;
    }

    method int operate(int m, int n, char op) {
        if (op = 43) { return m + n; }
        if (op = 45) { return m - n; }
        if (op = 42) { return m * n; }
        if (op = 47) { return m / n; }
        if (op = 37) { return lib.mod(m, n); }
        return 0;
    }

    method void clearBlock() {
        var String s;
        var Symbol p, q;

        return;
    }
}
*/
