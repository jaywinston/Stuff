class Canvas {

    field int bottom, left, right, top;
    field int blkDepth;
    field String PS1, PS2, ps;
    field String TKN_DLMS, EXP_DLMS;
    field String fName;
    field TextBox tb;
    field Turtle t;
    field HashTable symtab;
    field Symbol block, blocks;

    static int
        NULL,
        BLK,
        CMD,
        CMDLIN,
        FUNC,
        INT,
        STR,
        SYM,

        BLOCK,
        CLEAR,
        FORWARD,
        FUNCTION,
        PENDOWN,
        PENUP,
        PRINT,
        REPEAT,
        TURNLEFT,
        TURNRIGHT,
        QUIT,
        _ECHO;

    constructor Canvas new(int i, int j, int h, int w,
                           String ps1, String ps2) {
        let top = i;
        let left = j;
        let bottom = i + h;
        let right = j + w;
        let block = null;
        let blocks = null;
        let blkDepth = 0;
        let fName = null;
        let PS1 = ps1;
        let PS2 = ps2;
        let ps = PS1;
        let tb = TextBox.new(i, j, h, w);
        let symtab = HashTable.new();
        let TKN_DLMS = " =";
        let EXP_DLMS = "+-*/%";
        let t = newTurtle();

        do initKWs();

        return this;
    }

    method void dispose() {
        do PS1.dispose();
        do PS2.dispose();
        do TKN_DLMS.dispose();
        do EXP_DLMS.dispose();
        do t.dispose();
        do tb.dispose();
        do Memory.deAlloc(this);
        return;
    }

    /* intialize key words and internal symbols */
    method void initKWs() {
        var int i;

        let i = 0;
        let NULL   = i;  let i = i + 1;
        let BLK    = i;  let i = i + 1;
        let CMD    = i;  let i = i + 1;
        let CMDLIN = i;  let i = i + 1;
        let FUNC   = i;  let i = i + 1;
        let INT    = i;  let i = i + 1;
        let STR    = i;  let i = i + 1;
        let SYM    = i;  let i = i + 1;

        let BLOCK     = i;  let i = i + 1;
        let CLEAR     = i;  let i = i + 1;
        let FORWARD   = i;  let i = i + 1;
        let FUNCTION  = i;  let i = i + 1;
        let PENDOWN   = i;  let i = i + 1;
        let PENUP     = i;  let i = i + 1;
        let PRINT     = i;  let i = i + 1;
        let REPEAT    = i;  let i = i + 1;
        let TURNLEFT  = i;  let i = i + 1;
        let TURNRIGHT = i;  let i = i + 1;
        let QUIT      = i;  let i = i + 1;
        let _ECHO = i;

        do installKW("{",         CMD, BLOCK);
        do installKW("CLEAR",     CMD, CLEAR);
        do installKW("FORWARD",   CMD, FORWARD);
        do installKW("FUNCTION",  CMD, FUNCTION);
        do installKW("PENDOWN",   CMD, PENDOWN);
        do installKW("PENUP",     CMD, PENUP);
        do installKW("PRINT",     CMD, PRINT);
        do installKW("REPEAT",    CMD, REPEAT);
        do installKW("TURNLEFT",  CMD, TURNLEFT);
        do installKW("TURNRIGHT", CMD, TURNRIGHT);
        do installKW("QUIT",      CMD, QUIT);

        return;
    }

    method void installKW(String name, int type, int val) {
        do symtab.install(name, type, val);
        do name.dispose();
        return;
    }

    method void clear() {
        do t.dispose();
        do tb.clear();
        let t = newTurtle();
        return;
    }

    method Turtle newTurtle() {
        return Turtle.new(((2*left) + (right-left)) * 4,
                           ((2*bottom) + (top-bottom)) * 5,
                           90);
    }

    /* parse and execute a command line */
    method String exec(String s) {
        var int i, cmd, sLen;
        var String token;
        var Symbol argv;

        let sLen = s.length();

        if (sLen = 0) {
            return ps;
        }

        if (blkDepth > 0) {
            if (s.charAt(0) = 125) { // s == "}"
                if (s.length() > 1) {
                    do Error.set(1);  // token after rbrace
                    return ps;
                }
                if (fName = null) {
                    do execBlock(block);
                    do Canvas.clearSym(block);
                } else {
                    do symtab.install(fName, FUNC, block);
                    do fName.dispose();
                    let fName = null;
                }
                let block = popBlock();
                let ps = PS1;
                return ps;
            } else {
                if (block = null) {
                    let block = Symbol.new(null, CMDLIN, Str.dup(s));
                } else {
                    do block.append(Symbol.new(null, CMDLIN, Str.dup(s)));
                }
            }
            return ps;
        }

        let token = String.new(sLen);
        let i = Str.tkn(s, token, TKN_DLMS, 0);
        let argv = eval(token);
        do token.dispose();

        if (i < sLen) { if (s.charAt(i) = 61) {  // '='
            let token = String.new(sLen);
            let i = Str.tkn(s, token, TKN_DLMS, i+1);
            if (i < sLen) {
                do Error.set(1); // too many args: assignment
                return ps;
            }
            do argv.append(eval(token));
            do doInstall(argv);
            do token.dispose();
            do Canvas.clearSym(argv);
            return ps;
        }}

        while (i < sLen) {
            let token = String.new(sLen);
            let i = Str.tkn(s, token, TKN_DLMS, i+1);
            do argv.append(eval(token));
            do token.dispose();
        }

        if (argv = null) {
            do Error.set(1);  // null argv
            return ps;
        }

        if (argv.type() = NULL) {
            do Error.set(1);  // unrecognized symbol
            return ps;
        }

        if (argv.type() = CMD) {
            let cmd = argv. value();
        } else { if (argv.type() = FUNC) {
            do execBlock(argv.value());
            return ps;
        } else {
            let cmd = _ECHO;
        }}

        if (cmd = _ECHO)            { do echo(argv); }
        else { if (cmd = BLOCK)     { do doBlock(argv);            }
        else { if (cmd = CLEAR)     { do doClear(argv.next());     }
        else { if (cmd = FORWARD)   { do doForward(argv.next());   }
        else { if (cmd = FUNCTION)  { do doFunction(argv.next());  }
        else { if (cmd = PENDOWN)   { do doPendown(argv.next());   }
        else { if (cmd = PENUP)     { do doPenup(argv.next());     }
        else { if (cmd = PRINT)     { do doPrint(argv.next());     }
        else { if (cmd = REPEAT)    { do doRepeat(argv.next());    }
        else { if (cmd = TURNLEFT)  { do doTurnleft(argv.next());  }
        else { if (cmd = TURNRIGHT) { do doTurnright(argv.next()); }
        else { if (cmd = QUIT)      { do doQuit(argv.next());      }
        }}}}}}}}}}}

        do Canvas.clearSym(argv);

        return ps;
    }

    method void execBlock(Symbol b) {
        var int blkd;
        var Symbol p;

        let blkd = blkDepth;
        let blkDepth = 0;
        let p = b;
        while (~(p = null)) {
            do exec(p.value());
            let p = p.next();
        }
        let blkDepth = blkd;
        return;
    }

    method Symbol eval(String s) {
        var char c;

        if (s.length() = 0) {
            return null;
        }

        let c = s.charAt(0);

        if ( ((c>47) & (c<58)) | (c|1=41) ) {
            return Symbol.new(null, INT, evalInt(s, 0));
        } else { if (c = 34) {
            return Symbol.new(null, STR, evalStr(s));
        }}
        return evalSym(s);
    }

    method int evalInt(String s, int i) {
        var char op;
        var int n, sLen;
        var String token;

        let sLen = s.length();

        let token = String.new(sLen);
        if (s.charAt(i) = 40) {
            let i = Str.parens(s, token, i+1);
            if (i < 0) {
                do Error.set(1);  // unbalanced parens
                return -i;
            }
            let n = evalInt(token, 0);
        } else {
            let i = Str.tkn(s, token, EXP_DLMS, i);
            let n = intExpr(token);
        }

        do token.dispose();

        if (i = sLen) {
            return n;
        }

        let op = s.charAt(i);
            
        if ( (s.charAt(i+1)=40) | ((op=43) | (op=45)) ) {
            return operate(n, evalInt(s, i+1), op);
        } else { if ( ((op|5)=47) | (op=37) ) {
            let token = String.new(sLen);
            let i = Str.tkn(s, token, EXP_DLMS, i+1);
            if (i = sLen) {
                return operate(n, intExpr(token), op);
            }
            return operate(operate(n, intExpr(token), op),
                            evalInt(s, i+1), s.charAt(i));
        }}

        return n;
    }

    method int intExpr(String s) {
        var char c;
        var int n;
        var Symbol p;

        let c = s.charAt(0);

        if ( (c>47) & (c<58) ) {
            return String.intValue(s);
        }

        if ( ((c|32)>96) & ((c|32)<123) ) {
            let p = symtab.lookup(s);
            if (p = null) {
                do Error.set(1); // name not in symtab
                return 0;
            }
            if (~(p.type() = INT)) {
                do Error.set(1); // wrong type
                return 0;
            }
            return p.value();
        }

        do Error.set(1); // unexpected token
        return 0;
    }

    method String evalStr(String s) {
        do s.eraseLastChar();
        do Str.shift(s, 1);
        return s;
    }

    method Symbol evalSym(String s) {
        var Symbol p;

        let p =  Symbol.dup(symtab.lookup(s));

        if (p = null) {
            return Symbol.new(s, NULL, NULL);
        }

        return p;
    }

    method int operate(int m, int n, char op) {
        if (op = 43) { return m + n; }
        if (op = 45) { return m - n; }
        if (op = 42) { return m * n; }
        if (op = 47) { return m / n; }
        if (op = 37) { return lib.mod(m, n); }
        do Error.set(1);  // unrecognized operator
        return 0;
    }

    method void doInstall(Symbol sym) {
        var Symbol p;

        let p = sym.next();
        do symtab.install(sym.name(), p.type(), p.value());
        return;
    }

    method void doBlock(Symbol arg) {
        if (arg = null) {
            do Error.set(1);  // doBlock(): arg is null
            return;
        }

        if ( (~(arg.type()=CMD)) & (~(arg.value()=BLOCK)) ) {
            do Error.set(1);  // doBlock(): not CMD or not BLOCK
            return;
        }

        if (~(arg.next() = null)) {
            do Error.set(1);  // token after lbrace
            return;
        }

        do pushBlock(block);
        let block = null;
        let ps = PS2;

        return;
    }

    method void doClear(Symbol arg) {
        do clear();
        return;
    }

    method void doForward(Symbol arg) {
        do t.forward(arg.value());
        return;
    }

    method void doFunction(Symbol arg) {

        if (arg = null) { if (~(arg.type() = STR)) {
            do Error.set(1);  // no function name
            return;
        }}

        do doBlock(arg.next());

        if (Error.isSet()) {
            return;
        }

        let fName = Str.dup(arg.name());

        return;
    }

    method void doPendown(Symbol arg) {
        do t.pendown();
        return;
    }

    method void doPenup(Symbol arg) {
        do t.penup();
        return;
    }

    method void doPrint(Symbol arg) {
        return;
    }

    method void doRepeat(Symbol arg) {
        return;
    }

    method void doTurnleft(Symbol arg) {
        do t.turnleft(arg.value());
        return;
    }

    method void doTurnright(Symbol arg) {
        do t.turnright(arg.value());
        return;
    }

    method void doQuit(Symbol arg) {
        do Sys.halt();
        return;
    }

    method void echo(Symbol sym) {
        if (sym.type() = INT) {
            do echoInt(sym);
        }
        return;
    }

    method void echoInt(Symbol sym) {
        var String s;

        let s = String.new(5);
        do s.setInt(sym.value());
        do Error.send(s);
        return;
    }

    method void pushBlock(Symbol blk) {
        var Symbol top;

        let blkDepth = blkDepth + 1;

        if ( (block=null) & (blocks=null) ) {
            return;
        }

        let top = Symbol.new(null, BLK, blk);
        do top.append(blocks);
        return;
    }

    method Symbol popBlock() {
        var Symbol b, p;

        let blkDepth = blkDepth - 1;
        let p = blocks;
        if (p = null) {
            return null;
        }
        let blocks = blocks.next();
        let b = p.value();
        do p.dispose();
        return b;
    }

    function void clearSym(Symbol sym) {
        var int type;
        var String s;
        var Symbol p;

        while (~(sym = null)) {
            let p = sym;
            let sym = sym.next();

            let type = p.type();
            if ( (type=STR) | (type=CMDLIN) ) {
                let s = p.value();
                if (~(s = null)) {
                    do s.dispose();
                }
            }
            do p.dispose();
        }

        return;
    }

}
