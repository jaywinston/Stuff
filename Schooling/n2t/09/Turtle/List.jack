class List {

    static int INT, LIST, LSP;
    static int APPEND, CLEARLIST, EXTEND, SLICE;

    function void init() {

        let INT = LibSym.INT();
        let LIST = LibSym.LIST();
        let LSP = LibSym.LSP();

        let APPEND    = 0;
        let CLEARLIST = 1;
        let EXTEND    = 2;
        let SLICE     = 3;

        do Eval.install("APPEND", LSP, APPEND);
        do Eval.install("CLEARLIST", LSP, CLEARLIST);
        do Eval.install("EXTEND", LSP, EXTEND);
        do Eval.install("SLICE", LSP, SLICE);

        return;
    }


    function Symbol process(int cmd, Collection argv) {

        if (cmd = APPEND)    { return List.append(argv);    }
        if (cmd = CLEARLIST) { return List.clearList(argv); }
        if (cmd = EXTEND)    { return List.extend(argv);    }
        if (cmd = SLICE)     { return List.slice(argv);     }

        return null;
    }


    function void append(Collection argv) {
        var Collection l;
        var Symbol p;

        let p = Eval.arg(argv.pop());
        let l = p.data();
        do l.append(Eval.arg(argv.pop()));

        return;
    }


    function void clearList(Collection argv) {
        var Collection l;
        var Symbol p;

        let p = Eval.arg(argv.pop());
        let l = p.data();
        do LibSym.clearList(l);

        return;
    }


    function void extend(Collection argv) {
        var Collection l;
        var Symbol p;

        let p = Eval.arg(argv.pop());
        let l = p.data();
        let p = Eval.arg(argv.pop());
        do l.extend(p.data());

        return;
    }


    function Collection slice(Collection argv) {
        var int i, j;
        var Collection l;
        var Symbol lp, p;

        let lp = Eval.arg(argv.pop());

        if (~(lp.meta() = LIST)) {
            do LibIO.error("expected list");
            do LibSym.destroySym(lp);
            return null;
        }

        let l = lp.data();

        let p = Eval.arg(argv.pop());

        if (p = null) {
            let p = Symbol.new(null, LIST, l.slice(0, l.length()-1));
            do LibSym.destroySym(lp);
            return p;
        }

        if (~(p.meta() = INT)) {
            do LibIO.error("expected integer");
            do LibSym.destroySym(p);
            return null;
        }

        let i = p.data();
        do p.dispose();

        let p = Eval.arg(argv.pop());

        if (~(p.meta() = INT)) {
            do LibIO.error("expected integer");
            do LibSym.destroySym(p);
            return null;
        }

        let j = p.data();
        do p.dispose();

        let p = Symbol.new(null, LIST, l.slice(i, j));

        do LibSym.destroySym(lp);

        return p;

    }

}
