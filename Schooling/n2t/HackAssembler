#!/usr/bin/env python3


'''a stripped down version of HackAssembler

    Error checking has been replaced with stubs for clarity.'''


import re
import sys


def abort_assembly():
    '''print error message and exit

    This is a stub.'''

    print('error')
    sys.exit()


def mk_A_hack(n):
    return '{:016b}\n'.format(n)

if len(sys.argv) != 2:  # argv[0] == program name
    abort_assembly()    # argv[1] == input file

infile = sys.argv[1]

if not infile.endswith('.asm'):
    abort_assembly()

outfile = infile[:-4] + ".hack"

comp_tab = {
    "0"   : "101010", "!A"  : "110001", "M+1" : "110111", "D-M" : "010011",
    "1"   : "111111", "!M"  : "110001", "D-1" : "001110", "A-D" : "000111",
    "-1"  : "111010", "-D"  : "001111", "A-1" : "110010", "M-D" : "000111",
    "D"   : "001100", "-A"  : "110011", "M-1" : "110010", "D&A" : "000000",
    "A"   : "110000", "-M"  : "110011", "D+A" : "000010", "D&M" : "000000",
    "M"   : "110000", "D+1" : "011111", "D+M" : "000010", "D|A" : "010101",
    "!D"  : "001101", "A+1" : "110111", "D-A" : "010011", "D|M" : "010101"
}

jump_tab = {
    ""    : "000", "JGT" : "001", "JEQ" : "010", "JGE" : "011",
    "JLT" : "100", "JNE" : "101", "JLE" : "110", "JMP" : "111"
}

sym_tab = {
    "SP": 0, "LCL": 1, "ARG": 2, "THIS": 3, "THAT": 4,
    "SCREEN": 16384, "KBD": 24576
}

nsym = 16
re_symbol = re.compile('[$:.\w]+')
re_asm = re.compile('[01ADMEGJLNPQT=;!+&|-]{1,11}')
digit = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9') 


# This is a bit of a misnomer
def decomment(line):
    '''remove comments and external white space'''
    return line.split("//")[0].strip()

with open(infile, "Ur") as fi:
    asm = fi.readlines()

#  install labels to symbol table
maddr = 1  # memory address of cpu instruction for label
for nl, line in enumerate(asm):

    nl += 1  # line number, not index

    # This will make any lines with no code the empty string.
    line = decomment(line)

    if not line:
        continue

    if line.startswith('('):

        sym = line.strip('()')

        if not re_symbol.fullmatch(sym) or sym.startswith(digit):
            abort_assembly()

        if sym in sym_tab:
            abort_assembly()

        sym_tab[sym] = maddr

    else:
        maddr += 1

fo = open(outfile, "w")

# assemble
for nl, line in enumerate(asm):

    nl += 1

    line = decomment(line)

    if not line or line.startswith('('):
        continue

    if line.startswith('@'):  # A instruction

        line = line[1:]

        if line.startswith('R'):
            reg = line[1:]
            if reg.isdigit():
                reg = int(reg)
                if 0 <= reg <= 15:
                    fo.write(mk_A_hack(reg))

        elif re_symbol.fullmatch(line):

            if line.startswith(digit):
                abort_assembly()

            if line not in sym_tab:
                sym_tab[line] = nsym  
                nsym += 1

            ref = sym_tab[line]

            fo.write(mk_A_hack(ref))

        elif line.isdigit():
            fo.write(mk_A_hack(int(line)))

        else:
            abort_assembly()

    else:  # C instruction

        # remove internal whitespace
        line = ''.join(line.split())

        if not re_asm.fullmatch(line)  \
                or line.count('=') > 1 \
                or line.count(';') > 1:
            abort_assembly()

        eq = line.index('=') if '=' in line else 0
        sc = line.index(';') if ';' in line else len(line)

        dest = line[:eq]
        comp = line[eq:sc].strip('=')
        jump = line[sc:].strip(';')

        # build hack line
        hack = '111'

        # a field
        hack += '1' if 'M' in comp else '0'

        # comp field
        if comp not in comp_tab:
            abort_assembly()
        hack += comp_tab[comp]

        # dest field
        if not re.fullmatch('[ADM]*', dest):
            abort_assembly()
        hack += '1' if 'A' in dest else '0'
        hack += '1' if 'D' in dest else '0'
        hack += '1' if 'M' in dest else '0'

        # jump field
        if jump not in jump_tab:
            abort_assembly()
        hack += jump_tab[jump]

        hack += '\n'

        fo.write(hack)

fo.close()
