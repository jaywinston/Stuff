#!/usr/bin/python3

import pathlib
import sys


#
# core program
#


b = [0]  # The Buffer
p = 0    # The Pointer
s = []   # stack for loop addresses
i = 0    # src index
src = ''


def left():
    global p
    if p == 0:
        b.insert(0, 0)
    else:
        p -= 1


def right():
    global p
    p += 1
    if p == len(b):
        b.append(0)


def up():
    b[p] += 1


def down():
    b[p] -= 1


def decide():
    global i
    if b[p]:
        s.append(i - 1)
    else:
        e = i
        n = 1
        while n:
            advance()
            if i == len(src):
                i = e
                fail('unmatched [', 2)
            elif src[i] == '[':
                n += 1
            elif src[i] == ']':
                n -= 1


def repeat():
    global i
    if not s:
        fail('unmatched ]', 3)
    n = s.pop()
    if b[p]:
        i = n


def get():
    try:
        got = sys.stdin.read(1)
        b[p] = ord(got)
    except ValueError as e:
        fail(f'while reading input: not in character set: {got}', 5)


def put():
    try:
        info(chr(b[p]), file=sys.stdout)
    except ValueError as e:
        fail(f'in cell {p}: not in character set: {b[p]}', 4)


TRANSLATIONS = {
    '<': left,
    '>': right,
    '+': up,
    '-': down,
    '[': decide,
    ']': repeat,
    ',': get,
    '.': put,
}


def do_one(instructions):
    instructions.get(src[i], lambda: None)()


def advance():
    global i
    i += 1
    # this breaks debug_arb_txt and idk who should bow to whom
    #while i < len(src) and src[i] not in SCAN_CHARS:
    #    i += 1
    return True


def run():
    while i < len(src):
        do_one(TRANSLATIONS)
        advance()


#
# end core
#


r = 0  # exit status

PRETTY = False
DEBUG = False


def usage():
    print("""\
SYNOPSIS
    bf [-d] [-p] file [file ..]
    bf [-d] [-p] source-string
    bf [-d] [-p]
    bf -h

DESCRIPTION
    bf can be invoked with a list of file names where each file
    contains source text.  The files will be interpreted in the order they
    are listed on the command line.  If any file cannot be found, then all
    non-option arguments are interpreted as source text, in the order they
    are listed on the command line.  If no arguments are provided and the
    -h option is not listed, then stdin will be read and iterpreted as
    source text.  The stdin will be reinitialized after source collection
    and available for use during execution.

OPTIONS
    -d debug    enable non-standard instructions for introspection,
                formatting and program control
                The instructions are:
                _      print a blank
                ~      print a newline
                $      print the source text
                #$     print the length of the source
                %      print the source text 10 characters prior and subsequent
                       to the index
                @      print the current index in the source
                ?      print the buffer
                #?     print the number of cells in the buffer
                ^      print the value of the buffer pointer
                *      print the value of the buffer at the pointer
                :      print the address stack
                #:     print the size of the address stack
                {      print an arbitrary string
                       The string is delimited by '}'.  The delimiters are
                       not printed.  Any character preceded by '\\' is
                       printed literally.  This facilitates printing '}'.
                #{     suppress execution
                       Execution resumes immediately after '}' is encountered
                !      exit immediately
                All printing is to the stderr.
    -p pretty   decorate the debug output
    -h help     print this message and exit
""", end='', flush=True)  # decouple """ from message content for easy editing

# argparse.py?
for a in (argv := list(filter(lambda a: a.startswith('-'), sys.argv[1:]))):
    if 'h' in a:
        usage()
        exit()
    if 'p' in a:
        PRETTY = True
        import pprint  # !!!!! EMBEDDED IMPORT!!!!! NOQA NOQA NOQA!
    if 'd' in a:
        DEBUG = True


def main():
    getsrc()
    tty_setup()
    try:
        run()
        if s:
            fail('unmatched [', 2)
    except (KeyboardInterrupt, DebugExit):
        print()
    except RuntimeError as e:
        print(e, file=sys.stderr)
    except:
        print(report(), file=sys.stderr)
        raise
    finally:
        tty_cleanup()
    exit(r)


def getsrc():
    global src
    try:
        src = ''.join(pathlib.Path(f).read_text() for f in argv)
        if not src:
            src = sys.stdin.read()
            sys.stdin = open('/dev/tty')
    except FileNotFoundError as e:
        src = ''.join(sys.argv[1:])


def tty_setup():
    if sys.stdin.isatty():
        import termios
        global termattrs
        termattrs = termios.tcgetattr(sys.stdin.fileno())
        termios.tcsetattr(
            sys.stdin.fileno(),
            termios.TCSADRAIN,
            # raw mode reads without "Enter"
            termattrs[:3] + [termattrs[3] & ~termios.ICANON] + termattrs[4:])


def tty_cleanup():
    if sys.stdin.isatty():
        import termios
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, termattrs)


def report(m=''):
    lines = src[:i].split('\n')
    line = len(lines)
    col = i + 1 if line == 1 else i - len(' '.join(lines[:-1]))  # improve this
    return f'{m}\nline {line}, column {col}'


def fail(m, e):
    global r
    r = e
    raise RuntimeError(report(m))


def info(*o, file=None):
    def do_print(*o, file=None):
        print(*o, end='', file=file, flush=True)
        return True

    def pretty_info(*o, file=sys.stderr):
        if len(o) == 0:
            out = ''
        elif len(o) == 1:
            if type(o0 := o[0]) is str:  # pformat seems to repr str
                out = o0
            else:
                out = pprint.pformat(o0)
        else:
            out = pprint.pformat(o)
        return do_print(out, file=file)

    def boring_info(*o, file=sys.stderr):
        return do_print(*o, file=file)

    global info  # init self
    info = pretty_info if PRETTY else boring_info

    return info(*o, file=file)


class DebugExit(Exception):
    # idk why empty exception classes are so anti-dogmaed.
    # they're very expressive when used judiciously.
    pass


def debug_exit():
    raise DebugExit


def debug_arbitrary_text(process):  # i just can't help it
    """print an arbitrary string on the stderr or suppress interpretation"""

    # src[i] is now '{'. print until '}' is seen and return.
    # the system will advance past the '}' by normal execution.
    # '\' escapes the next char. there are no esc sequences. (yet... yet)
    # having an esc is to print a literal '}'.
    # just fail off the end on missing '}'.

    def doit():
        advance()  # discard '{'
        while True:
            if src[i] == '}':
                return
            if src[i] == '\\':
                advance()
            process()

    return doit


class PrettyCell(int):
    def __repr__(self):
        return '\033[7m%d\033[0m' % self  # {} recurses here


def debug_print_buffer():
    def pretty_buffer():
        b[p] = PrettyCell(b[p])
        info(b)
        b[p] = int(b[p])

    def boring_buffer():
        info(b)

    global debug_print_buffer  # init self
    debug_print_buffer = pretty_buffer if PRETTY else boring_buffer

    debug_print_buffer()


def debug_macro():
    advance()  # discard '#'
    do_one(MACROS)


MACROS = ()
if DEBUG:
    MACROS = {
        '{': debug_arbitrary_text(advance),
        '?': lambda: info(len(b)),
        ':': lambda: info(len(s)),
        '$': lambda: info(len(src)),
    }
    TRANSLATIONS.update({
        '_': lambda: info(' '),
        '~': lambda: info('\n'),
        '$': lambda: info(src),
        '%': lambda: info(src[max(0, i-10) : i+10]),
        '@': lambda: info(i),
        '?': debug_print_buffer,
        '^': lambda: info(p),
        '*': lambda: info(b[p]),
        ':': lambda: info(s),
        '{': debug_arbitrary_text(lambda: info(src[i]) and advance()),
        '#': debug_macro,
        '!': debug_exit,
    })

SCAN_CHARS = ''.join((*TRANSLATIONS, *MACROS))

main()
